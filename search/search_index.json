{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Fast Healthchecks","text":"<p>Framework-agnostic health checks with integrations for the most popular ASGI frameworks: FastAPI / FastStream / Litestar to help you implement the Health Check API pattern.</p>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>Installation \u2014 install with pip, poetry, or uv; optional extras.</li> <li>Usage \u2014 mount health checks per framework; examples (FastAPI, FastStream, Litestar).</li> <li>Lifecycle and shutdown \u2014 closing cached clients on app shutdown.</li> <li>Probe options \u2014 probe parameters and <code>build_probe_route_options</code>.</li> <li>Running probes without ASGI \u2014 <code>run_probe</code> for CLI, cron, tests.</li> <li>Configuration objects \u2014 <code>config</code> argument and types in <code>fast_healthchecks.checks.configs</code>.</li> <li>URL check and SSRF protection \u2014 <code>block_private_hosts</code> for <code>UrlHealthCheck</code>.</li> <li>DSN formats \u2014 URL schemes for <code>from_dsn()</code>; PostgreSQL TLS certificate rotation.</li> </ul> <p>For API reference (configs, check classes, public API boundary), see API Reference.</p>"},{"location":"SECURITY/","title":"Security policy","text":""},{"location":"SECURITY/#url-checks-and-ssrf","title":"URL checks and SSRF","text":"<p>Health check URLs must come from trusted configuration only. Do not use user-controlled input. For URL/SSRF behaviour, allowed schemes, <code>block_private_hosts</code>, and edge cases, see the SSRF documentation in the docs.</p>"},{"location":"SECURITY/#rabbitmq-default-credentials","title":"RabbitMQ default credentials","text":"<p>The RabbitMQ health check (and <code>RabbitMQConfig</code>) default to <code>user=\"guest\"</code> and <code>password=\"guest\"</code> when not specified (e.g. when parsing a DSN without credentials). Do not use these defaults in production or on any non-local broker. They are intended for local development only. In production, set explicit credentials (e.g. from environment or a secrets manager) or use a DSN that includes the credentials.</p>"},{"location":"SECURITY/#reporting-vulnerabilities","title":"Reporting vulnerabilities","text":"<p>If you believe you have found a security vulnerability, please report it privately. Do not open a public issue.</p> <p>How to report: Send details to the maintainer email in the project's <code>pyproject.toml</code>, or use GitHub Security Advisories for this repository. Include steps to reproduce and impact if possible.</p> <p>We will acknowledge receipt and work on a fix. Please do not disclose the issue publicly until a fix has been released or we have agreed on disclosure timing.</p>"},{"location":"api/","title":"API Reference","text":"<p>The root package <code>__all__</code> is the single source for stable root-level exports. Prefer <code>from fast_healthchecks import Probe, run_probe, healthcheck_shutdown, HealthCheckReport, HealthCheckResult, Check, FunctionConfig</code> and the exception hierarchy (<code>HealthCheckError</code>, <code>HealthCheckTimeoutError</code>, <code>HealthCheckSSRFError</code>). Check classes (e.g. <code>RedisHealthCheck</code>) and other configs are available from <code>fast_healthchecks.checks</code> or their submodules (e.g. <code>fast_healthchecks.checks.redis</code>). See <code>fast_healthchecks.__all__</code> and <code>fast_healthchecks.checks.__all__</code>.</p> <p>Config types (e.g. <code>RedisConfig</code>, <code>UrlConfig</code>) in <code>fast_healthchecks.checks.configs</code> are part of the supported API for passing <code>config=...</code> to check constructors. The <code>to_dict()</code> methods on check classes are for internal test use only and are not part of the supported public API; do not rely on them in production code.</p> <p>Secrets and redaction: Check and config <code>to_dict(redact_secrets=True)</code> redacts credential-style keys (same set as in <code>fast_healthchecks.utils</code>). The structured logging layer used by <code>run_probe</code> does not log config or secrets; see <code>fast_healthchecks.logging</code> and the run_probe docs.</p>"},{"location":"api/#exception-hierarchy-public","title":"Exception hierarchy (public)","text":"<p>The following exceptions are part of the public API and are documented for callers who want to handle them explicitly. Existing code that catches <code>asyncio.TimeoutError</code> or <code>ValueError</code> continues to work, because the new types subclass those.</p> <ul> <li>HealthCheckError \u2014 Base for health-check-related exceptions.</li> <li>HealthCheckTimeoutError \u2014 Raised when a probe or check run times out. Subclass of <code>HealthCheckError</code> and <code>asyncio.TimeoutError</code>.</li> <li>HealthCheckSSRFError \u2014 Raised when URL/host SSRF validation fails (e.g. <code>validate_url_ssrf</code>, <code>validate_host_ssrf_async</code>). Subclass of <code>HealthCheckError</code> and <code>ValueError</code>. See SSRF documentation for behaviour and edge cases.</li> </ul> <p>Models for healthchecks.</p> <p>DSN NewTypes for type hints only.</p> <p>These types annotate DSN strings (e.g. AmqpDsn, RedisDsn) but are not used at runtime by check classes. Each HealthCheckDSN subclass implements its own parse_dsn() and validate_dsn(); dsn.py provides no parsing or validation logic. Use these types to annotate configuration or function parameters.</p>"},{"location":"api/#fast_healthchecks.models.HealthCheckError","title":"<code>HealthCheckError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception for health-check-related failures.</p> <p>Raised or used as a base for timeouts, SSRF validation, and other health-check errors. Subclasses preserve the original exception type (e.g. HealthCheckTimeoutError is also an asyncio.TimeoutError) so existing code that catches TimeoutError or ValueError continues to work.</p> Source code in <code>fast_healthchecks/models.py</code> <pre><code>class HealthCheckError(Exception):\n    \"\"\"Base exception for health-check-related failures.\n\n    Raised or used as a base for timeouts, SSRF validation, and other\n    health-check errors. Subclasses preserve the original exception type\n    (e.g. HealthCheckTimeoutError is also an asyncio.TimeoutError) so\n    existing code that catches TimeoutError or ValueError continues to work.\n    \"\"\"\n</code></pre>"},{"location":"api/#fast_healthchecks.models.HealthCheckReport","title":"<code>HealthCheckReport</code>  <code>dataclass</code>","text":"<p>Report of healthchecks.</p> <p>Attributes:</p> Name Type Description <code>results</code> <code>list[HealthCheckResult]</code> <p>List of healthcheck results.</p> <code>allow_partial_failure</code> <code>bool</code> <p>If True, report is healthy when at least one check passes.</p> Source code in <code>fast_healthchecks/models.py</code> <pre><code>@dataclass(frozen=True)\nclass HealthCheckReport:\n    \"\"\"Report of healthchecks.\n\n    Attributes:\n        results: List of healthcheck results.\n        allow_partial_failure: If True, report is healthy when at least one check passes.\n    \"\"\"\n\n    results: list[HealthCheckResult]\n    allow_partial_failure: bool = False\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return a string representation of the report.\"\"\"\n        return \"\\n\".join(str(result) for result in self.results)\n\n    @property\n    def healthy(self) -&gt; bool:\n        \"\"\"Return whether all healthchecks passed (or allowed partial failure).\"\"\"\n        if self.allow_partial_failure:\n            return any(result.healthy for result in self.results)\n        return all(result.healthy for result in self.results)\n</code></pre>"},{"location":"api/#fast_healthchecks.models.HealthCheckReport.healthy","title":"<code>healthy</code>  <code>property</code>","text":"<p>Return whether all healthchecks passed (or allowed partial failure).</p>"},{"location":"api/#fast_healthchecks.models.HealthCheckReport.__str__","title":"<code>__str__()</code>","text":"<p>Return a string representation of the report.</p> Source code in <code>fast_healthchecks/models.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of the report.\"\"\"\n    return \"\\n\".join(str(result) for result in self.results)\n</code></pre>"},{"location":"api/#fast_healthchecks.models.HealthCheckResult","title":"<code>HealthCheckResult</code>  <code>dataclass</code>","text":"<p>Result of a healthcheck.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of the healthcheck.</p> <code>healthy</code> <code>bool</code> <p>Whether the healthcheck passed.</p> <code>error_details</code> <code>str | None</code> <p>Details of the error if the healthcheck failed.</p> Source code in <code>fast_healthchecks/models.py</code> <pre><code>@dataclass(frozen=True)\nclass HealthCheckResult:\n    \"\"\"Result of a healthcheck.\n\n    Attributes:\n        name: Name of the healthcheck.\n        healthy: Whether the healthcheck passed.\n        error_details: Details of the error if the healthcheck failed.\n    \"\"\"\n\n    name: str\n    healthy: bool\n    error_details: str | None = None\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return a string representation of the result.\"\"\"\n        return f\"{self.name}: {'healthy' if self.healthy else 'unhealthy'}\"\n</code></pre>"},{"location":"api/#fast_healthchecks.models.HealthCheckResult.__str__","title":"<code>__str__()</code>","text":"<p>Return a string representation of the result.</p> Source code in <code>fast_healthchecks/models.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of the result.\"\"\"\n    return f\"{self.name}: {'healthy' if self.healthy else 'unhealthy'}\"\n</code></pre>"},{"location":"api/#fast_healthchecks.models.HealthCheckSSRFError","title":"<code>HealthCheckSSRFError</code>","text":"<p>               Bases: <code>HealthCheckError</code>, <code>ValueError</code></p> <p>Raised when URL or host validation fails (SSRF / block_private_hosts).</p> <p>Subclass of both HealthCheckError and ValueError so that <code>except ValueError</code> still catches it.</p> Source code in <code>fast_healthchecks/models.py</code> <pre><code>class HealthCheckSSRFError(HealthCheckError, ValueError):\n    \"\"\"Raised when URL or host validation fails (SSRF / block_private_hosts).\n\n    Subclass of both HealthCheckError and ValueError so that\n    ``except ValueError`` still catches it.\n    \"\"\"\n</code></pre>"},{"location":"api/#fast_healthchecks.models.HealthCheckTimeoutError","title":"<code>HealthCheckTimeoutError</code>","text":"<p>               Bases: <code>HealthCheckError</code>, <code>TimeoutError</code></p> <p>Raised when a probe or check run exceeds its timeout.</p> <p>Subclass of both HealthCheckError and asyncio.TimeoutError so that <code>except asyncio.TimeoutError</code> or <code>except TimeoutError</code> still catch it.</p> Source code in <code>fast_healthchecks/models.py</code> <pre><code>class HealthCheckTimeoutError(HealthCheckError, asyncio.TimeoutError):\n    \"\"\"Raised when a probe or check run exceeds its timeout.\n\n    Subclass of both HealthCheckError and asyncio.TimeoutError so that\n    ``except asyncio.TimeoutError`` or ``except TimeoutError`` still catch it.\n    \"\"\"\n</code></pre>"},{"location":"api/#checks","title":"Checks","text":"<p>Immutable configuration dataclasses for health checks.</p> <p>Encapsulates connection parameters to avoid long parameter lists (PLR0913) and centralize serialization for to_dict().</p> <p>Type aliases for health checks.</p> <p>Health check that runs a user-provided callable (sync or async).</p> <p>FunctionHealthCheck runs the callable each time the check is executed; sync functions are run in a thread pool via run_in_executor.</p> <p>This module provides a health check class for Redis.</p> <p>Classes:</p> Name Description <code>RedisHealthCheck</code> <p>A class to perform health checks on Redis.</p> Usage <p>The RedisHealthCheck class can be used to perform health checks on Redis by calling it.</p> Example <p>health_check = RedisHealthCheck(     host=\"localhost\",     port=6379, ) result = await health_check() print(result.healthy)</p> <p>This module provides a health check class for Kafka.</p> <p>Classes:</p> Name Description <code>KafkaHealthCheck</code> <p>A class to perform health checks on Kafka.</p> Usage <p>The KafkaHealthCheck class can be used to perform health checks on Kafka by calling it.</p> Example <p>health_check = KafkaHealthCheck(     bootstrap_servers=\"localhost:9092\",     security_protocol=\"PLAINTEXT\", ) result = await health_check() print(result.healthy)</p> <p>This module provides a health check class for MongoDB.</p> <p>Classes:</p> Name Description <code>MongoHealthCheck</code> <p>A class to perform health checks on MongoDB.</p> Usage <p>The MongoHealthCheck class can be used to perform health checks on MongoDB by calling it.</p> Example <p>health_check = MongoHealthCheck(     hosts=[\"host1:27017\", \"host2:27017\"],     # or hosts=\"localhost\",     port=27017,     user=\"myuser\",     password=\"mypassword\",     database=\"mydatabase\" ) result = await health_check() print(result.healthy)</p> <p>This module provides a health check class for OpenSearch.</p> <p>Classes:</p> Name Description <code>OpenSearchHealthCheck</code> <p>A class to perform health checks on OpenSearch.</p> Usage <p>The OpenSearchHealthCheck class can be used to perform health checks on OpenSearch by calling it.</p> Example <p>health_check = OpenSearchHealthCheck(     hosts=[\"localhost:9200\"],     http_auth=(\"username\", \"password\"),     use_ssl=True,     verify_certs=True,     ssl_show_warn=False,     ca_certs=\"/path/to/ca.pem\", ) result = await health_check() print(result.healthy)</p> <p>This module provides a health check class for RabbitMQ.</p> <p>Classes:</p> Name Description <code>RabbitMQHealthCheck</code> <p>A class to perform health checks on RabbitMQ.</p> <p>Security: When using DSN or config without a password (or with default credentials), the library falls back to <code>user=\"guest\"</code> and <code>password=\"guest\"</code>. These defaults are for local development only; do not use them in production or on non-local brokers. See SECURITY.md and :class:<code>RabbitMQConfig</code> docstring.</p> Usage <p>The RabbitMQHealthCheck class can be used to perform health checks on RabbitMQ by calling it.</p> Example <p>health_check = RabbitMQHealthCheck(     host=\"localhost\",     port=5672,     username=\"guest\",     password=\"guest\", ) result = await health_check() print(result.healthy)</p> <p>Health check that performs an HTTP GET to a URL.</p> <p>UrlHealthCheck caches an httpx AsyncClient and supports optional basic auth, SSL verification, and SSRF protection (block_private_hosts).</p> <p>This module provides a health check class for PostgreSQL using asyncpg.</p> <p>Classes:</p> Name Description <code>PostgreSQLAsyncPGHealthCheck</code> <p>A class to perform health checks on a PostgreSQL database using asyncpg.</p> Usage <p>The PostgreSQLAsyncPGHealthCheck class can be used to perform health checks on a PostgreSQL database by connecting to the database and executing a simple query.</p> Example <p>health_check = PostgreSQLAsyncPGHealthCheck(     host=\"localhost\",     port=5432,     user=\"username\",     password=\"password\",     database=\"dbname\" )</p> <p>This module provides a health check for PostgreSQL using psycopg.</p> <p>Classes:</p> Name Description <code>PostgreSQLPsycopgHealthCheck</code> <p>A class for health checking PostgreSQL using psycopg.</p> Usage <p>The PostgreSQLPsycopgHealthCheck class can be used to perform health checks on a PostgreSQL database by connecting to the database and executing a simple query.</p> Example <p>health_check = PostgreSQLPsycopgHealthCheck(     host=\"localhost\",     port=5432,     user=\"username\",     password=\"password\",     database=\"dbname\" )</p>"},{"location":"api/#fast_healthchecks.checks.configs.FunctionConfig","title":"<code>FunctionConfig</code>  <code>dataclass</code>","text":"<p>Configuration for function health check.</p> Source code in <code>fast_healthchecks/checks/configs.py</code> <pre><code>@dataclass(frozen=True)\nclass FunctionConfig:\n    \"\"\"Configuration for function health check.\"\"\"\n\n    args: tuple[object, ...] = ()\n    kwargs: dict[str, object] | None = None\n    timeout: float = DEFAULT_HC_TIMEOUT\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Return config as a dict for serialization.\"\"\"\n        d = asdict(self)\n        d[\"args\"] = list(d.get(\"args\") or ())\n        d[\"kwargs\"] = dict(d[\"kwargs\"]) if d.get(\"kwargs\") else {}\n        return d\n</code></pre>"},{"location":"api/#fast_healthchecks.checks.configs.FunctionConfig.to_dict","title":"<code>to_dict()</code>","text":"<p>Return config as a dict for serialization.</p> Source code in <code>fast_healthchecks/checks/configs.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Return config as a dict for serialization.\"\"\"\n    d = asdict(self)\n    d[\"args\"] = list(d.get(\"args\") or ())\n    d[\"kwargs\"] = dict(d[\"kwargs\"]) if d.get(\"kwargs\") else {}\n    return d\n</code></pre>"},{"location":"api/#fast_healthchecks.checks.configs.KafkaConfig","title":"<code>KafkaConfig</code>  <code>dataclass</code>","text":"<p>Configuration for Kafka health check.</p> Source code in <code>fast_healthchecks/checks/configs.py</code> <pre><code>@dataclass(frozen=True)\nclass KafkaConfig:\n    \"\"\"Configuration for Kafka health check.\"\"\"\n\n    bootstrap_servers: str = \"localhost:9092\"\n    ssl_context: _ssl.SSLContext | None = None\n    security_protocol: SecurityProtocol = \"PLAINTEXT\"\n    sasl_mechanism: SaslMechanism = \"PLAIN\"\n    sasl_plain_username: str | None = None\n    sasl_plain_password: str | None = None\n    timeout: float = DEFAULT_HC_TIMEOUT\n\n    def __post_init__(self) -&gt; None:\n        \"\"\"Validate security_protocol and sasl_mechanism.\n\n        Raises:\n            ValueError: If security_protocol or sasl_mechanism is invalid.\n        \"\"\"\n        if self.security_protocol not in VALID_SECURITY_PROTOCOLS:\n            msg = f\"Invalid security protocol: {self.security_protocol}\"\n            raise ValueError(msg)\n        if self.sasl_mechanism not in VALID_SASL_MECHANISMS:\n            msg = f\"Invalid SASL mechanism: {self.sasl_mechanism}\"\n            raise ValueError(msg)\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Return config as a dict for serialization.\"\"\"\n        # ssl_context is not deepcopy-safe; build dict manually\n        return {\n            \"bootstrap_servers\": self.bootstrap_servers,\n            \"ssl_context\": self.ssl_context,\n            \"security_protocol\": self.security_protocol,\n            \"sasl_mechanism\": self.sasl_mechanism,\n            \"sasl_plain_username\": self.sasl_plain_username,\n            \"sasl_plain_password\": self.sasl_plain_password,\n            \"timeout\": self.timeout,\n        }\n</code></pre>"},{"location":"api/#fast_healthchecks.checks.configs.KafkaConfig.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Validate security_protocol and sasl_mechanism.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If security_protocol or sasl_mechanism is invalid.</p> Source code in <code>fast_healthchecks/checks/configs.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    \"\"\"Validate security_protocol and sasl_mechanism.\n\n    Raises:\n        ValueError: If security_protocol or sasl_mechanism is invalid.\n    \"\"\"\n    if self.security_protocol not in VALID_SECURITY_PROTOCOLS:\n        msg = f\"Invalid security protocol: {self.security_protocol}\"\n        raise ValueError(msg)\n    if self.sasl_mechanism not in VALID_SASL_MECHANISMS:\n        msg = f\"Invalid SASL mechanism: {self.sasl_mechanism}\"\n        raise ValueError(msg)\n</code></pre>"},{"location":"api/#fast_healthchecks.checks.configs.KafkaConfig.to_dict","title":"<code>to_dict()</code>","text":"<p>Return config as a dict for serialization.</p> Source code in <code>fast_healthchecks/checks/configs.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Return config as a dict for serialization.\"\"\"\n    # ssl_context is not deepcopy-safe; build dict manually\n    return {\n        \"bootstrap_servers\": self.bootstrap_servers,\n        \"ssl_context\": self.ssl_context,\n        \"security_protocol\": self.security_protocol,\n        \"sasl_mechanism\": self.sasl_mechanism,\n        \"sasl_plain_username\": self.sasl_plain_username,\n        \"sasl_plain_password\": self.sasl_plain_password,\n        \"timeout\": self.timeout,\n    }\n</code></pre>"},{"location":"api/#fast_healthchecks.checks.configs.MongoConfig","title":"<code>MongoConfig</code>  <code>dataclass</code>","text":"<p>Configuration for MongoDB health check.</p> Source code in <code>fast_healthchecks/checks/configs.py</code> <pre><code>@dataclass(frozen=True)\nclass MongoConfig:\n    \"\"\"Configuration for MongoDB health check.\"\"\"\n\n    hosts: str | list[str] = \"localhost\"\n    port: int | None = 27017\n    user: str | None = None\n    password: str | None = None\n    database: str | None = None\n    auth_source: str = \"admin\"\n    timeout: float = DEFAULT_HC_TIMEOUT\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Return config as a dict for serialization.\"\"\"\n        return asdict(self)\n</code></pre>"},{"location":"api/#fast_healthchecks.checks.configs.MongoConfig.to_dict","title":"<code>to_dict()</code>","text":"<p>Return config as a dict for serialization.</p> Source code in <code>fast_healthchecks/checks/configs.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Return config as a dict for serialization.\"\"\"\n    return asdict(self)\n</code></pre>"},{"location":"api/#fast_healthchecks.checks.configs.OpenSearchConfig","title":"<code>OpenSearchConfig</code>  <code>dataclass</code>","text":"<p>Configuration for OpenSearch health check.</p> Source code in <code>fast_healthchecks/checks/configs.py</code> <pre><code>@dataclass(frozen=True)\nclass OpenSearchConfig:\n    \"\"\"Configuration for OpenSearch health check.\"\"\"\n\n    hosts: list[str] = field(default_factory=lambda: [\"localhost:9200\"])\n    http_auth: tuple[str, str] | None = None\n    use_ssl: bool = False\n    verify_certs: bool = False\n    ssl_show_warn: bool = False\n    ca_certs: str | None = None\n    timeout: float = DEFAULT_HC_TIMEOUT\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Return config as a dict for serialization.\"\"\"\n        return asdict(self)\n</code></pre>"},{"location":"api/#fast_healthchecks.checks.configs.OpenSearchConfig.to_dict","title":"<code>to_dict()</code>","text":"<p>Return config as a dict for serialization.</p> Source code in <code>fast_healthchecks/checks/configs.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Return config as a dict for serialization.\"\"\"\n    return asdict(self)\n</code></pre>"},{"location":"api/#fast_healthchecks.checks.configs.PostgresAsyncPGConfig","title":"<code>PostgresAsyncPGConfig</code>  <code>dataclass</code>","text":"<p>Configuration for PostgreSQL health check (asyncpg driver).</p> Source code in <code>fast_healthchecks/checks/configs.py</code> <pre><code>@dataclass(frozen=True)\nclass PostgresAsyncPGConfig:\n    \"\"\"Configuration for PostgreSQL health check (asyncpg driver).\"\"\"\n\n    host: str = \"localhost\"\n    port: int = 5432\n    user: str | None = None\n    password: str | None = None\n    database: str | None = None\n    ssl: _ssl.SSLContext | None = None\n    direct_tls: bool = False\n    timeout: float = DEFAULT_HC_TIMEOUT\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Return config as a dict for serialization.\"\"\"\n        # ssl is not serializable; include as None in dict for consistent keys\n        return {\n            \"host\": self.host,\n            \"port\": self.port,\n            \"user\": self.user,\n            \"password\": self.password,\n            \"database\": self.database,\n            \"ssl\": self.ssl,\n            \"direct_tls\": self.direct_tls,\n            \"timeout\": self.timeout,\n        }\n</code></pre>"},{"location":"api/#fast_healthchecks.checks.configs.PostgresAsyncPGConfig.to_dict","title":"<code>to_dict()</code>","text":"<p>Return config as a dict for serialization.</p> Source code in <code>fast_healthchecks/checks/configs.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Return config as a dict for serialization.\"\"\"\n    # ssl is not serializable; include as None in dict for consistent keys\n    return {\n        \"host\": self.host,\n        \"port\": self.port,\n        \"user\": self.user,\n        \"password\": self.password,\n        \"database\": self.database,\n        \"ssl\": self.ssl,\n        \"direct_tls\": self.direct_tls,\n        \"timeout\": self.timeout,\n    }\n</code></pre>"},{"location":"api/#fast_healthchecks.checks.configs.PostgresPsycopgConfig","title":"<code>PostgresPsycopgConfig</code>  <code>dataclass</code>","text":"<p>Configuration for PostgreSQL health check (psycopg driver).</p> Source code in <code>fast_healthchecks/checks/configs.py</code> <pre><code>@dataclass(frozen=True)\nclass PostgresPsycopgConfig:\n    \"\"\"Configuration for PostgreSQL health check (psycopg driver).\"\"\"\n\n    host: str = \"localhost\"\n    port: int = 5432\n    user: str | None = None\n    password: str | None = None\n    database: str | None = None\n    sslmode: str | None = None\n    sslcert: str | None = None\n    sslkey: str | None = None\n    sslrootcert: str | None = None\n    timeout: float = DEFAULT_HC_TIMEOUT\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Return config as a dict for serialization.\"\"\"\n        return asdict(self)\n</code></pre>"},{"location":"api/#fast_healthchecks.checks.configs.PostgresPsycopgConfig.to_dict","title":"<code>to_dict()</code>","text":"<p>Return config as a dict for serialization.</p> Source code in <code>fast_healthchecks/checks/configs.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Return config as a dict for serialization.\"\"\"\n    return asdict(self)\n</code></pre>"},{"location":"api/#fast_healthchecks.checks.configs.RabbitMQConfig","title":"<code>RabbitMQConfig</code>  <code>dataclass</code>","text":"<p>Configuration for RabbitMQ health check.</p> <p>Security: The default <code>user</code> and <code>password</code> (<code>\"guest\"</code>) match RabbitMQ's default credentials and are intended for local development only. Do not use these defaults in production or on non-local brokers; set explicit credentials or use a secrets manager. See SECURITY.md.</p> Source code in <code>fast_healthchecks/checks/configs.py</code> <pre><code>@dataclass(frozen=True)\nclass RabbitMQConfig:\n    \"\"\"Configuration for RabbitMQ health check.\n\n    **Security:** The default ``user`` and ``password`` (``\"guest\"``) match\n    RabbitMQ's default credentials and are intended for local development only.\n    Do not use these defaults in production or on non-local brokers; set\n    explicit credentials or use a secrets manager. See SECURITY.md.\n    \"\"\"\n\n    host: str = \"localhost\"\n    port: int = 5672\n    user: str = \"guest\"\n    password: str = \"guest\"  # noqa: S105\n    vhost: str = \"/\"\n    secure: bool = False\n    timeout: float = DEFAULT_HC_TIMEOUT\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Return config as a dict for serialization.\"\"\"\n        return asdict(self)\n</code></pre>"},{"location":"api/#fast_healthchecks.checks.configs.RabbitMQConfig.to_dict","title":"<code>to_dict()</code>","text":"<p>Return config as a dict for serialization.</p> Source code in <code>fast_healthchecks/checks/configs.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Return config as a dict for serialization.\"\"\"\n    return asdict(self)\n</code></pre>"},{"location":"api/#fast_healthchecks.checks.configs.RedisConfig","title":"<code>RedisConfig</code>  <code>dataclass</code>","text":"<p>Configuration for Redis health check.</p> Source code in <code>fast_healthchecks/checks/configs.py</code> <pre><code>@dataclass(frozen=True)\nclass RedisConfig:\n    \"\"\"Configuration for Redis health check.\"\"\"\n\n    host: str = \"localhost\"\n    port: int = 6379\n    database: int | str = 0\n    user: str | None = None\n    password: str | None = None\n    ssl: bool = False\n    ssl_ca_certs: str | None = None\n    timeout: float = DEFAULT_HC_TIMEOUT\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Return config as a dict for serialization.\"\"\"\n        return asdict(self)\n</code></pre>"},{"location":"api/#fast_healthchecks.checks.configs.RedisConfig.to_dict","title":"<code>to_dict()</code>","text":"<p>Return config as a dict for serialization.</p> Source code in <code>fast_healthchecks/checks/configs.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Return config as a dict for serialization.\"\"\"\n    return asdict(self)\n</code></pre>"},{"location":"api/#fast_healthchecks.checks.configs.UrlConfig","title":"<code>UrlConfig</code>  <code>dataclass</code>","text":"<p>Configuration for URL health check.</p> <p>Use only trusted URLs from application configuration; do not pass user-controlled input to avoid SSRF. Validation and behaviour are provided by :func:<code>~fast_healthchecks.utils.validate_url_ssrf</code> and :func:<code>~fast_healthchecks.utils.validate_host_ssrf_async</code>. See the SSRF documentation in the docs.</p> Source code in <code>fast_healthchecks/checks/configs.py</code> <pre><code>@dataclass(frozen=True)\nclass UrlConfig:\n    \"\"\"Configuration for URL health check.\n\n    Use only trusted URLs from application configuration; do not pass\n    user-controlled input to avoid SSRF. Validation and behaviour are\n    provided by :func:`~fast_healthchecks.utils.validate_url_ssrf` and\n    :func:`~fast_healthchecks.utils.validate_host_ssrf_async`. See the\n    SSRF documentation in the docs.\n    \"\"\"\n\n    url: str = \"\"\n    username: str | None = None\n    password: str | None = None\n    verify_ssl: bool = True\n    follow_redirects: bool = True\n    timeout: float = DEFAULT_HC_TIMEOUT\n    block_private_hosts: bool = False\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Return config as a dict for serialization.\"\"\"\n        return asdict(self)\n</code></pre>"},{"location":"api/#fast_healthchecks.checks.configs.UrlConfig.to_dict","title":"<code>to_dict()</code>","text":"<p>Return config as a dict for serialization.</p> Source code in <code>fast_healthchecks/checks/configs.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Return config as a dict for serialization.\"\"\"\n    return asdict(self)\n</code></pre>"},{"location":"api/#fast_healthchecks.checks.types.HealthCheck","title":"<code>HealthCheck</code>","text":"<p>               Bases: <code>Protocol[T_co]</code></p> <p>Base class for health checks.</p> Source code in <code>fast_healthchecks/checks/_base.py</code> <pre><code>class HealthCheck(Protocol[T_co]):\n    \"\"\"Base class for health checks.\"\"\"\n\n    async def __call__(self) -&gt; T_co: ...\n</code></pre>"},{"location":"api/#fast_healthchecks.checks.types.HealthCheckDSN","title":"<code>HealthCheckDSN</code>","text":"<p>               Bases: <code>ConfigDictMixin</code>, <code>HealthCheck[T_co]</code>, <code>Generic[T_co, T_parsed]</code></p> <p>Base class for health checks that can be created from a DSN.</p> <p>Contract: subclasses must define _allowed_schemes(), _default_name(), parse_dsn(), and _from_parsed_dsn(). The check stores its display name in _name (used in HealthCheckResult and error reporting). DSN validation uses validate_dsn(); fast_healthchecks.dsn NewTypes are typing-only, not runtime.</p> <p>Type parameters: T_co is the result type (e.g. HealthCheckResult); T_parsed is the type returned by parse_dsn() and accepted by _from_parsed_dsn().</p> Source code in <code>fast_healthchecks/checks/_base.py</code> <pre><code>class HealthCheckDSN(ConfigDictMixin, HealthCheck[T_co], Generic[T_co, T_parsed]):\n    \"\"\"Base class for health checks that can be created from a DSN.\n\n    Contract: subclasses must define _allowed_schemes(), _default_name(),\n    parse_dsn(), and _from_parsed_dsn(). The check stores its display name in\n    _name (used in HealthCheckResult and error reporting). DSN validation uses\n    validate_dsn(); fast_healthchecks.dsn NewTypes are typing-only, not runtime.\n\n    Type parameters: T_co is the result type (e.g. HealthCheckResult);\n    T_parsed is the type returned by parse_dsn() and accepted by _from_parsed_dsn().\n    \"\"\"\n\n    @classmethod\n    @abstractmethod\n    def _allowed_schemes(cls) -&gt; tuple[str, ...]:\n        \"\"\"Return DSN schemes allowed for this check (e.g. ('redis', 'rediss')).\"\"\"\n        raise NotImplementedError  # pragma: no cover\n\n    @classmethod\n    @abstractmethod\n    def _default_name(cls) -&gt; str:\n        \"\"\"Return the default check name for from_dsn (e.g. 'Redis').\"\"\"\n        raise NotImplementedError  # pragma: no cover\n\n    @classmethod\n    @abstractmethod\n    def parse_dsn(cls, dsn: str) -&gt; T_parsed:\n        \"\"\"Parse the DSN string. Subclasses must implement.\"\"\"\n        raise NotImplementedError  # pragma: no cover\n\n    @classmethod\n    @abstractmethod\n    def _from_parsed_dsn(\n        cls,\n        parsed: T_parsed,\n        *,\n        name: str = \"Service\",\n        timeout: float = DEFAULT_HC_TIMEOUT,\n        **kwargs: object,\n    ) -&gt; HealthCheckDSN[T_co, T_parsed]:\n        \"\"\"Create a check instance from parsed DSN.\"\"\"\n        raise NotImplementedError  # pragma: no cover\n\n    @classmethod\n    def from_dsn(\n        cls,\n        dsn: str,\n        *,\n        name: str | None = None,\n        timeout: float = DEFAULT_HC_TIMEOUT,\n        **kwargs: object,\n    ) -&gt; HealthCheckDSN[T_co, T_parsed]:\n        \"\"\"Create a check instance from a DSN string.\n\n        Returns:\n            HealthCheckDSN: Configured check instance.\n        \"\"\"\n        if name is None:\n            name = cls._default_name()\n        dsn = cls.validate_dsn(dsn, allowed_schemes=cls._allowed_schemes())\n        parsed = cls.parse_dsn(dsn)\n        return cls._from_parsed_dsn(parsed, name=name, timeout=timeout, **kwargs)\n\n    @classmethod\n    def validate_dsn(cls, dsn: str, *, allowed_schemes: tuple[str, ...]) -&gt; str:\n        \"\"\"Validate the DSN has an allowed scheme.\n\n        Allows compound schemes (e.g. postgresql+asyncpg) when the base\n        part before '+' is in allowed_schemes. Scheme comparison is case-insensitive.\n\n        Returns:\n            str: The DSN string (stripped of leading/trailing whitespace).\n\n        Raises:\n            TypeError: If dsn is not a string.\n            ValueError: If DSN is empty or scheme is not in allowed_schemes.\n        \"\"\"\n        if not isinstance(dsn, str):\n            msg = f\"DSN must be str, got {type(dsn).__name__!r}\"\n            raise TypeError(msg) from None\n\n        dsn = dsn.strip()\n        if not dsn:\n            msg = \"DSN cannot be empty\"\n            raise ValueError(msg) from None\n\n        if not allowed_schemes:\n            msg = \"allowed_schemes cannot be empty\"\n            raise ValueError(msg) from None\n\n        parsed = urlsplit(dsn)\n        scheme = (parsed.scheme or \"\").lower()\n        base_scheme = scheme.split(\"+\", 1)[0] if \"+\" in scheme else scheme\n\n        allowed_set = frozenset(s.lower() for s in allowed_schemes)\n        if scheme not in allowed_set and base_scheme not in allowed_set:\n            schemes_str = \", \".join(sorted(allowed_set))\n            msg = f\"DSN scheme must be one of {schemes_str} (or compound e.g. postgresql+driver), got {scheme!r}\"\n            raise ValueError(msg) from None\n\n        return dsn\n</code></pre>"},{"location":"api/#fast_healthchecks.checks.types.HealthCheckDSN.from_dsn","title":"<code>from_dsn(dsn, *, name=None, timeout=DEFAULT_HC_TIMEOUT, **kwargs)</code>  <code>classmethod</code>","text":"<p>Create a check instance from a DSN string.</p> <p>Returns:</p> Name Type Description <code>HealthCheckDSN</code> <code>HealthCheckDSN[T_co, T_parsed]</code> <p>Configured check instance.</p> Source code in <code>fast_healthchecks/checks/_base.py</code> <pre><code>@classmethod\ndef from_dsn(\n    cls,\n    dsn: str,\n    *,\n    name: str | None = None,\n    timeout: float = DEFAULT_HC_TIMEOUT,\n    **kwargs: object,\n) -&gt; HealthCheckDSN[T_co, T_parsed]:\n    \"\"\"Create a check instance from a DSN string.\n\n    Returns:\n        HealthCheckDSN: Configured check instance.\n    \"\"\"\n    if name is None:\n        name = cls._default_name()\n    dsn = cls.validate_dsn(dsn, allowed_schemes=cls._allowed_schemes())\n    parsed = cls.parse_dsn(dsn)\n    return cls._from_parsed_dsn(parsed, name=name, timeout=timeout, **kwargs)\n</code></pre>"},{"location":"api/#fast_healthchecks.checks.types.HealthCheckDSN.parse_dsn","title":"<code>parse_dsn(dsn)</code>  <code>abstractmethod</code> <code>classmethod</code>","text":"<p>Parse the DSN string. Subclasses must implement.</p> Source code in <code>fast_healthchecks/checks/_base.py</code> <pre><code>@classmethod\n@abstractmethod\ndef parse_dsn(cls, dsn: str) -&gt; T_parsed:\n    \"\"\"Parse the DSN string. Subclasses must implement.\"\"\"\n    raise NotImplementedError  # pragma: no cover\n</code></pre>"},{"location":"api/#fast_healthchecks.checks.types.HealthCheckDSN.validate_dsn","title":"<code>validate_dsn(dsn, *, allowed_schemes)</code>  <code>classmethod</code>","text":"<p>Validate the DSN has an allowed scheme.</p> <p>Allows compound schemes (e.g. postgresql+asyncpg) when the base part before '+' is in allowed_schemes. Scheme comparison is case-insensitive.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The DSN string (stripped of leading/trailing whitespace).</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If dsn is not a string.</p> <code>ValueError</code> <p>If DSN is empty or scheme is not in allowed_schemes.</p> Source code in <code>fast_healthchecks/checks/_base.py</code> <pre><code>@classmethod\ndef validate_dsn(cls, dsn: str, *, allowed_schemes: tuple[str, ...]) -&gt; str:\n    \"\"\"Validate the DSN has an allowed scheme.\n\n    Allows compound schemes (e.g. postgresql+asyncpg) when the base\n    part before '+' is in allowed_schemes. Scheme comparison is case-insensitive.\n\n    Returns:\n        str: The DSN string (stripped of leading/trailing whitespace).\n\n    Raises:\n        TypeError: If dsn is not a string.\n        ValueError: If DSN is empty or scheme is not in allowed_schemes.\n    \"\"\"\n    if not isinstance(dsn, str):\n        msg = f\"DSN must be str, got {type(dsn).__name__!r}\"\n        raise TypeError(msg) from None\n\n    dsn = dsn.strip()\n    if not dsn:\n        msg = \"DSN cannot be empty\"\n        raise ValueError(msg) from None\n\n    if not allowed_schemes:\n        msg = \"allowed_schemes cannot be empty\"\n        raise ValueError(msg) from None\n\n    parsed = urlsplit(dsn)\n    scheme = (parsed.scheme or \"\").lower()\n    base_scheme = scheme.split(\"+\", 1)[0] if \"+\" in scheme else scheme\n\n    allowed_set = frozenset(s.lower() for s in allowed_schemes)\n    if scheme not in allowed_set and base_scheme not in allowed_set:\n        schemes_str = \", \".join(sorted(allowed_set))\n        msg = f\"DSN scheme must be one of {schemes_str} (or compound e.g. postgresql+driver), got {scheme!r}\"\n        raise ValueError(msg) from None\n\n    return dsn\n</code></pre>"},{"location":"api/#fast_healthchecks.checks.function.FunctionHealthCheck","title":"<code>FunctionHealthCheck</code>","text":"<p>               Bases: <code>ConfigDictMixin</code>, <code>HealthCheck[HealthCheckResult]</code></p> <p>Health check that runs a callable (sync or async) each time it is executed.</p> <p>Synchronous functions are run via <code>loop.run_in_executor(executor, ...)</code>. The default executor is <code>None</code> (shared thread pool). Long-running blocking sync checks can exhaust the pool; pass a dedicated :class:<code>Executor</code> if needed.</p> Source code in <code>fast_healthchecks/checks/function.py</code> <pre><code>@final\nclass FunctionHealthCheck(ConfigDictMixin, HealthCheck[HealthCheckResult]):\n    \"\"\"Health check that runs a callable (sync or async) each time it is executed.\n\n    Synchronous functions are run via ``loop.run_in_executor(executor, ...)``.\n    The default executor is ``None`` (shared thread pool). Long-running blocking\n    sync checks can exhaust the pool; pass a dedicated :class:`Executor` if needed.\n    \"\"\"\n\n    __slots__ = (\"_config\", \"_executor\", \"_func\", \"_name\")\n\n    _config: FunctionConfig\n    _func: Callable[..., Any]\n    _executor: Executor | None\n    _name: str\n\n    def __init__(\n        self,\n        *,\n        config: FunctionConfig | None = None,\n        func: Callable[..., Any] | None = None,\n        name: str = \"Function\",\n        executor: Executor | None = None,\n        **kwargs: Any,  # noqa: ANN401\n    ) -&gt; None:\n        \"\"\"Initialize the FunctionHealthCheck.\n\n        Args:\n            config: Config (args, kwargs, timeout). If None, built from kwargs.\n            func: The function to perform the health check on (required if config is None).\n            name: The name of the health check.\n            executor: Executor for sync functions. Defaults to None (thread pool).\n            **kwargs: Passed to FunctionConfig when config is None (args, kwargs, timeout).\n\n        Raises:\n            TypeError: When func is not provided.\n        \"\"\"\n        if config is None:\n            kwargs_copy = dict(kwargs)\n            func = kwargs_copy.pop(\"func\", func)\n            executor = kwargs_copy.pop(\"executor\", executor)\n            if func is None:\n                msg = \"func is required when config is not provided\"\n                raise TypeError(msg)\n            config = FunctionConfig(**kwargs_copy)\n        elif func is None:\n            msg = \"func is required\"\n            raise TypeError(msg)\n        self._config = config\n        self._func = func\n        self._executor = executor\n        self._name = name\n\n    @healthcheck_safe(invalidate_on_error=False)\n    async def __call__(self) -&gt; HealthCheckResult:\n        \"\"\"Perform the health check on the function.\n\n        Sync functions run in the given executor (default: shared thread pool).\n\n        Returns:\n            HealthCheckResult: The result of the health check.\n        \"\"\"\n        c = self._config\n        args = c.args or ()\n        kwargs = dict(c.kwargs) if c.kwargs else {}\n        task: asyncio.Future[Any]\n        if inspect.iscoroutinefunction(self._func):\n            task = self._func(*args, **kwargs)\n        else:\n            loop = asyncio.get_running_loop()\n            task = loop.run_in_executor(\n                self._executor,\n                functools.partial(self._func, *args, **kwargs),\n            )\n        result = await asyncio.wait_for(task, timeout=c.timeout)\n        healthy = bool(result) if isinstance(result, bool) else True\n        return HealthCheckResult(name=self._name, healthy=healthy)\n</code></pre>"},{"location":"api/#fast_healthchecks.checks.function.FunctionHealthCheck.__call__","title":"<code>__call__()</code>  <code>async</code>","text":"<p>Perform the health check on the function.</p> <p>Sync functions run in the given executor (default: shared thread pool).</p> <p>Returns:</p> Name Type Description <code>HealthCheckResult</code> <code>HealthCheckResult</code> <p>The result of the health check.</p> Source code in <code>fast_healthchecks/checks/function.py</code> <pre><code>@healthcheck_safe(invalidate_on_error=False)\nasync def __call__(self) -&gt; HealthCheckResult:\n    \"\"\"Perform the health check on the function.\n\n    Sync functions run in the given executor (default: shared thread pool).\n\n    Returns:\n        HealthCheckResult: The result of the health check.\n    \"\"\"\n    c = self._config\n    args = c.args or ()\n    kwargs = dict(c.kwargs) if c.kwargs else {}\n    task: asyncio.Future[Any]\n    if inspect.iscoroutinefunction(self._func):\n        task = self._func(*args, **kwargs)\n    else:\n        loop = asyncio.get_running_loop()\n        task = loop.run_in_executor(\n            self._executor,\n            functools.partial(self._func, *args, **kwargs),\n        )\n    result = await asyncio.wait_for(task, timeout=c.timeout)\n    healthy = bool(result) if isinstance(result, bool) else True\n    return HealthCheckResult(name=self._name, healthy=healthy)\n</code></pre>"},{"location":"api/#fast_healthchecks.checks.function.FunctionHealthCheck.__init__","title":"<code>__init__(*, config=None, func=None, name='Function', executor=None, **kwargs)</code>","text":"<p>Initialize the FunctionHealthCheck.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>FunctionConfig | None</code> <p>Config (args, kwargs, timeout). If None, built from kwargs.</p> <code>None</code> <code>func</code> <code>Callable[..., Any] | None</code> <p>The function to perform the health check on (required if config is None).</p> <code>None</code> <code>name</code> <code>str</code> <p>The name of the health check.</p> <code>'Function'</code> <code>executor</code> <code>Executor | None</code> <p>Executor for sync functions. Defaults to None (thread pool).</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Passed to FunctionConfig when config is None (args, kwargs, timeout).</p> <code>{}</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>When func is not provided.</p> Source code in <code>fast_healthchecks/checks/function.py</code> <pre><code>def __init__(\n    self,\n    *,\n    config: FunctionConfig | None = None,\n    func: Callable[..., Any] | None = None,\n    name: str = \"Function\",\n    executor: Executor | None = None,\n    **kwargs: Any,  # noqa: ANN401\n) -&gt; None:\n    \"\"\"Initialize the FunctionHealthCheck.\n\n    Args:\n        config: Config (args, kwargs, timeout). If None, built from kwargs.\n        func: The function to perform the health check on (required if config is None).\n        name: The name of the health check.\n        executor: Executor for sync functions. Defaults to None (thread pool).\n        **kwargs: Passed to FunctionConfig when config is None (args, kwargs, timeout).\n\n    Raises:\n        TypeError: When func is not provided.\n    \"\"\"\n    if config is None:\n        kwargs_copy = dict(kwargs)\n        func = kwargs_copy.pop(\"func\", func)\n        executor = kwargs_copy.pop(\"executor\", executor)\n        if func is None:\n            msg = \"func is required when config is not provided\"\n            raise TypeError(msg)\n        config = FunctionConfig(**kwargs_copy)\n    elif func is None:\n        msg = \"func is required\"\n        raise TypeError(msg)\n    self._config = config\n    self._func = func\n    self._executor = executor\n    self._name = name\n</code></pre>"},{"location":"api/#fast_healthchecks.checks.redis.RedisHealthCheck","title":"<code>RedisHealthCheck</code>","text":"<p>               Bases: <code>ClientCachingMixin['Redis']</code>, <code>HealthCheckDSN[HealthCheckResult, RedisParseDsnResult]</code></p> <p>A class to perform health checks on Redis.</p> <p>Attributes:</p> Name Type Description <code>_database</code> <p>The database to connect to.</p> <code>_host</code> <p>The host to connect to.</p> <code>_name</code> <code>str</code> <p>The name of the health check.</p> <code>_password</code> <code>str</code> <p>The password to authenticate with.</p> <code>_port</code> <code>str</code> <p>The port to connect to.</p> <code>_timeout</code> <code>str</code> <p>The timeout for the connection.</p> <code>_user</code> <code>str</code> <p>The user to authenticate with.</p> <code>_ssl</code> <code>str</code> <p>Whether to use SSL or not.</p> <code>_ssl_ca_certs</code> <code>str</code> <p>The path to the CA certificate.</p> Source code in <code>fast_healthchecks/checks/redis.py</code> <pre><code>@final\nclass RedisHealthCheck(ClientCachingMixin[\"Redis\"], HealthCheckDSN[HealthCheckResult, RedisParseDsnResult]):\n    \"\"\"A class to perform health checks on Redis.\n\n    Attributes:\n        _database: The database to connect to.\n        _host: The host to connect to.\n        _name: The name of the health check.\n        _password: The password to authenticate with.\n        _port: The port to connect to.\n        _timeout: The timeout for the connection.\n        _user: The user to authenticate with.\n        _ssl: Whether to use SSL or not.\n        _ssl_ca_certs: The path to the CA certificate.\n    \"\"\"\n\n    __slots__ = (*_CLIENT_CACHING_SLOTS, \"_config\", \"_name\")\n\n    _config: RedisConfig\n    _name: str\n    _client: Redis | None\n    _client_loop: asyncio.AbstractEventLoop | None\n\n    def __init__(\n        self,\n        *,\n        config: RedisConfig | None = None,\n        name: str = \"Redis\",\n        close_client_fn: Callable[[Redis], Awaitable[None]] = _close_redis_client,\n        **kwargs: Any,  # noqa: ANN401\n    ) -&gt; None:\n        \"\"\"Initialize the RedisHealthCheck class.\n\n        Args:\n            config: Connection config. If None, built from kwargs (host, port, database, etc.).\n            name: The name of the health check.\n            close_client_fn: Callable to close the cached client. Defaults to the\n                standard Redis aclose.\n            **kwargs: Passed to RedisConfig when config is None (host, port, database,\n                user, password, ssl, ssl_ca_certs, timeout).\n        \"\"\"\n        if config is None:\n            config = RedisConfig(**kwargs)\n        self._config = config\n        self._name = name\n        super().__init__(close_client_fn=close_client_fn)\n\n    def _create_client(self) -&gt; Redis:\n        c = self._config\n        return Redis(\n            host=c.host,\n            port=c.port,\n            db=c.database,\n            username=c.user,\n            password=c.password,\n            socket_timeout=c.timeout,\n            single_connection_client=True,\n            ssl=c.ssl,\n            ssl_ca_certs=c.ssl_ca_certs,\n        )\n\n    @classmethod\n    def _allowed_schemes(cls) -&gt; tuple[str, ...]:\n        return (\"redis\", \"rediss\")\n\n    @classmethod\n    def _default_name(cls) -&gt; str:\n        return \"Redis\"\n\n    @classmethod\n    def parse_dsn(cls, dsn: str) -&gt; RedisParseDsnResult:\n        \"\"\"Parse the DSN and return the results.\n\n        Args:\n            dsn: The DSN to parse.\n\n        Returns:\n            RedisParseDsnResult: The results of parsing the DSN.\n        \"\"\"\n        parse_result: ConnectKwargs = parse_url(str(dsn))\n        scheme = urlsplit(dsn).scheme.lower()\n        return {\"parse_result\": parse_result, \"scheme\": scheme}\n\n    @classmethod\n    def _from_parsed_dsn(\n        cls,\n        parsed: RedisParseDsnResult,\n        *,\n        name: str = \"Redis\",\n        timeout: float = DEFAULT_HC_TIMEOUT,\n        **_kwargs: object,\n    ) -&gt; RedisHealthCheck:\n        parse_result = parsed[\"parse_result\"]\n        scheme = parsed.get(\"scheme\", \"\")\n        ssl_ca_certs: str | None = parse_result.get(\"ssl_ca_certs\")\n        ssl = parse_result.get(\"ssl\", False) or bool(ssl_ca_certs) or (scheme == \"rediss\")\n        config = RedisConfig(\n            host=parse_result.get(\"host\", \"localhost\"),\n            port=parse_result.get(\"port\", 6379),\n            database=parse_result.get(\"db\", 0),\n            user=parse_result.get(\"username\"),\n            password=parse_result.get(\"password\"),\n            ssl=ssl,\n            ssl_ca_certs=ssl_ca_certs,\n            timeout=timeout,\n        )\n        return cls(config=config, name=name)\n\n    @healthcheck_safe(invalidate_on_error=True)\n    async def __call__(self) -&gt; HealthCheckResult:\n        \"\"\"Perform a health check on Redis.\n\n        Returns:\n            HealthCheckResult: The result of the health check.\n        \"\"\"\n        redis = await self._ensure_client()\n        ping_result = redis.ping()\n        healthy = bool(await ping_result) if asyncio.iscoroutine(ping_result) else bool(ping_result)\n        return HealthCheckResult(name=self._name, healthy=healthy)\n</code></pre>"},{"location":"api/#fast_healthchecks.checks.redis.RedisHealthCheck.__call__","title":"<code>__call__()</code>  <code>async</code>","text":"<p>Perform a health check on Redis.</p> <p>Returns:</p> Name Type Description <code>HealthCheckResult</code> <code>HealthCheckResult</code> <p>The result of the health check.</p> Source code in <code>fast_healthchecks/checks/redis.py</code> <pre><code>@healthcheck_safe(invalidate_on_error=True)\nasync def __call__(self) -&gt; HealthCheckResult:\n    \"\"\"Perform a health check on Redis.\n\n    Returns:\n        HealthCheckResult: The result of the health check.\n    \"\"\"\n    redis = await self._ensure_client()\n    ping_result = redis.ping()\n    healthy = bool(await ping_result) if asyncio.iscoroutine(ping_result) else bool(ping_result)\n    return HealthCheckResult(name=self._name, healthy=healthy)\n</code></pre>"},{"location":"api/#fast_healthchecks.checks.redis.RedisHealthCheck.__init__","title":"<code>__init__(*, config=None, name='Redis', close_client_fn=_close_redis_client, **kwargs)</code>","text":"<p>Initialize the RedisHealthCheck class.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>RedisConfig | None</code> <p>Connection config. If None, built from kwargs (host, port, database, etc.).</p> <code>None</code> <code>name</code> <code>str</code> <p>The name of the health check.</p> <code>'Redis'</code> <code>close_client_fn</code> <code>Callable[[Redis], Awaitable[None]]</code> <p>Callable to close the cached client. Defaults to the standard Redis aclose.</p> <code>_close_redis_client</code> <code>**kwargs</code> <code>Any</code> <p>Passed to RedisConfig when config is None (host, port, database, user, password, ssl, ssl_ca_certs, timeout).</p> <code>{}</code> Source code in <code>fast_healthchecks/checks/redis.py</code> <pre><code>def __init__(\n    self,\n    *,\n    config: RedisConfig | None = None,\n    name: str = \"Redis\",\n    close_client_fn: Callable[[Redis], Awaitable[None]] = _close_redis_client,\n    **kwargs: Any,  # noqa: ANN401\n) -&gt; None:\n    \"\"\"Initialize the RedisHealthCheck class.\n\n    Args:\n        config: Connection config. If None, built from kwargs (host, port, database, etc.).\n        name: The name of the health check.\n        close_client_fn: Callable to close the cached client. Defaults to the\n            standard Redis aclose.\n        **kwargs: Passed to RedisConfig when config is None (host, port, database,\n            user, password, ssl, ssl_ca_certs, timeout).\n    \"\"\"\n    if config is None:\n        config = RedisConfig(**kwargs)\n    self._config = config\n    self._name = name\n    super().__init__(close_client_fn=close_client_fn)\n</code></pre>"},{"location":"api/#fast_healthchecks.checks.redis.RedisHealthCheck.parse_dsn","title":"<code>parse_dsn(dsn)</code>  <code>classmethod</code>","text":"<p>Parse the DSN and return the results.</p> <p>Parameters:</p> Name Type Description Default <code>dsn</code> <code>str</code> <p>The DSN to parse.</p> required <p>Returns:</p> Name Type Description <code>RedisParseDsnResult</code> <code>RedisParseDsnResult</code> <p>The results of parsing the DSN.</p> Source code in <code>fast_healthchecks/checks/redis.py</code> <pre><code>@classmethod\ndef parse_dsn(cls, dsn: str) -&gt; RedisParseDsnResult:\n    \"\"\"Parse the DSN and return the results.\n\n    Args:\n        dsn: The DSN to parse.\n\n    Returns:\n        RedisParseDsnResult: The results of parsing the DSN.\n    \"\"\"\n    parse_result: ConnectKwargs = parse_url(str(dsn))\n    scheme = urlsplit(dsn).scheme.lower()\n    return {\"parse_result\": parse_result, \"scheme\": scheme}\n</code></pre>"},{"location":"api/#fast_healthchecks.checks.kafka.KafkaHealthCheck","title":"<code>KafkaHealthCheck</code>","text":"<p>               Bases: <code>ClientCachingMixin['AIOKafkaAdminClient']</code>, <code>HealthCheckDSN[HealthCheckResult, KafkaParseDsnResult]</code></p> <p>A class to perform health checks on Kafka.</p> <p>Attributes:</p> Name Type Description <code>_bootstrap_servers</code> <p>The Kafka bootstrap servers.</p> <code>_name</code> <code>str</code> <p>The name of the health check.</p> <code>_sasl_mechanism</code> <code>str</code> <p>The SASL mechanism to use.</p> <code>_sasl_plain_password</code> <code>str</code> <p>The SASL plain password.</p> <code>_sasl_plain_username</code> <code>str</code> <p>The SASL plain username.</p> <code>_security_protocol</code> <code>str</code> <p>The security protocol to use.</p> <code>_ssl_context</code> <code>str</code> <p>The SSL context to use.</p> <code>_timeout</code> <code>str</code> <p>The timeout for the health check.</p> Source code in <code>fast_healthchecks/checks/kafka.py</code> <pre><code>@final\nclass KafkaHealthCheck(\n    ClientCachingMixin[\"AIOKafkaAdminClient\"],\n    HealthCheckDSN[HealthCheckResult, KafkaParseDsnResult],\n):\n    \"\"\"A class to perform health checks on Kafka.\n\n    Attributes:\n        _bootstrap_servers: The Kafka bootstrap servers.\n        _name: The name of the health check.\n        _sasl_mechanism: The SASL mechanism to use.\n        _sasl_plain_password: The SASL plain password.\n        _sasl_plain_username: The SASL plain username.\n        _security_protocol: The security protocol to use.\n        _ssl_context: The SSL context to use.\n        _timeout: The timeout for the health check.\n    \"\"\"\n\n    __slots__ = (*_CLIENT_CACHING_SLOTS, \"_config\", \"_name\")\n\n    _config: KafkaConfig\n    _name: str\n    _client: AIOKafkaAdminClient | None\n    _client_loop: asyncio.AbstractEventLoop | None\n\n    def __init__(\n        self,\n        *,\n        config: KafkaConfig | None = None,\n        name: str = \"Kafka\",\n        close_client_fn: Callable[[AIOKafkaAdminClient], Awaitable[None]] = _close_kafka_client,\n        **kwargs: Any,  # noqa: ANN401\n    ) -&gt; None:\n        \"\"\"Initialize the KafkaHealthCheck.\n\n        Args:\n            config: Connection config. If None, built from kwargs (bootstrap_servers, etc.).\n            name: The name of the health check.\n            close_client_fn: Callable to close the cached client.\n            **kwargs: Passed to KafkaConfig when config is None.\n        \"\"\"\n        if config is None:\n            config = KafkaConfig(**kwargs)\n        self._config = config\n        self._name = name\n        super().__init__(close_client_fn=close_client_fn)\n\n    def _create_client(self) -&gt; AIOKafkaAdminClient:\n        c = self._config\n        return AIOKafkaAdminClient(\n            bootstrap_servers=c.bootstrap_servers,\n            client_id=\"fast_healthchecks\",\n            request_timeout_ms=int(c.timeout * 1000),\n            ssl_context=c.ssl_context,\n            security_protocol=c.security_protocol,\n            sasl_mechanism=c.sasl_mechanism,\n            sasl_plain_username=c.sasl_plain_username,\n            sasl_plain_password=c.sasl_plain_password,\n        )\n\n    @classmethod\n    def _allowed_schemes(cls) -&gt; tuple[str, ...]:\n        return (\"kafka\", \"kafkas\")\n\n    @classmethod\n    def _default_name(cls) -&gt; str:\n        return \"Kafka\"\n\n    @classmethod\n    def parse_dsn(cls, dsn: str) -&gt; KafkaParseDsnResult:\n        \"\"\"Parse the Kafka DSN and return the results.\n\n        Scheme ``kafkas`` implies SSL (SASL_SSL when credentials present).\n        Scheme ``kafka`` implies PLAINTEXT (SASL_PLAINTEXT when credentials present).\n        Kwargs to from_dsn override DSN-derived values.\n\n        Args:\n            dsn: The DSN to parse.\n\n        Returns:\n            KafkaParseDsnResult: The results of parsing the DSN.\n\n        Raises:\n            ValueError: If bootstrap servers are missing.\n        \"\"\"\n        parsed = urlsplit(dsn)\n        scheme = (parsed.scheme or \"kafka\").lower()\n        netloc = parsed.netloc\n        sasl_plain_username: str | None = None\n        sasl_plain_password: str | None = None\n        if \"@\" in netloc:\n            userinfo, hosts = netloc.rsplit(\"@\", 1)\n            netloc = hosts\n            if \":\" in userinfo:\n                username, password = userinfo.split(\":\", 1)\n                sasl_plain_username = unquote(username) or None\n                sasl_plain_password = unquote(password) or None\n            else:\n                sasl_plain_username = unquote(userinfo) or None\n\n        bootstrap_servers = netloc or parsed.path.lstrip(\"/\")\n        if not bootstrap_servers:\n            msg = \"Kafka DSN must include bootstrap servers\"\n            raise ValueError(msg) from None\n\n        if scheme == \"kafkas\":\n            security_protocol = \"SASL_SSL\" if (sasl_plain_username or sasl_plain_password) else \"SSL\"\n        else:\n            security_protocol = \"SASL_PLAINTEXT\" if (sasl_plain_username or sasl_plain_password) else \"PLAINTEXT\"\n\n        return {\n            \"bootstrap_servers\": bootstrap_servers,\n            \"sasl_plain_username\": sasl_plain_username,\n            \"sasl_plain_password\": sasl_plain_password,\n            \"security_protocol\": security_protocol,\n        }\n\n    @classmethod\n    def _from_parsed_dsn(\n        cls,\n        parsed: KafkaParseDsnResult,\n        *,\n        name: str = \"Kafka\",\n        timeout: float = DEFAULT_HC_TIMEOUT,\n        **kwargs: object,\n    ) -&gt; KafkaHealthCheck:\n        config = KafkaConfig(\n            bootstrap_servers=parsed[\"bootstrap_servers\"],\n            ssl_context=cast(\"ssl.SSLContext | None\", kwargs.get(\"ssl_context\")),\n            security_protocol=cast(\n                \"SecurityProtocol\",\n                kwargs.get(\"security_protocol\", parsed[\"security_protocol\"]) or \"PLAINTEXT\",\n            ),\n            sasl_mechanism=cast(\"SaslMechanism\", kwargs.get(\"sasl_mechanism\", \"PLAIN\")),\n            sasl_plain_username=parsed[\"sasl_plain_username\"],\n            sasl_plain_password=parsed[\"sasl_plain_password\"],\n            timeout=timeout,\n        )\n        return cls(config=config, name=name)\n\n    @healthcheck_safe(invalidate_on_error=True)\n    async def __call__(self) -&gt; HealthCheckResult:\n        \"\"\"Perform the health check on Kafka.\n\n        Returns:\n            HealthCheckResult: The result of the health check.\n        \"\"\"\n        client = await self._ensure_client()\n        await client.start()\n        await client.list_topics()\n        return HealthCheckResult(name=self._name, healthy=True)\n</code></pre>"},{"location":"api/#fast_healthchecks.checks.kafka.KafkaHealthCheck.__call__","title":"<code>__call__()</code>  <code>async</code>","text":"<p>Perform the health check on Kafka.</p> <p>Returns:</p> Name Type Description <code>HealthCheckResult</code> <code>HealthCheckResult</code> <p>The result of the health check.</p> Source code in <code>fast_healthchecks/checks/kafka.py</code> <pre><code>@healthcheck_safe(invalidate_on_error=True)\nasync def __call__(self) -&gt; HealthCheckResult:\n    \"\"\"Perform the health check on Kafka.\n\n    Returns:\n        HealthCheckResult: The result of the health check.\n    \"\"\"\n    client = await self._ensure_client()\n    await client.start()\n    await client.list_topics()\n    return HealthCheckResult(name=self._name, healthy=True)\n</code></pre>"},{"location":"api/#fast_healthchecks.checks.kafka.KafkaHealthCheck.__init__","title":"<code>__init__(*, config=None, name='Kafka', close_client_fn=_close_kafka_client, **kwargs)</code>","text":"<p>Initialize the KafkaHealthCheck.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>KafkaConfig | None</code> <p>Connection config. If None, built from kwargs (bootstrap_servers, etc.).</p> <code>None</code> <code>name</code> <code>str</code> <p>The name of the health check.</p> <code>'Kafka'</code> <code>close_client_fn</code> <code>Callable[[AIOKafkaAdminClient], Awaitable[None]]</code> <p>Callable to close the cached client.</p> <code>_close_kafka_client</code> <code>**kwargs</code> <code>Any</code> <p>Passed to KafkaConfig when config is None.</p> <code>{}</code> Source code in <code>fast_healthchecks/checks/kafka.py</code> <pre><code>def __init__(\n    self,\n    *,\n    config: KafkaConfig | None = None,\n    name: str = \"Kafka\",\n    close_client_fn: Callable[[AIOKafkaAdminClient], Awaitable[None]] = _close_kafka_client,\n    **kwargs: Any,  # noqa: ANN401\n) -&gt; None:\n    \"\"\"Initialize the KafkaHealthCheck.\n\n    Args:\n        config: Connection config. If None, built from kwargs (bootstrap_servers, etc.).\n        name: The name of the health check.\n        close_client_fn: Callable to close the cached client.\n        **kwargs: Passed to KafkaConfig when config is None.\n    \"\"\"\n    if config is None:\n        config = KafkaConfig(**kwargs)\n    self._config = config\n    self._name = name\n    super().__init__(close_client_fn=close_client_fn)\n</code></pre>"},{"location":"api/#fast_healthchecks.checks.kafka.KafkaHealthCheck.parse_dsn","title":"<code>parse_dsn(dsn)</code>  <code>classmethod</code>","text":"<p>Parse the Kafka DSN and return the results.</p> <p>Scheme <code>kafkas</code> implies SSL (SASL_SSL when credentials present). Scheme <code>kafka</code> implies PLAINTEXT (SASL_PLAINTEXT when credentials present). Kwargs to from_dsn override DSN-derived values.</p> <p>Parameters:</p> Name Type Description Default <code>dsn</code> <code>str</code> <p>The DSN to parse.</p> required <p>Returns:</p> Name Type Description <code>KafkaParseDsnResult</code> <code>KafkaParseDsnResult</code> <p>The results of parsing the DSN.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If bootstrap servers are missing.</p> Source code in <code>fast_healthchecks/checks/kafka.py</code> <pre><code>@classmethod\ndef parse_dsn(cls, dsn: str) -&gt; KafkaParseDsnResult:\n    \"\"\"Parse the Kafka DSN and return the results.\n\n    Scheme ``kafkas`` implies SSL (SASL_SSL when credentials present).\n    Scheme ``kafka`` implies PLAINTEXT (SASL_PLAINTEXT when credentials present).\n    Kwargs to from_dsn override DSN-derived values.\n\n    Args:\n        dsn: The DSN to parse.\n\n    Returns:\n        KafkaParseDsnResult: The results of parsing the DSN.\n\n    Raises:\n        ValueError: If bootstrap servers are missing.\n    \"\"\"\n    parsed = urlsplit(dsn)\n    scheme = (parsed.scheme or \"kafka\").lower()\n    netloc = parsed.netloc\n    sasl_plain_username: str | None = None\n    sasl_plain_password: str | None = None\n    if \"@\" in netloc:\n        userinfo, hosts = netloc.rsplit(\"@\", 1)\n        netloc = hosts\n        if \":\" in userinfo:\n            username, password = userinfo.split(\":\", 1)\n            sasl_plain_username = unquote(username) or None\n            sasl_plain_password = unquote(password) or None\n        else:\n            sasl_plain_username = unquote(userinfo) or None\n\n    bootstrap_servers = netloc or parsed.path.lstrip(\"/\")\n    if not bootstrap_servers:\n        msg = \"Kafka DSN must include bootstrap servers\"\n        raise ValueError(msg) from None\n\n    if scheme == \"kafkas\":\n        security_protocol = \"SASL_SSL\" if (sasl_plain_username or sasl_plain_password) else \"SSL\"\n    else:\n        security_protocol = \"SASL_PLAINTEXT\" if (sasl_plain_username or sasl_plain_password) else \"PLAINTEXT\"\n\n    return {\n        \"bootstrap_servers\": bootstrap_servers,\n        \"sasl_plain_username\": sasl_plain_username,\n        \"sasl_plain_password\": sasl_plain_password,\n        \"security_protocol\": security_protocol,\n    }\n</code></pre>"},{"location":"api/#fast_healthchecks.checks.mongo.MongoHealthCheck","title":"<code>MongoHealthCheck</code>","text":"<p>               Bases: <code>ClientCachingMixin['AsyncIOMotorClient[dict[str, Any]]']</code>, <code>HealthCheckDSN[HealthCheckResult, MongoParseDsnResult]</code></p> <p>A class to perform health checks on MongoDB.</p> <p>Attributes:</p> Name Type Description <code>_auth_source</code> <p>The MongoDB authentication source.</p> <code>_database</code> <p>The MongoDB database to use.</p> <code>_hosts</code> <p>The MongoDB host or a list of hosts.</p> <code>_name</code> <code>str</code> <p>The name of the health check.</p> <code>_password</code> <code>str</code> <p>The MongoDB password.</p> <code>_port</code> <code>str</code> <p>The MongoDB port.</p> <code>_timeout</code> <code>str</code> <p>The timeout for the health check.</p> <code>_user</code> <code>str</code> <p>The MongoDB user.</p> Source code in <code>fast_healthchecks/checks/mongo.py</code> <pre><code>@final\nclass MongoHealthCheck(\n    ClientCachingMixin[\"AsyncIOMotorClient[dict[str, Any]]\"],\n    HealthCheckDSN[HealthCheckResult, MongoParseDsnResult],\n):\n    \"\"\"A class to perform health checks on MongoDB.\n\n    Attributes:\n        _auth_source: The MongoDB authentication source.\n        _database: The MongoDB database to use.\n        _hosts: The MongoDB host or a list of hosts.\n        _name: The name of the health check.\n        _password: The MongoDB password.\n        _port: The MongoDB port.\n        _timeout: The timeout for the health check.\n        _user: The MongoDB user.\n    \"\"\"\n\n    __slots__ = (*_CLIENT_CACHING_SLOTS, \"_config\", \"_name\")\n\n    _config: MongoConfig\n    _name: str\n    _client: AsyncIOMotorClient[dict[str, Any]] | None\n    _client_loop: asyncio.AbstractEventLoop | None\n\n    def __init__(\n        self,\n        *,\n        config: MongoConfig | None = None,\n        name: str = \"MongoDB\",\n        close_client_fn: Callable[\n            [AsyncIOMotorClient[dict[str, Any]]],\n            Awaitable[None],\n        ] = _close_mongo_client,\n        **kwargs: Any,  # noqa: ANN401\n    ) -&gt; None:\n        \"\"\"Initialize the MongoHealthCheck.\n\n        Args:\n            config: Connection config. If None, built from kwargs (hosts, port, etc.).\n            name: The name of the health check.\n            close_client_fn: Callable to close the cached client.\n            **kwargs: Passed to MongoConfig when config is None.\n        \"\"\"\n        if config is None:\n            config = MongoConfig(**kwargs)\n        self._config = config\n        self._name = name\n        super().__init__(close_client_fn=close_client_fn)\n\n    def _create_client(self) -&gt; AsyncIOMotorClient[dict[str, Any]]:\n        c = self._config\n        return AsyncIOMotorClient(\n            host=c.hosts,\n            port=c.port,\n            username=c.user,\n            password=c.password,\n            authSource=c.auth_source,\n            serverSelectionTimeoutMS=int(c.timeout * 1000),\n        )\n\n    @classmethod\n    def _allowed_schemes(cls) -&gt; tuple[str, ...]:\n        return (\"mongodb\", \"mongodb+srv\")\n\n    @classmethod\n    def _default_name(cls) -&gt; str:\n        return \"MongoDB\"\n\n    @classmethod\n    def parse_dsn(cls, dsn: str) -&gt; MongoParseDsnResult:\n        \"\"\"Parse the DSN and return the results.\n\n        Args:\n            dsn: The DSN to parse.\n\n        Returns:\n            MongoParseDsnResult: The results of parsing the DSN.\n        \"\"\"\n        parse_result = urlsplit(dsn)\n        query = parse_query_string(parse_result.query)\n        return {\"parse_result\": parse_result, \"authSource\": query.get(\"authSource\", \"admin\")}\n\n    @classmethod\n    def _from_parsed_dsn(\n        cls,\n        parsed: MongoParseDsnResult,\n        *,\n        name: str = \"MongoDB\",\n        timeout: float = DEFAULT_HC_TIMEOUT,\n        **_kwargs: object,\n    ) -&gt; MongoHealthCheck:\n        parse_result = parsed[\"parse_result\"]\n        hosts: str | list[str]\n        port: int | None\n        if \",\" in parse_result.netloc:\n            hosts = parse_result.netloc.split(\"@\")[-1].split(\",\")\n            port = None\n        else:\n            hosts = parse_result.hostname or \"localhost\"\n            port = parse_result.port or 27017\n        config = MongoConfig(\n            hosts=hosts,\n            port=port,\n            user=parse_result.username,\n            password=parse_result.password,\n            database=parse_result.path.lstrip(\"/\") or None,\n            auth_source=parsed[\"authSource\"],\n            timeout=timeout,\n        )\n        return cls(config=config, name=name)\n\n    @healthcheck_safe(invalidate_on_error=True)\n    async def __call__(self) -&gt; HealthCheckResult:\n        \"\"\"Perform the health check on MongoDB.\n\n        Returns:\n            HealthCheckResult: The result of the health check.\n        \"\"\"\n        client = await self._ensure_client()\n        database = client[self._config.database] if self._config.database else client[self._config.auth_source]\n        res = await database.command(\"ping\")\n        ok_raw = res.get(\"ok\")\n        ok_value = ok_raw if isinstance(ok_raw, (bool, int, float)) else 0\n        return HealthCheckResult(name=self._name, healthy=int(ok_value) == 1)\n</code></pre>"},{"location":"api/#fast_healthchecks.checks.mongo.MongoHealthCheck.__call__","title":"<code>__call__()</code>  <code>async</code>","text":"<p>Perform the health check on MongoDB.</p> <p>Returns:</p> Name Type Description <code>HealthCheckResult</code> <code>HealthCheckResult</code> <p>The result of the health check.</p> Source code in <code>fast_healthchecks/checks/mongo.py</code> <pre><code>@healthcheck_safe(invalidate_on_error=True)\nasync def __call__(self) -&gt; HealthCheckResult:\n    \"\"\"Perform the health check on MongoDB.\n\n    Returns:\n        HealthCheckResult: The result of the health check.\n    \"\"\"\n    client = await self._ensure_client()\n    database = client[self._config.database] if self._config.database else client[self._config.auth_source]\n    res = await database.command(\"ping\")\n    ok_raw = res.get(\"ok\")\n    ok_value = ok_raw if isinstance(ok_raw, (bool, int, float)) else 0\n    return HealthCheckResult(name=self._name, healthy=int(ok_value) == 1)\n</code></pre>"},{"location":"api/#fast_healthchecks.checks.mongo.MongoHealthCheck.__init__","title":"<code>__init__(*, config=None, name='MongoDB', close_client_fn=_close_mongo_client, **kwargs)</code>","text":"<p>Initialize the MongoHealthCheck.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>MongoConfig | None</code> <p>Connection config. If None, built from kwargs (hosts, port, etc.).</p> <code>None</code> <code>name</code> <code>str</code> <p>The name of the health check.</p> <code>'MongoDB'</code> <code>close_client_fn</code> <code>Callable[[AsyncIOMotorClient[dict[str, Any]]], Awaitable[None]]</code> <p>Callable to close the cached client.</p> <code>_close_mongo_client</code> <code>**kwargs</code> <code>Any</code> <p>Passed to MongoConfig when config is None.</p> <code>{}</code> Source code in <code>fast_healthchecks/checks/mongo.py</code> <pre><code>def __init__(\n    self,\n    *,\n    config: MongoConfig | None = None,\n    name: str = \"MongoDB\",\n    close_client_fn: Callable[\n        [AsyncIOMotorClient[dict[str, Any]]],\n        Awaitable[None],\n    ] = _close_mongo_client,\n    **kwargs: Any,  # noqa: ANN401\n) -&gt; None:\n    \"\"\"Initialize the MongoHealthCheck.\n\n    Args:\n        config: Connection config. If None, built from kwargs (hosts, port, etc.).\n        name: The name of the health check.\n        close_client_fn: Callable to close the cached client.\n        **kwargs: Passed to MongoConfig when config is None.\n    \"\"\"\n    if config is None:\n        config = MongoConfig(**kwargs)\n    self._config = config\n    self._name = name\n    super().__init__(close_client_fn=close_client_fn)\n</code></pre>"},{"location":"api/#fast_healthchecks.checks.mongo.MongoHealthCheck.parse_dsn","title":"<code>parse_dsn(dsn)</code>  <code>classmethod</code>","text":"<p>Parse the DSN and return the results.</p> <p>Parameters:</p> Name Type Description Default <code>dsn</code> <code>str</code> <p>The DSN to parse.</p> required <p>Returns:</p> Name Type Description <code>MongoParseDsnResult</code> <code>MongoParseDsnResult</code> <p>The results of parsing the DSN.</p> Source code in <code>fast_healthchecks/checks/mongo.py</code> <pre><code>@classmethod\ndef parse_dsn(cls, dsn: str) -&gt; MongoParseDsnResult:\n    \"\"\"Parse the DSN and return the results.\n\n    Args:\n        dsn: The DSN to parse.\n\n    Returns:\n        MongoParseDsnResult: The results of parsing the DSN.\n    \"\"\"\n    parse_result = urlsplit(dsn)\n    query = parse_query_string(parse_result.query)\n    return {\"parse_result\": parse_result, \"authSource\": query.get(\"authSource\", \"admin\")}\n</code></pre>"},{"location":"api/#fast_healthchecks.checks.opensearch.OpenSearchHealthCheck","title":"<code>OpenSearchHealthCheck</code>","text":"<p>               Bases: <code>ClientCachingMixin['AsyncOpenSearch']</code>, <code>HealthCheckDSN[HealthCheckResult, OpenSearchParseDsnResult]</code></p> <p>A class to perform health checks on OpenSearch.</p> <p>Attributes:</p> Name Type Description <code>_hosts</code> <p>The OpenSearch hosts.</p> <code>_name</code> <code>str</code> <p>The name of the health check.</p> <code>_http_auth</code> <code>str</code> <p>The HTTP authentication.</p> <code>_use_ssl</code> <code>str</code> <p>Whether to use SSL or not.</p> <code>_verify_certs</code> <code>str</code> <p>Whether to verify certificates or not.</p> <code>_ssl_show_warn</code> <code>str</code> <p>Whether to show SSL warnings or not.</p> <code>_ca_certs</code> <code>str</code> <p>The CA certificates.</p> <code>_timeout</code> <code>str</code> <p>The timeout for the health check.</p> Source code in <code>fast_healthchecks/checks/opensearch.py</code> <pre><code>@final\nclass OpenSearchHealthCheck(\n    ClientCachingMixin[\"AsyncOpenSearch\"],\n    HealthCheckDSN[HealthCheckResult, OpenSearchParseDsnResult],\n):\n    \"\"\"A class to perform health checks on OpenSearch.\n\n    Attributes:\n        _hosts: The OpenSearch hosts.\n        _name: The name of the health check.\n        _http_auth: The HTTP authentication.\n        _use_ssl: Whether to use SSL or not.\n        _verify_certs: Whether to verify certificates or not.\n        _ssl_show_warn: Whether to show SSL warnings or not.\n        _ca_certs: The CA certificates.\n        _timeout: The timeout for the health check.\n    \"\"\"\n\n    __slots__ = (*_CLIENT_CACHING_SLOTS, \"_config\", \"_name\")\n\n    _config: OpenSearchConfig\n    _name: str\n    _client: AsyncOpenSearch | None\n    _client_loop: asyncio.AbstractEventLoop | None\n\n    def __init__(\n        self,\n        *,\n        config: OpenSearchConfig | None = None,\n        name: str = \"OpenSearch\",\n        close_client_fn: Callable[[AsyncOpenSearch], Awaitable[None]] = _close_opensearch_client,\n        **kwargs: Any,  # noqa: ANN401\n    ) -&gt; None:\n        \"\"\"Initialize the OpenSearchHealthCheck.\n\n        Args:\n            config: Connection config. If None, built from kwargs (hosts, http_auth, etc.).\n            name: The name of the health check.\n            close_client_fn: Callable to close the cached client.\n            **kwargs: Passed to OpenSearchConfig when config is None.\n        \"\"\"\n        if config is None:\n            config = OpenSearchConfig(**kwargs)\n        self._config = config\n        self._name = name\n        super().__init__(close_client_fn=close_client_fn)\n\n    def _create_client(self) -&gt; AsyncOpenSearch:\n        c = self._config\n        return AsyncOpenSearch(\n            hosts=c.hosts,\n            http_auth=c.http_auth,\n            use_ssl=c.use_ssl,\n            verify_certs=c.verify_certs,\n            ssl_show_warn=c.ssl_show_warn,\n            ca_certs=c.ca_certs,\n            timeout=c.timeout,\n        )\n\n    @classmethod\n    def _allowed_schemes(cls) -&gt; tuple[str, ...]:\n        return (\"http\", \"https\")\n\n    @classmethod\n    def _default_name(cls) -&gt; str:\n        return \"OpenSearch\"\n\n    @classmethod\n    def parse_dsn(cls, dsn: str) -&gt; OpenSearchParseDsnResult:\n        \"\"\"Parse the OpenSearch DSN and return the results.\n\n        Args:\n            dsn: The DSN to parse.\n\n        Returns:\n            OpenSearchParseDsnResult: The results of parsing the DSN.\n\n        Raises:\n            ValueError: If DSN has missing host.\n        \"\"\"\n        parsed = urlsplit(dsn)\n        if not parsed.hostname:\n            msg = \"OpenSearch DSN must include a host\"\n            raise ValueError(msg) from None\n\n        http_auth: tuple[str, str] | None = None\n        if parsed.username is not None:\n            http_auth = (unquote(parsed.username), unquote(parsed.password or \"\"))\n\n        port = parsed.port or (443 if parsed.scheme == \"https\" else 9200)\n        return {\n            \"hosts\": [f\"{parsed.hostname}:{port}\"],\n            \"http_auth\": http_auth,\n            \"use_ssl\": parsed.scheme == \"https\",\n        }\n\n    @classmethod\n    def _from_parsed_dsn(\n        cls,\n        parsed: OpenSearchParseDsnResult,\n        *,\n        name: str = \"OpenSearch\",\n        timeout: float = DEFAULT_HC_TIMEOUT,\n        **kwargs: object,\n    ) -&gt; OpenSearchHealthCheck:\n        config = OpenSearchConfig(\n            hosts=parsed[\"hosts\"],\n            http_auth=parsed[\"http_auth\"],\n            use_ssl=parsed[\"use_ssl\"],\n            verify_certs=cast(\"bool\", kwargs.get(\"verify_certs\", False)),\n            ssl_show_warn=cast(\"bool\", kwargs.get(\"ssl_show_warn\", False)),\n            ca_certs=cast(\"str | None\", kwargs.get(\"ca_certs\")),\n            timeout=timeout,\n        )\n        return cls(config=config, name=name)\n\n    @healthcheck_safe(invalidate_on_error=True)\n    async def __call__(self) -&gt; HealthCheckResult:\n        \"\"\"Perform the health check on OpenSearch.\n\n        Returns:\n            HealthCheckResult: The result of the health check.\n        \"\"\"\n        client = await self._ensure_client()\n        await client.info()\n        return HealthCheckResult(name=self._name, healthy=True)\n</code></pre>"},{"location":"api/#fast_healthchecks.checks.opensearch.OpenSearchHealthCheck.__call__","title":"<code>__call__()</code>  <code>async</code>","text":"<p>Perform the health check on OpenSearch.</p> <p>Returns:</p> Name Type Description <code>HealthCheckResult</code> <code>HealthCheckResult</code> <p>The result of the health check.</p> Source code in <code>fast_healthchecks/checks/opensearch.py</code> <pre><code>@healthcheck_safe(invalidate_on_error=True)\nasync def __call__(self) -&gt; HealthCheckResult:\n    \"\"\"Perform the health check on OpenSearch.\n\n    Returns:\n        HealthCheckResult: The result of the health check.\n    \"\"\"\n    client = await self._ensure_client()\n    await client.info()\n    return HealthCheckResult(name=self._name, healthy=True)\n</code></pre>"},{"location":"api/#fast_healthchecks.checks.opensearch.OpenSearchHealthCheck.__init__","title":"<code>__init__(*, config=None, name='OpenSearch', close_client_fn=_close_opensearch_client, **kwargs)</code>","text":"<p>Initialize the OpenSearchHealthCheck.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>OpenSearchConfig | None</code> <p>Connection config. If None, built from kwargs (hosts, http_auth, etc.).</p> <code>None</code> <code>name</code> <code>str</code> <p>The name of the health check.</p> <code>'OpenSearch'</code> <code>close_client_fn</code> <code>Callable[[AsyncOpenSearch], Awaitable[None]]</code> <p>Callable to close the cached client.</p> <code>_close_opensearch_client</code> <code>**kwargs</code> <code>Any</code> <p>Passed to OpenSearchConfig when config is None.</p> <code>{}</code> Source code in <code>fast_healthchecks/checks/opensearch.py</code> <pre><code>def __init__(\n    self,\n    *,\n    config: OpenSearchConfig | None = None,\n    name: str = \"OpenSearch\",\n    close_client_fn: Callable[[AsyncOpenSearch], Awaitable[None]] = _close_opensearch_client,\n    **kwargs: Any,  # noqa: ANN401\n) -&gt; None:\n    \"\"\"Initialize the OpenSearchHealthCheck.\n\n    Args:\n        config: Connection config. If None, built from kwargs (hosts, http_auth, etc.).\n        name: The name of the health check.\n        close_client_fn: Callable to close the cached client.\n        **kwargs: Passed to OpenSearchConfig when config is None.\n    \"\"\"\n    if config is None:\n        config = OpenSearchConfig(**kwargs)\n    self._config = config\n    self._name = name\n    super().__init__(close_client_fn=close_client_fn)\n</code></pre>"},{"location":"api/#fast_healthchecks.checks.opensearch.OpenSearchHealthCheck.parse_dsn","title":"<code>parse_dsn(dsn)</code>  <code>classmethod</code>","text":"<p>Parse the OpenSearch DSN and return the results.</p> <p>Parameters:</p> Name Type Description Default <code>dsn</code> <code>str</code> <p>The DSN to parse.</p> required <p>Returns:</p> Name Type Description <code>OpenSearchParseDsnResult</code> <code>OpenSearchParseDsnResult</code> <p>The results of parsing the DSN.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If DSN has missing host.</p> Source code in <code>fast_healthchecks/checks/opensearch.py</code> <pre><code>@classmethod\ndef parse_dsn(cls, dsn: str) -&gt; OpenSearchParseDsnResult:\n    \"\"\"Parse the OpenSearch DSN and return the results.\n\n    Args:\n        dsn: The DSN to parse.\n\n    Returns:\n        OpenSearchParseDsnResult: The results of parsing the DSN.\n\n    Raises:\n        ValueError: If DSN has missing host.\n    \"\"\"\n    parsed = urlsplit(dsn)\n    if not parsed.hostname:\n        msg = \"OpenSearch DSN must include a host\"\n        raise ValueError(msg) from None\n\n    http_auth: tuple[str, str] | None = None\n    if parsed.username is not None:\n        http_auth = (unquote(parsed.username), unquote(parsed.password or \"\"))\n\n    port = parsed.port or (443 if parsed.scheme == \"https\" else 9200)\n    return {\n        \"hosts\": [f\"{parsed.hostname}:{port}\"],\n        \"http_auth\": http_auth,\n        \"use_ssl\": parsed.scheme == \"https\",\n    }\n</code></pre>"},{"location":"api/#fast_healthchecks.checks.rabbitmq.RabbitMQHealthCheck","title":"<code>RabbitMQHealthCheck</code>","text":"<p>               Bases: <code>ClientCachingMixin['AbstractRobustConnection']</code>, <code>HealthCheckDSN[HealthCheckResult, RabbitMQParseDsnResult]</code></p> <p>A class to perform health checks on RabbitMQ.</p> <p>Uses ClientCachingMixin to reuse a single connection instead of opening a new one on every check.</p> <p>Attributes:</p> Name Type Description <code>_host</code> <p>The RabbitMQ host.</p> <code>_name</code> <code>str</code> <p>The name of the health check.</p> <code>_password</code> <code>str</code> <p>The RabbitMQ password.</p> <code>_port</code> <code>str</code> <p>The RabbitMQ port.</p> <code>_secure</code> <code>str</code> <p>Whether to use a secure connection.</p> <code>_timeout</code> <code>str</code> <p>The timeout for the health check.</p> <code>_user</code> <code>str</code> <p>The RabbitMQ user.</p> <code>_vhost</code> <code>str</code> <p>The RabbitMQ virtual host.</p> Source code in <code>fast_healthchecks/checks/rabbitmq.py</code> <pre><code>@final\nclass RabbitMQHealthCheck(\n    ClientCachingMixin[\"AbstractRobustConnection\"],\n    HealthCheckDSN[HealthCheckResult, RabbitMQParseDsnResult],\n):\n    \"\"\"A class to perform health checks on RabbitMQ.\n\n    Uses ClientCachingMixin to reuse a single connection instead of opening\n    a new one on every check.\n\n    Attributes:\n        _host: The RabbitMQ host.\n        _name: The name of the health check.\n        _password: The RabbitMQ password.\n        _port: The RabbitMQ port.\n        _secure: Whether to use a secure connection.\n        _timeout: The timeout for the health check.\n        _user: The RabbitMQ user.\n        _vhost: The RabbitMQ virtual host.\n    \"\"\"\n\n    __slots__ = (*_CLIENT_CACHING_SLOTS, \"_config\", \"_name\")\n\n    _config: RabbitMQConfig\n    _name: str\n    _client: AbstractRobustConnection | None\n    _client_loop: asyncio.AbstractEventLoop | None\n\n    def __init__(\n        self,\n        *,\n        config: RabbitMQConfig | None = None,\n        name: str = \"RabbitMQ\",\n        close_client_fn: Callable[[AbstractRobustConnection], Awaitable[None]] = _close_rabbitmq_client,\n        **kwargs: Any,  # noqa: ANN401\n    ) -&gt; None:\n        \"\"\"Initialize the RabbitMQHealthCheck.\n\n        Args:\n            config: Connection config. If None, built from kwargs (host, user, password, etc.).\n            name: The name of the health check.\n            close_client_fn: Callable to close the cached connection.\n            **kwargs: Passed to RabbitMQConfig when config is None.\n        \"\"\"\n        if config is None:\n            config = RabbitMQConfig(**kwargs)\n        self._config = config\n        self._name = name\n        super().__init__(close_client_fn=close_client_fn)\n\n    def _create_client(self) -&gt; Awaitable[AbstractRobustConnection]:\n        c = self._config\n        return aio_pika.connect_robust(\n            host=c.host,\n            port=c.port,\n            login=c.user,\n            password=c.password,\n            ssl=c.secure,\n            virtualhost=c.vhost,\n            timeout=c.timeout,\n        )\n\n    @classmethod\n    def _allowed_schemes(cls) -&gt; tuple[str, ...]:\n        return (\"amqp\", \"amqps\")\n\n    @classmethod\n    def _default_name(cls) -&gt; str:\n        return \"RabbitMQ\"\n\n    @classmethod\n    def parse_dsn(cls, dsn: str) -&gt; RabbitMQParseDsnResult:\n        \"\"\"Parse the DSN and return the results.\n\n        Args:\n            dsn: The DSN to parse.\n\n        Returns:\n            RabbitMQParseDsnResult: The results of parsing the DSN.\n        \"\"\"\n        parse_result = urlsplit(dsn)\n        return {\"parse_result\": parse_result}\n\n    @classmethod\n    def _from_parsed_dsn(\n        cls,\n        parsed: RabbitMQParseDsnResult,\n        *,\n        name: str = \"RabbitMQ\",\n        timeout: float = DEFAULT_HC_TIMEOUT,\n        **_kwargs: object,\n    ) -&gt; RabbitMQHealthCheck:\n        parse_result = parsed[\"parse_result\"]\n        # Default \"guest\"/\"guest\" is development-only; see SECURITY.md and RabbitMQConfig.\n        config = RabbitMQConfig(\n            host=parse_result.hostname or \"localhost\",\n            user=parse_result.username or \"guest\",\n            password=parse_result.password or \"guest\",\n            port=parse_result.port or 5672,\n            vhost=parse_result.path.lstrip(\"/\") or \"/\",\n            secure=parse_result.scheme == \"amqps\",\n            timeout=timeout,\n        )\n        return cls(config=config, name=name)\n\n    @healthcheck_safe(invalidate_on_error=True)\n    async def __call__(self) -&gt; HealthCheckResult:\n        \"\"\"Perform the health check on RabbitMQ.\n\n        ClientCachingMixin handles connection persistence; _ensure_client\n        validates the connection via aio-pika's robust logic.\n\n        Returns:\n            HealthCheckResult: The result of the health check.\n        \"\"\"\n        _ = await self._ensure_client()\n        return HealthCheckResult(name=self._name, healthy=True)\n</code></pre>"},{"location":"api/#fast_healthchecks.checks.rabbitmq.RabbitMQHealthCheck.__call__","title":"<code>__call__()</code>  <code>async</code>","text":"<p>Perform the health check on RabbitMQ.</p> <p>ClientCachingMixin handles connection persistence; _ensure_client validates the connection via aio-pika's robust logic.</p> <p>Returns:</p> Name Type Description <code>HealthCheckResult</code> <code>HealthCheckResult</code> <p>The result of the health check.</p> Source code in <code>fast_healthchecks/checks/rabbitmq.py</code> <pre><code>@healthcheck_safe(invalidate_on_error=True)\nasync def __call__(self) -&gt; HealthCheckResult:\n    \"\"\"Perform the health check on RabbitMQ.\n\n    ClientCachingMixin handles connection persistence; _ensure_client\n    validates the connection via aio-pika's robust logic.\n\n    Returns:\n        HealthCheckResult: The result of the health check.\n    \"\"\"\n    _ = await self._ensure_client()\n    return HealthCheckResult(name=self._name, healthy=True)\n</code></pre>"},{"location":"api/#fast_healthchecks.checks.rabbitmq.RabbitMQHealthCheck.__init__","title":"<code>__init__(*, config=None, name='RabbitMQ', close_client_fn=_close_rabbitmq_client, **kwargs)</code>","text":"<p>Initialize the RabbitMQHealthCheck.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>RabbitMQConfig | None</code> <p>Connection config. If None, built from kwargs (host, user, password, etc.).</p> <code>None</code> <code>name</code> <code>str</code> <p>The name of the health check.</p> <code>'RabbitMQ'</code> <code>close_client_fn</code> <code>Callable[[AbstractRobustConnection], Awaitable[None]]</code> <p>Callable to close the cached connection.</p> <code>_close_rabbitmq_client</code> <code>**kwargs</code> <code>Any</code> <p>Passed to RabbitMQConfig when config is None.</p> <code>{}</code> Source code in <code>fast_healthchecks/checks/rabbitmq.py</code> <pre><code>def __init__(\n    self,\n    *,\n    config: RabbitMQConfig | None = None,\n    name: str = \"RabbitMQ\",\n    close_client_fn: Callable[[AbstractRobustConnection], Awaitable[None]] = _close_rabbitmq_client,\n    **kwargs: Any,  # noqa: ANN401\n) -&gt; None:\n    \"\"\"Initialize the RabbitMQHealthCheck.\n\n    Args:\n        config: Connection config. If None, built from kwargs (host, user, password, etc.).\n        name: The name of the health check.\n        close_client_fn: Callable to close the cached connection.\n        **kwargs: Passed to RabbitMQConfig when config is None.\n    \"\"\"\n    if config is None:\n        config = RabbitMQConfig(**kwargs)\n    self._config = config\n    self._name = name\n    super().__init__(close_client_fn=close_client_fn)\n</code></pre>"},{"location":"api/#fast_healthchecks.checks.rabbitmq.RabbitMQHealthCheck.parse_dsn","title":"<code>parse_dsn(dsn)</code>  <code>classmethod</code>","text":"<p>Parse the DSN and return the results.</p> <p>Parameters:</p> Name Type Description Default <code>dsn</code> <code>str</code> <p>The DSN to parse.</p> required <p>Returns:</p> Name Type Description <code>RabbitMQParseDsnResult</code> <code>RabbitMQParseDsnResult</code> <p>The results of parsing the DSN.</p> Source code in <code>fast_healthchecks/checks/rabbitmq.py</code> <pre><code>@classmethod\ndef parse_dsn(cls, dsn: str) -&gt; RabbitMQParseDsnResult:\n    \"\"\"Parse the DSN and return the results.\n\n    Args:\n        dsn: The DSN to parse.\n\n    Returns:\n        RabbitMQParseDsnResult: The results of parsing the DSN.\n    \"\"\"\n    parse_result = urlsplit(dsn)\n    return {\"parse_result\": parse_result}\n</code></pre>"},{"location":"api/#fast_healthchecks.checks.url.UrlHealthCheck","title":"<code>UrlHealthCheck</code>","text":"<p>               Bases: <code>ClientCachingMixin['AsyncClient']</code>, <code>ConfigDictMixin</code>, <code>HealthCheck[HealthCheckResult]</code></p> <p>Health check that performs an HTTP GET to a configurable URL.</p> <p>Supports basic auth, custom timeout, SSL verification, and optional SSRF protection via <code>block_private_hosts</code> (see config).</p> Source code in <code>fast_healthchecks/checks/url.py</code> <pre><code>@final\nclass UrlHealthCheck(ClientCachingMixin[\"AsyncClient\"], ConfigDictMixin, HealthCheck[HealthCheckResult]):\n    \"\"\"Health check that performs an HTTP GET to a configurable URL.\n\n    Supports basic auth, custom timeout, SSL verification, and optional\n    SSRF protection via ``block_private_hosts`` (see config).\n    \"\"\"\n\n    __slots__ = (*_CLIENT_CACHING_SLOTS, \"_config\", \"_name\")\n\n    _config: UrlConfig\n    _name: str\n    _client: AsyncClient | None\n    _client_loop: asyncio.AbstractEventLoop | None\n\n    @property\n    def _auth(self) -&gt; BasicAuth | None:\n        c = self._config\n        return BasicAuth(c.username, c.password or \"\") if c.username else None\n\n    @property\n    def _transport(self) -&gt; AsyncHTTPTransport:\n        return AsyncHTTPTransport(verify=self._config.verify_ssl)\n\n    @property\n    def _block_private_hosts(self) -&gt; bool:\n        return self._config.block_private_hosts\n\n    def __init__(\n        self,\n        *,\n        config: UrlConfig | None = None,\n        name: str = \"HTTP\",\n        close_client_fn: Callable[[AsyncClient], Awaitable[None]] = _close_url_client,\n        **kwargs: Any,  # noqa: ANN401\n    ) -&gt; None:\n        \"\"\"Initialize the health check.\n\n        Warning:\n            Pass only trusted URLs from application configuration. Do not use\n            user-controlled input for ``url`` to avoid SSRF.\n\n        Args:\n            config: Connection config. If None, built from kwargs (url, username, etc.).\n            name: The name of the health check.\n            close_client_fn: Callable to close the cached client.\n            **kwargs: Passed to UrlConfig when config is None (url required).\n        \"\"\"\n        if config is None:\n            kwargs = dict(kwargs)\n            if \"url\" in kwargs:\n                kwargs[\"url\"] = str(kwargs[\"url\"])\n            config = UrlConfig(**kwargs)\n        validate_url_ssrf(config.url, block_private_hosts=config.block_private_hosts)\n        self._config = config\n        self._name = name\n        super().__init__(close_client_fn=close_client_fn)\n\n    def _create_client(self) -&gt; AsyncClient:\n        c = self._config\n        transport = AsyncHTTPTransport(verify=c.verify_ssl)\n        return AsyncClient(\n            auth=self._auth,\n            timeout=c.timeout,\n            transport=transport,\n            follow_redirects=c.follow_redirects,\n        )\n\n    @healthcheck_safe(invalidate_on_error=True)\n    async def __call__(self) -&gt; HealthCheckResult:\n        \"\"\"Perform the health check.\n\n        When block_private_hosts is True, resolves the URL host before the request\n        and rejects if it resolves to loopback/private (SSRF/DNS rebinding protection).\n\n        Returns:\n            HealthCheckResult: Result with healthy=True if response is success.\n        \"\"\"\n        if self._config.block_private_hosts:\n            parsed = urlparse(self._config.url)\n            host = parsed.hostname or \"\"\n            await validate_host_ssrf_async(host)\n        client = await self._ensure_client()\n        response: Response = await client.get(self._config.url)\n        if response.status_code &gt;= HTTPStatus.INTERNAL_SERVER_ERROR or (\n            self._config.username and response.status_code in {HTTPStatus.UNAUTHORIZED, HTTPStatus.FORBIDDEN}\n        ):\n            response.raise_for_status()\n        return HealthCheckResult(name=self._name, healthy=response.is_success)\n</code></pre>"},{"location":"api/#fast_healthchecks.checks.url.UrlHealthCheck.__call__","title":"<code>__call__()</code>  <code>async</code>","text":"<p>Perform the health check.</p> <p>When block_private_hosts is True, resolves the URL host before the request and rejects if it resolves to loopback/private (SSRF/DNS rebinding protection).</p> <p>Returns:</p> Name Type Description <code>HealthCheckResult</code> <code>HealthCheckResult</code> <p>Result with healthy=True if response is success.</p> Source code in <code>fast_healthchecks/checks/url.py</code> <pre><code>@healthcheck_safe(invalidate_on_error=True)\nasync def __call__(self) -&gt; HealthCheckResult:\n    \"\"\"Perform the health check.\n\n    When block_private_hosts is True, resolves the URL host before the request\n    and rejects if it resolves to loopback/private (SSRF/DNS rebinding protection).\n\n    Returns:\n        HealthCheckResult: Result with healthy=True if response is success.\n    \"\"\"\n    if self._config.block_private_hosts:\n        parsed = urlparse(self._config.url)\n        host = parsed.hostname or \"\"\n        await validate_host_ssrf_async(host)\n    client = await self._ensure_client()\n    response: Response = await client.get(self._config.url)\n    if response.status_code &gt;= HTTPStatus.INTERNAL_SERVER_ERROR or (\n        self._config.username and response.status_code in {HTTPStatus.UNAUTHORIZED, HTTPStatus.FORBIDDEN}\n    ):\n        response.raise_for_status()\n    return HealthCheckResult(name=self._name, healthy=response.is_success)\n</code></pre>"},{"location":"api/#fast_healthchecks.checks.url.UrlHealthCheck.__init__","title":"<code>__init__(*, config=None, name='HTTP', close_client_fn=_close_url_client, **kwargs)</code>","text":"<p>Initialize the health check.</p> Warning <p>Pass only trusted URLs from application configuration. Do not use user-controlled input for <code>url</code> to avoid SSRF.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>UrlConfig | None</code> <p>Connection config. If None, built from kwargs (url, username, etc.).</p> <code>None</code> <code>name</code> <code>str</code> <p>The name of the health check.</p> <code>'HTTP'</code> <code>close_client_fn</code> <code>Callable[[AsyncClient], Awaitable[None]]</code> <p>Callable to close the cached client.</p> <code>_close_url_client</code> <code>**kwargs</code> <code>Any</code> <p>Passed to UrlConfig when config is None (url required).</p> <code>{}</code> Source code in <code>fast_healthchecks/checks/url.py</code> <pre><code>def __init__(\n    self,\n    *,\n    config: UrlConfig | None = None,\n    name: str = \"HTTP\",\n    close_client_fn: Callable[[AsyncClient], Awaitable[None]] = _close_url_client,\n    **kwargs: Any,  # noqa: ANN401\n) -&gt; None:\n    \"\"\"Initialize the health check.\n\n    Warning:\n        Pass only trusted URLs from application configuration. Do not use\n        user-controlled input for ``url`` to avoid SSRF.\n\n    Args:\n        config: Connection config. If None, built from kwargs (url, username, etc.).\n        name: The name of the health check.\n        close_client_fn: Callable to close the cached client.\n        **kwargs: Passed to UrlConfig when config is None (url required).\n    \"\"\"\n    if config is None:\n        kwargs = dict(kwargs)\n        if \"url\" in kwargs:\n            kwargs[\"url\"] = str(kwargs[\"url\"])\n        config = UrlConfig(**kwargs)\n    validate_url_ssrf(config.url, block_private_hosts=config.block_private_hosts)\n    self._config = config\n    self._name = name\n    super().__init__(close_client_fn=close_client_fn)\n</code></pre>"},{"location":"api/#fast_healthchecks.checks.postgresql.asyncpg--or","title":"or","text":"<p>health_check = PostgreSQLAsyncPGHealthCheck.from_dsn(     \"postgresql://username:password@localhost:5432/dbname\", ) result = await health_check() print(result.healthy)</p>"},{"location":"api/#fast_healthchecks.checks.postgresql.asyncpg.PostgreSQLAsyncPGHealthCheck","title":"<code>PostgreSQLAsyncPGHealthCheck</code>","text":"<p>               Bases: <code>BasePostgreSQLHealthCheck[HealthCheckResult]</code></p> <p>Health check class for PostgreSQL using asyncpg.</p> <p>Attributes:</p> Name Type Description <code>_name</code> <code>str</code> <p>The name of the health check.</p> <code>_host</code> <code>str</code> <p>The hostname of the PostgreSQL server.</p> <code>_port</code> <code>str</code> <p>The port number of the PostgreSQL server.</p> <code>_user</code> <code>str</code> <p>The username for authentication.</p> <code>_password</code> <code>str</code> <p>The password for authentication.</p> <code>_database</code> <code>str</code> <p>The database name.</p> <code>_ssl</code> <code>str</code> <p>The SSL context for secure connections.</p> <code>_direct_tls</code> <code>str</code> <p>Whether to use direct TLS.</p> <code>_timeout</code> <code>str</code> <p>The timeout for the connection.</p> Source code in <code>fast_healthchecks/checks/postgresql/asyncpg.py</code> <pre><code>class PostgreSQLAsyncPGHealthCheck(BasePostgreSQLHealthCheck[HealthCheckResult]):\n    \"\"\"Health check class for PostgreSQL using asyncpg.\n\n    Attributes:\n        _name: The name of the health check.\n        _host: The hostname of the PostgreSQL server.\n        _port: The port number of the PostgreSQL server.\n        _user: The username for authentication.\n        _password: The password for authentication.\n        _database: The database name.\n        _ssl: The SSL context for secure connections.\n        _direct_tls: Whether to use direct TLS.\n        _timeout: The timeout for the connection.\n    \"\"\"\n\n    __slots__ = (\"_config\", \"_name\")\n\n    _config: PostgresAsyncPGConfig\n    _name: str\n\n    def __init__(\n        self,\n        *,\n        config: PostgresAsyncPGConfig | None = None,\n        name: str = \"PostgreSQL\",\n        **kwargs: Any,  # noqa: ANN401\n    ) -&gt; None:\n        \"\"\"Initialize the PostgreSQLAsyncPGHealthCheck.\n\n        Args:\n            config: Connection config. If None, built from kwargs (host, port, user, etc.).\n            name: The name of the health check.\n            **kwargs: Passed to PostgresAsyncPGConfig when config is None.\n        \"\"\"\n        if config is None:\n            config = PostgresAsyncPGConfig(**kwargs)\n        self._config = config\n        self._name = name\n\n    @classmethod\n    def _from_parsed_dsn(\n        cls,\n        parsed: \"PostgresParseDsnResult\",  # noqa: UP037\n        *,\n        name: str = \"PostgreSQL\",\n        timeout: float = DEFAULT_HC_TIMEOUT,\n        **_kwargs: object,\n    ) -&gt; PostgreSQLAsyncPGHealthCheck:\n        parse_result = parsed[\"parse_result\"]\n        sslctx = parsed[\"sslctx\"]\n        config = PostgresAsyncPGConfig(\n            host=parse_result.hostname or \"localhost\",\n            port=parse_result.port or 5432,\n            user=parse_result.username,\n            password=parse_result.password,\n            database=parse_result.path.lstrip(\"/\"),\n            ssl=sslctx,\n            direct_tls=parsed[\"direct_tls\"],\n            timeout=timeout,\n        )\n        return cls(config=config, name=name)\n\n    @healthcheck_safe(invalidate_on_error=False)\n    async def __call__(self) -&gt; HealthCheckResult:\n        \"\"\"Perform the health check.\n\n        Returns:\n            HealthCheckResult: The result of the health check.\n        \"\"\"\n        c = self._config\n        connection: Connection | None = None\n        try:\n            connection = await asyncpg.connect(\n                host=c.host,\n                port=c.port,\n                user=c.user,\n                password=c.password,\n                database=c.database,\n                timeout=c.timeout,\n                ssl=c.ssl,\n                direct_tls=c.direct_tls,\n            )\n            async with connection.transaction(readonly=True):\n                healthy: bool = bool(await connection.fetchval(\"SELECT 1\"))\n                return HealthCheckResult(name=self._name, healthy=healthy)\n        finally:\n            if connection is not None and not connection.is_closed():\n                await connection.close(timeout=c.timeout)\n</code></pre>"},{"location":"api/#fast_healthchecks.checks.postgresql.asyncpg.PostgreSQLAsyncPGHealthCheck.__call__","title":"<code>__call__()</code>  <code>async</code>","text":"<p>Perform the health check.</p> <p>Returns:</p> Name Type Description <code>HealthCheckResult</code> <code>HealthCheckResult</code> <p>The result of the health check.</p> Source code in <code>fast_healthchecks/checks/postgresql/asyncpg.py</code> <pre><code>@healthcheck_safe(invalidate_on_error=False)\nasync def __call__(self) -&gt; HealthCheckResult:\n    \"\"\"Perform the health check.\n\n    Returns:\n        HealthCheckResult: The result of the health check.\n    \"\"\"\n    c = self._config\n    connection: Connection | None = None\n    try:\n        connection = await asyncpg.connect(\n            host=c.host,\n            port=c.port,\n            user=c.user,\n            password=c.password,\n            database=c.database,\n            timeout=c.timeout,\n            ssl=c.ssl,\n            direct_tls=c.direct_tls,\n        )\n        async with connection.transaction(readonly=True):\n            healthy: bool = bool(await connection.fetchval(\"SELECT 1\"))\n            return HealthCheckResult(name=self._name, healthy=healthy)\n    finally:\n        if connection is not None and not connection.is_closed():\n            await connection.close(timeout=c.timeout)\n</code></pre>"},{"location":"api/#fast_healthchecks.checks.postgresql.asyncpg.PostgreSQLAsyncPGHealthCheck.__init__","title":"<code>__init__(*, config=None, name='PostgreSQL', **kwargs)</code>","text":"<p>Initialize the PostgreSQLAsyncPGHealthCheck.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>PostgresAsyncPGConfig | None</code> <p>Connection config. If None, built from kwargs (host, port, user, etc.).</p> <code>None</code> <code>name</code> <code>str</code> <p>The name of the health check.</p> <code>'PostgreSQL'</code> <code>**kwargs</code> <code>Any</code> <p>Passed to PostgresAsyncPGConfig when config is None.</p> <code>{}</code> Source code in <code>fast_healthchecks/checks/postgresql/asyncpg.py</code> <pre><code>def __init__(\n    self,\n    *,\n    config: PostgresAsyncPGConfig | None = None,\n    name: str = \"PostgreSQL\",\n    **kwargs: Any,  # noqa: ANN401\n) -&gt; None:\n    \"\"\"Initialize the PostgreSQLAsyncPGHealthCheck.\n\n    Args:\n        config: Connection config. If None, built from kwargs (host, port, user, etc.).\n        name: The name of the health check.\n        **kwargs: Passed to PostgresAsyncPGConfig when config is None.\n    \"\"\"\n    if config is None:\n        config = PostgresAsyncPGConfig(**kwargs)\n    self._config = config\n    self._name = name\n</code></pre>"},{"location":"api/#fast_healthchecks.checks.postgresql.psycopg--or","title":"or","text":"<p>health_check = PostgreSQLPsycopgHealthCheck.from_dsn(     \"postgresql://username:password@localhost:5432/dbname\", ) result = await health_check() print(result.healthy)</p>"},{"location":"api/#fast_healthchecks.checks.postgresql.psycopg.PostgreSQLPsycopgHealthCheck","title":"<code>PostgreSQLPsycopgHealthCheck</code>","text":"<p>               Bases: <code>BasePostgreSQLHealthCheck[HealthCheckResult]</code></p> <p>Health check class for PostgreSQL using psycopg.</p> <p>Attributes:</p> Name Type Description <code>_name</code> <code>str</code> <p>The name of the health check.</p> <code>_host</code> <code>str</code> <p>The hostname of the PostgreSQL server.</p> <code>_port</code> <code>str</code> <p>The port number of the PostgreSQL server.</p> <code>_user</code> <code>str</code> <p>The username for authentication.</p> <code>_password</code> <code>str</code> <p>The password for authentication.</p> <code>_database</code> <code>str</code> <p>The database name.</p> <code>_sslmode</code> <code>str</code> <p>The SSL mode to use for the connection.</p> <code>_sslcert</code> <code>str</code> <p>The path to the SSL certificate file.</p> <code>_sslkey</code> <code>str</code> <p>The path to the SSL key file.</p> <code>_sslrootcert</code> <code>str</code> <p>The path to the SSL root certificate file.</p> <code>_timeout</code> <code>str</code> <p>The timeout for the health check.</p> Source code in <code>fast_healthchecks/checks/postgresql/psycopg.py</code> <pre><code>class PostgreSQLPsycopgHealthCheck(BasePostgreSQLHealthCheck[HealthCheckResult]):\n    \"\"\"Health check class for PostgreSQL using psycopg.\n\n    Attributes:\n        _name: The name of the health check.\n        _host: The hostname of the PostgreSQL server.\n        _port: The port number of the PostgreSQL server.\n        _user: The username for authentication.\n        _password: The password for authentication.\n        _database: The database name.\n        _sslmode: The SSL mode to use for the connection.\n        _sslcert: The path to the SSL certificate file.\n        _sslkey: The path to the SSL key file.\n        _sslrootcert: The path to the SSL root certificate file.\n        _timeout: The timeout for the health check.\n    \"\"\"\n\n    __slots__ = (\"_config\", \"_name\")\n\n    _config: PostgresPsycopgConfig\n    _name: str\n\n    def __init__(\n        self,\n        *,\n        config: PostgresPsycopgConfig | None = None,\n        name: str = \"PostgreSQL\",\n        **kwargs: Any,  # noqa: ANN401\n    ) -&gt; None:\n        \"\"\"Initialize the PostgreSQLPsycopgHealthCheck.\n\n        Args:\n            config: Connection config. If None, built from kwargs (host, port, user, etc.).\n            name: The name of the health check.\n            **kwargs: Passed to PostgresPsycopgConfig when config is None.\n        \"\"\"\n        if config is None:\n            config = PostgresPsycopgConfig(**kwargs)\n        self._config = config\n        self._name = name\n\n    @classmethod\n    def _from_parsed_dsn(\n        cls,\n        parsed: \"PostgresParseDsnResult\",  # noqa: UP037\n        *,\n        name: str = \"PostgreSQL\",\n        timeout: float = DEFAULT_HC_TIMEOUT,\n        **_kwargs: object,\n    ) -&gt; PostgreSQLPsycopgHealthCheck:\n        parse_result = parsed[\"parse_result\"]\n        config = PostgresPsycopgConfig(\n            host=parse_result.hostname or \"localhost\",\n            port=parse_result.port or 5432,\n            user=parse_result.username,\n            password=parse_result.password,\n            database=parse_result.path.lstrip(\"/\"),\n            sslmode=parsed[\"sslmode\"],\n            sslcert=parsed[\"sslcert\"],\n            sslkey=parsed[\"sslkey\"],\n            sslrootcert=parsed[\"sslrootcert\"],\n            timeout=timeout,\n        )\n        return cls(config=config, name=name)\n\n    @healthcheck_safe(invalidate_on_error=False)\n    async def __call__(self) -&gt; HealthCheckResult:\n        \"\"\"Perform the health check.\n\n        Returns:\n            HealthCheckResult: The result of the health check.\n        \"\"\"\n        c = self._config\n        connection: AsyncConnection | None = None\n        try:\n            connection = await psycopg.AsyncConnection.connect(\n                host=c.host,\n                port=c.port,\n                user=c.user,\n                password=c.password,\n                dbname=c.database,\n                sslmode=c.sslmode,\n                sslcert=c.sslcert,\n                sslkey=c.sslkey,\n                sslrootcert=c.sslrootcert,\n                connect_timeout=int(c.timeout),\n            )\n            async with connection.cursor() as cursor:\n                await cursor.execute(\"SELECT 1\")\n                healthy: bool = bool(await cursor.fetchone())\n                return HealthCheckResult(name=self._name, healthy=healthy)\n        finally:\n            if connection is not None and not connection.closed:\n                await connection.cancel_safe(timeout=c.timeout)\n                await connection.close()\n</code></pre>"},{"location":"api/#fast_healthchecks.checks.postgresql.psycopg.PostgreSQLPsycopgHealthCheck.__call__","title":"<code>__call__()</code>  <code>async</code>","text":"<p>Perform the health check.</p> <p>Returns:</p> Name Type Description <code>HealthCheckResult</code> <code>HealthCheckResult</code> <p>The result of the health check.</p> Source code in <code>fast_healthchecks/checks/postgresql/psycopg.py</code> <pre><code>@healthcheck_safe(invalidate_on_error=False)\nasync def __call__(self) -&gt; HealthCheckResult:\n    \"\"\"Perform the health check.\n\n    Returns:\n        HealthCheckResult: The result of the health check.\n    \"\"\"\n    c = self._config\n    connection: AsyncConnection | None = None\n    try:\n        connection = await psycopg.AsyncConnection.connect(\n            host=c.host,\n            port=c.port,\n            user=c.user,\n            password=c.password,\n            dbname=c.database,\n            sslmode=c.sslmode,\n            sslcert=c.sslcert,\n            sslkey=c.sslkey,\n            sslrootcert=c.sslrootcert,\n            connect_timeout=int(c.timeout),\n        )\n        async with connection.cursor() as cursor:\n            await cursor.execute(\"SELECT 1\")\n            healthy: bool = bool(await cursor.fetchone())\n            return HealthCheckResult(name=self._name, healthy=healthy)\n    finally:\n        if connection is not None and not connection.closed:\n            await connection.cancel_safe(timeout=c.timeout)\n            await connection.close()\n</code></pre>"},{"location":"api/#fast_healthchecks.checks.postgresql.psycopg.PostgreSQLPsycopgHealthCheck.__init__","title":"<code>__init__(*, config=None, name='PostgreSQL', **kwargs)</code>","text":"<p>Initialize the PostgreSQLPsycopgHealthCheck.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>PostgresPsycopgConfig | None</code> <p>Connection config. If None, built from kwargs (host, port, user, etc.).</p> <code>None</code> <code>name</code> <code>str</code> <p>The name of the health check.</p> <code>'PostgreSQL'</code> <code>**kwargs</code> <code>Any</code> <p>Passed to PostgresPsycopgConfig when config is None.</p> <code>{}</code> Source code in <code>fast_healthchecks/checks/postgresql/psycopg.py</code> <pre><code>def __init__(\n    self,\n    *,\n    config: PostgresPsycopgConfig | None = None,\n    name: str = \"PostgreSQL\",\n    **kwargs: Any,  # noqa: ANN401\n) -&gt; None:\n    \"\"\"Initialize the PostgreSQLPsycopgHealthCheck.\n\n    Args:\n        config: Connection config. If None, built from kwargs (host, port, user, etc.).\n        name: The name of the health check.\n        **kwargs: Passed to PostgresPsycopgConfig when config is None.\n    \"\"\"\n    if config is None:\n        config = PostgresPsycopgConfig(**kwargs)\n    self._config = config\n    self._name = name\n</code></pre>"},{"location":"api/#integrations","title":"Integrations","text":"<p>Base for FastAPI, FastStream, and Litestar integrations.</p> <p>Provides Probe, run_probe(), healthcheck_shutdown(), and helpers to build health routes. Framework-specific routers use these to expose liveness/readiness.</p> <p>FastAPI integration for health checks.</p> <p>FastStream integration for health checks.</p> <p>Litestar integration for health checks.</p> <p>Utility functions for fast-healthchecks.</p>"},{"location":"api/#fast_healthchecks.integrations.base.Probe","title":"<code>Probe</code>","text":"<p>               Bases: <code>NamedTuple</code></p> <p>A probe is a collection of health checks that can be run together.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the probe.</p> <code>checks</code> <code>Sequence[Check]</code> <p>A sequence of health checks to run.</p> <code>summary</code> <code>str | None</code> <p>A summary of the probe. If not provided, a default summary will be generated.</p> <code>allow_partial_failure</code> <code>bool</code> <p>If True, probe is healthy when at least one check passes.</p> Source code in <code>fast_healthchecks/integrations/base.py</code> <pre><code>class Probe(NamedTuple):\n    \"\"\"A probe is a collection of health checks that can be run together.\n\n    Attributes:\n        name: The name of the probe.\n        checks: A sequence of health checks to run.\n        summary: A summary of the probe. If not provided, a default summary will be generated.\n        allow_partial_failure: If True, probe is healthy when at least one check passes.\n    \"\"\"\n\n    name: str\n    checks: Sequence[Check]\n    summary: str | None = None\n    allow_partial_failure: bool = False\n\n    @property\n    def endpoint_summary(self) -&gt; str:\n        \"\"\"Return a summary for the endpoint.\n\n        If a summary is provided, it will be used. Otherwise, a default summary will be generated.\n        \"\"\"\n        if self.summary:\n            return self.summary\n        title = re.sub(\n            pattern=r\"[^a-z0-9]+\",\n            repl=\" \",\n            string=self.name.lower().capitalize(),\n            flags=re.IGNORECASE,\n        )\n        return f\"{title} probe\"\n</code></pre>"},{"location":"api/#fast_healthchecks.integrations.base.Probe.endpoint_summary","title":"<code>endpoint_summary</code>  <code>property</code>","text":"<p>Return a summary for the endpoint.</p> <p>If a summary is provided, it will be used. Otherwise, a default summary will be generated.</p>"},{"location":"api/#fast_healthchecks.integrations.base.ProbeAsgi","title":"<code>ProbeAsgi</code>","text":"<p>An ASGI probe.</p> <p>Parameters:</p> Name Type Description Default <code>probe</code> <code>Probe</code> <p>The probe to run.</p> required <code>options</code> <code>ProbeRouteOptions | None</code> <p>Route options (handlers, status codes, debug, timeout). When None, defaults from build_probe_route_options() are used.</p> <code>None</code> Source code in <code>fast_healthchecks/integrations/base.py</code> <pre><code>class ProbeAsgi:\n    \"\"\"An ASGI probe.\n\n    Args:\n        probe: The probe to run.\n        options: Route options (handlers, status codes, debug, timeout).\n            When None, defaults from build_probe_route_options() are used.\n    \"\"\"\n\n    __slots__ = (\n        \"_debug\",\n        \"_exclude_fields\",\n        \"_failure_handler\",\n        \"_failure_status\",\n        \"_map_handler\",\n        \"_map_status\",\n        \"_probe\",\n        \"_success_handler\",\n        \"_success_status\",\n        \"_timeout\",\n    )\n\n    _probe: Probe\n    _success_handler: HandlerType\n    _failure_handler: HandlerType\n    _success_status: int\n    _failure_status: int\n    _debug: bool\n    _exclude_fields: set[str]\n    _map_status: dict[bool, int]\n    _map_handler: dict[bool, HandlerType]\n    _timeout: float | None\n\n    def __init__(self, probe: Probe, *, options: ProbeRouteOptions | None = None) -&gt; None:\n        \"\"\"Initialize the ASGI probe.\"\"\"\n        if options is None:\n            options = build_probe_route_options()\n        params = options.to_route_params()\n        self._probe = probe\n        self._success_handler = params.success_handler\n        self._failure_handler = params.failure_handler\n        self._success_status = params.success_status\n        self._failure_status = params.failure_status\n        self._debug = params.debug\n        self._timeout = params.timeout\n        self._exclude_fields = {\"allow_partial_failure\", \"error_details\"} if not params.debug else set()\n        self._map_status = {True: params.success_status, False: params.failure_status}\n        self._map_handler = {True: params.success_handler, False: params.failure_handler}\n\n    async def __call__(self) -&gt; tuple[bytes, dict[str, str] | None, int]:\n        \"\"\"Run the probe via run_probe (unified execution and timeout handling).\n\n        Returns:\n            A tuple containing the response body, headers, and status code.\n        \"\"\"\n        report = await run_probe(\n            self._probe,\n            timeout=self._timeout,\n            on_timeout_return_failure=True,\n        )\n        response = ProbeAsgiResponse(\n            data=asdict(\n                report,\n                dict_factory=lambda x: {k: v for (k, v) in x if k not in self._exclude_fields},\n            ),\n            healthy=report.healthy,\n        )\n\n        actual_status = self._map_status[response.healthy]\n        content_needed = actual_status not in {\n            HTTPStatus.NO_CONTENT,\n            HTTPStatus.NOT_MODIFIED,\n        } and not (response.healthy and actual_status &lt; HTTPStatus.OK)\n\n        content = b\"\"\n        headers = None\n        if content_needed:\n            # When debug=True and unhealthy, return full report so assertion/logs show which check failed\n            if self._debug and not response.healthy:\n                content_ = response.data\n            else:\n                handler = self._map_handler[response.healthy]\n                content_ = await handler(response)\n            if content_ is not None:\n                content = json.dumps(\n                    content_,\n                    ensure_ascii=False,\n                    allow_nan=False,\n                    indent=None,\n                    separators=(\",\", \":\"),\n                ).encode(\"utf-8\")\n                headers = {\n                    \"content-type\": \"application/json\",\n                    \"content-length\": str(len(content)),\n                }\n\n        return content, headers, self._map_status[response.healthy]\n</code></pre>"},{"location":"api/#fast_healthchecks.integrations.base.ProbeAsgi.__call__","title":"<code>__call__()</code>  <code>async</code>","text":"<p>Run the probe via run_probe (unified execution and timeout handling).</p> <p>Returns:</p> Type Description <code>tuple[bytes, dict[str, str] | None, int]</code> <p>A tuple containing the response body, headers, and status code.</p> Source code in <code>fast_healthchecks/integrations/base.py</code> <pre><code>async def __call__(self) -&gt; tuple[bytes, dict[str, str] | None, int]:\n    \"\"\"Run the probe via run_probe (unified execution and timeout handling).\n\n    Returns:\n        A tuple containing the response body, headers, and status code.\n    \"\"\"\n    report = await run_probe(\n        self._probe,\n        timeout=self._timeout,\n        on_timeout_return_failure=True,\n    )\n    response = ProbeAsgiResponse(\n        data=asdict(\n            report,\n            dict_factory=lambda x: {k: v for (k, v) in x if k not in self._exclude_fields},\n        ),\n        healthy=report.healthy,\n    )\n\n    actual_status = self._map_status[response.healthy]\n    content_needed = actual_status not in {\n        HTTPStatus.NO_CONTENT,\n        HTTPStatus.NOT_MODIFIED,\n    } and not (response.healthy and actual_status &lt; HTTPStatus.OK)\n\n    content = b\"\"\n    headers = None\n    if content_needed:\n        # When debug=True and unhealthy, return full report so assertion/logs show which check failed\n        if self._debug and not response.healthy:\n            content_ = response.data\n        else:\n            handler = self._map_handler[response.healthy]\n            content_ = await handler(response)\n        if content_ is not None:\n            content = json.dumps(\n                content_,\n                ensure_ascii=False,\n                allow_nan=False,\n                indent=None,\n                separators=(\",\", \":\"),\n            ).encode(\"utf-8\")\n            headers = {\n                \"content-type\": \"application/json\",\n                \"content-length\": str(len(content)),\n            }\n\n    return content, headers, self._map_status[response.healthy]\n</code></pre>"},{"location":"api/#fast_healthchecks.integrations.base.ProbeAsgi.__init__","title":"<code>__init__(probe, *, options=None)</code>","text":"<p>Initialize the ASGI probe.</p> Source code in <code>fast_healthchecks/integrations/base.py</code> <pre><code>def __init__(self, probe: Probe, *, options: ProbeRouteOptions | None = None) -&gt; None:\n    \"\"\"Initialize the ASGI probe.\"\"\"\n    if options is None:\n        options = build_probe_route_options()\n    params = options.to_route_params()\n    self._probe = probe\n    self._success_handler = params.success_handler\n    self._failure_handler = params.failure_handler\n    self._success_status = params.success_status\n    self._failure_status = params.failure_status\n    self._debug = params.debug\n    self._timeout = params.timeout\n    self._exclude_fields = {\"allow_partial_failure\", \"error_details\"} if not params.debug else set()\n    self._map_status = {True: params.success_status, False: params.failure_status}\n    self._map_handler = {True: params.success_handler, False: params.failure_handler}\n</code></pre>"},{"location":"api/#fast_healthchecks.integrations.base.ProbeAsgiResponse","title":"<code>ProbeAsgiResponse</code>","text":"<p>               Bases: <code>NamedTuple</code></p> <p>A response from an ASGI probe.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>dict[str, Any]</code> <p>The response data (healthcheck results).</p> <code>healthy</code> <code>bool</code> <p>Whether all healthchecks passed.</p> Source code in <code>fast_healthchecks/integrations/base.py</code> <pre><code>class ProbeAsgiResponse(NamedTuple):\n    \"\"\"A response from an ASGI probe.\n\n    Attributes:\n        data: The response data (healthcheck results).\n        healthy: Whether all healthchecks passed.\n    \"\"\"\n\n    data: dict[str, Any]\n    healthy: bool\n</code></pre>"},{"location":"api/#fast_healthchecks.integrations.base.ProbeRouteOptions","title":"<code>ProbeRouteOptions</code>","text":"<p>               Bases: <code>NamedTuple</code></p> <p>Options for probe routes. Combines handler params and path prefix.</p> Source code in <code>fast_healthchecks/integrations/base.py</code> <pre><code>class ProbeRouteOptions(NamedTuple):\n    \"\"\"Options for probe routes. Combines handler params and path prefix.\"\"\"\n\n    success_handler: HandlerType\n    failure_handler: HandlerType\n    success_status: int\n    failure_status: int\n    debug: bool\n    timeout: float | None\n    prefix: str\n\n    def to_route_params(self) -&gt; ProbeRouteParams:\n        \"\"\"Return ProbeRouteParams for create_probe_route_handler.\"\"\"\n        return ProbeRouteParams(\n            success_handler=self.success_handler,\n            failure_handler=self.failure_handler,\n            success_status=self.success_status,\n            failure_status=self.failure_status,\n            debug=self.debug,\n            timeout=self.timeout,\n        )\n</code></pre>"},{"location":"api/#fast_healthchecks.integrations.base.ProbeRouteOptions.to_route_params","title":"<code>to_route_params()</code>","text":"<p>Return ProbeRouteParams for create_probe_route_handler.</p> Source code in <code>fast_healthchecks/integrations/base.py</code> <pre><code>def to_route_params(self) -&gt; ProbeRouteParams:\n    \"\"\"Return ProbeRouteParams for create_probe_route_handler.\"\"\"\n    return ProbeRouteParams(\n        success_handler=self.success_handler,\n        failure_handler=self.failure_handler,\n        success_status=self.success_status,\n        failure_status=self.failure_status,\n        debug=self.debug,\n        timeout=self.timeout,\n    )\n</code></pre>"},{"location":"api/#fast_healthchecks.integrations.base.ProbeRouteParams","title":"<code>ProbeRouteParams</code>","text":"<p>               Bases: <code>NamedTuple</code></p> <p>Parameters for probe route handlers. Used by framework integrations.</p> Source code in <code>fast_healthchecks/integrations/base.py</code> <pre><code>class ProbeRouteParams(NamedTuple):\n    \"\"\"Parameters for probe route handlers. Used by framework integrations.\"\"\"\n\n    success_handler: HandlerType\n    failure_handler: HandlerType\n    success_status: int\n    failure_status: int\n    debug: bool\n    timeout: float | None\n\n    def to_options(self, prefix: str = \"/health\") -&gt; ProbeRouteOptions:\n        \"\"\"Return ProbeRouteOptions with the given prefix.\"\"\"\n        return ProbeRouteOptions(\n            success_handler=self.success_handler,\n            failure_handler=self.failure_handler,\n            success_status=self.success_status,\n            failure_status=self.failure_status,\n            debug=self.debug,\n            timeout=self.timeout,\n            prefix=prefix,\n        )\n</code></pre>"},{"location":"api/#fast_healthchecks.integrations.base.ProbeRouteParams.to_options","title":"<code>to_options(prefix='/health')</code>","text":"<p>Return ProbeRouteOptions with the given prefix.</p> Source code in <code>fast_healthchecks/integrations/base.py</code> <pre><code>def to_options(self, prefix: str = \"/health\") -&gt; ProbeRouteOptions:\n    \"\"\"Return ProbeRouteOptions with the given prefix.\"\"\"\n    return ProbeRouteOptions(\n        success_handler=self.success_handler,\n        failure_handler=self.failure_handler,\n        success_status=self.success_status,\n        failure_status=self.failure_status,\n        debug=self.debug,\n        timeout=self.timeout,\n        prefix=prefix,\n    )\n</code></pre>"},{"location":"api/#fast_healthchecks.integrations.base.build_health_routes","title":"<code>build_health_routes(probes, add_route, *, options=None)</code>","text":"<p>Build health route entries for framework integrations.</p> <p>Used by Litestar and FastStream health() functions. When options is None, uses build_probe_route_options() defaults.</p> <p>Parameters:</p> Name Type Description Default <code>probes</code> <code>Iterable[Probe]</code> <p>Probes to build routes for.</p> required <code>add_route</code> <code>Callable[[Probe, ProbeRouteOptions], _T]</code> <p>Callback (probe, options) -&gt; route entry for the framework.</p> required <code>options</code> <code>ProbeRouteOptions | None</code> <p>Route options. When None, defaults from build_probe_route_options().</p> <code>None</code> <p>Returns:</p> Type Description <code>list[_T]</code> <p>List of route entries produced by add_route for each probe.</p> Source code in <code>fast_healthchecks/integrations/base.py</code> <pre><code>def build_health_routes(\n    probes: Iterable[Probe],\n    add_route: Callable[[Probe, ProbeRouteOptions], _T],\n    *,\n    options: ProbeRouteOptions | None = None,\n) -&gt; list[_T]:\n    \"\"\"Build health route entries for framework integrations.\n\n    Used by Litestar and FastStream health() functions. When options is None,\n    uses build_probe_route_options() defaults.\n\n    Args:\n        probes: Probes to build routes for.\n        add_route: Callback (probe, options) -&gt; route entry for the framework.\n        options: Route options. When None, defaults from build_probe_route_options().\n\n    Returns:\n        List of route entries produced by add_route for each probe.\n    \"\"\"\n    if options is None:\n        options = build_probe_route_options()\n    return _build_health_routes(probes, add_route=add_route, options=options)\n</code></pre>"},{"location":"api/#fast_healthchecks.integrations.base.build_probe_route_options","title":"<code>build_probe_route_options(*, success_handler=default_handler, failure_handler=default_handler, success_status=HTTPStatus.NO_CONTENT, failure_status=HTTPStatus.SERVICE_UNAVAILABLE, debug=False, prefix='/health', timeout=None)</code>","text":"<p>Build ProbeRouteOptions with defaults. Used by health() and _add_probe_route.</p> <p>Parameters:</p> Name Type Description Default <code>success_handler</code> <code>HandlerType</code> <p>Handler for healthy responses. Receives ProbeAsgiResponse.</p> <code>default_handler</code> <code>failure_handler</code> <code>HandlerType</code> <p>Handler for unhealthy responses. Same signature.</p> <code>default_handler</code> <code>success_status</code> <code>int</code> <p>HTTP status for healthy (default 204 No Content).</p> <code>NO_CONTENT</code> <code>failure_status</code> <code>int</code> <p>HTTP status for unhealthy (default 503).</p> <code>SERVICE_UNAVAILABLE</code> <code>debug</code> <code>bool</code> <p>Include check details in responses.</p> <code>False</code> <code>prefix</code> <code>str</code> <p>URL prefix for probe routes (e.g. \"/health\").</p> <code>'/health'</code> <code>timeout</code> <code>float | None</code> <p>Max seconds for all checks; on exceed returns failure. None = no limit.</p> <code>None</code> <p>Returns:</p> Type Description <code>ProbeRouteOptions</code> <p>ProbeRouteOptions for use with HealthcheckRouter or health().</p> Source code in <code>fast_healthchecks/integrations/base.py</code> <pre><code>def build_probe_route_options(  # noqa: PLR0913\n    *,\n    success_handler: HandlerType = default_handler,\n    failure_handler: HandlerType = default_handler,\n    success_status: int = HTTPStatus.NO_CONTENT,\n    failure_status: int = HTTPStatus.SERVICE_UNAVAILABLE,\n    debug: bool = False,\n    prefix: str = \"/health\",\n    timeout: float | None = None,\n) -&gt; ProbeRouteOptions:\n    \"\"\"Build ProbeRouteOptions with defaults. Used by health() and _add_probe_route.\n\n    Args:\n        success_handler: Handler for healthy responses. Receives ProbeAsgiResponse.\n        failure_handler: Handler for unhealthy responses. Same signature.\n        success_status: HTTP status for healthy (default 204 No Content).\n        failure_status: HTTP status for unhealthy (default 503).\n        debug: Include check details in responses.\n        prefix: URL prefix for probe routes (e.g. \"/health\").\n        timeout: Max seconds for all checks; on exceed returns failure. None = no limit.\n\n    Returns:\n        ProbeRouteOptions for use with HealthcheckRouter or health().\n    \"\"\"\n    return ProbeRouteOptions(\n        success_handler=success_handler,\n        failure_handler=failure_handler,\n        success_status=success_status,\n        failure_status=failure_status,\n        debug=debug,\n        timeout=timeout,\n        prefix=prefix,\n    )\n</code></pre>"},{"location":"api/#fast_healthchecks.integrations.base.close_probes","title":"<code>close_probes(probes)</code>  <code>async</code>","text":"<p>Close resources owned by checks in the given probes.</p> <p>Calls <code>aclose()</code> on each check that has it (e.g. checks with cached clients). Ignores exceptions so one failure does not block others. After closing, yields to the event loop a few times so that any transport/socket cleanup callbacks (e.g. from aiohttp connector) can run before the caller's context is torn down (avoids unclosed-resource warnings in tests).</p> <p>Parameters:</p> Name Type Description Default <code>probes</code> <code>Iterable[Probe]</code> <p>Probes whose checks should be closed.</p> required Source code in <code>fast_healthchecks/integrations/base.py</code> <pre><code>async def close_probes(probes: Iterable[Probe]) -&gt; None:\n    \"\"\"Close resources owned by checks in the given probes.\n\n    Calls ``aclose()`` on each check that has it (e.g. checks with cached\n    clients). Ignores exceptions so one failure does not block others.\n    After closing, yields to the event loop a few times so that any\n    transport/socket cleanup callbacks (e.g. from aiohttp connector) can run\n    before the caller's context is torn down (avoids unclosed-resource\n    warnings in tests).\n\n    Args:\n        probes: Probes whose checks should be closed.\n    \"\"\"\n    for probe in probes:\n        for check in probe.checks:\n            aclose = getattr(check, \"aclose\", None)\n            if callable(aclose):\n                with contextlib.suppress(Exception):\n                    await aclose()\n    # aiohttp (opensearch-py) schedules transport cleanup on the next loop\n    # iteration; yield so it can run before the caller tears down.\n    await asyncio.sleep(0)\n</code></pre>"},{"location":"api/#fast_healthchecks.integrations.base.create_probe_route_handler","title":"<code>create_probe_route_handler(probe, params, *, response_factory)</code>","text":"<p>Create an async handler for a probe route.</p> <p>Framework integrations use this with their response_factory to build the handler, then register it (FastAPI add_api_route, FastStream/Litestar return).</p> <p>Parameters:</p> Name Type Description Default <code>probe</code> <code>Probe</code> <p>The probe to run when the route is called.</p> required <code>params</code> <code>ProbeRouteParams</code> <p>Route params (handlers, status codes, etc.).</p> required <code>response_factory</code> <code>Callable[[bytes, dict[str, str], int], _T]</code> <p>Called with (body, headers, status_code); returns framework response.</p> required <p>Returns:</p> Type Description <code>Callable[[], Awaitable[_T]]</code> <p>Async callable that runs the probe and returns the framework response.</p> Source code in <code>fast_healthchecks/integrations/base.py</code> <pre><code>def create_probe_route_handler(\n    probe: Probe,\n    params: ProbeRouteParams,\n    *,\n    response_factory: Callable[[bytes, dict[str, str], int], _T],\n) -&gt; Callable[[], Awaitable[_T]]:\n    \"\"\"Create an async handler for a probe route.\n\n    Framework integrations use this with their response_factory to build\n    the handler, then register it (FastAPI add_api_route, FastStream/Litestar return).\n\n    Args:\n        probe: The probe to run when the route is called.\n        params: Route params (handlers, status codes, etc.).\n        response_factory: Called with (body, headers, status_code); returns framework response.\n\n    Returns:\n        Async callable that runs the probe and returns the framework response.\n    \"\"\"\n    probe_asgi = make_probe_asgi(probe, options=params.to_options())\n\n    async def handler() -&gt; _T:\n        content, headers, status_code = await probe_asgi()\n        return response_factory(content, headers or {}, status_code)\n\n    return handler\n</code></pre>"},{"location":"api/#fast_healthchecks.integrations.base.default_handler","title":"<code>default_handler(response)</code>  <code>async</code>","text":"<p>Default handler for health check route.</p> <p>Returns a minimal body <code>{\"status\": \"healthy\"|\"unhealthy\"}</code> for responses that require content (e.g. 503). Returns <code>None</code> for 204 No Content.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>ProbeAsgiResponse</code> <p>The response from the probe.</p> required <p>Returns:</p> Type Description <code>dict[str, Any] | None</code> <p>Minimal status dict, or None for no response body.</p> Source code in <code>fast_healthchecks/integrations/base.py</code> <pre><code>async def default_handler(response: ProbeAsgiResponse) -&gt; dict[str, Any] | None:\n    \"\"\"Default handler for health check route.\n\n    Returns a minimal body ``{\"status\": \"healthy\"|\"unhealthy\"}`` for responses\n    that require content (e.g. 503). Returns ``None`` for 204 No Content.\n\n    Args:\n        response: The response from the probe.\n\n    Returns:\n        Minimal status dict, or None for no response body.\n    \"\"\"\n    await asyncio.sleep(0)\n    return {\"status\": \"healthy\" if response.healthy else \"unhealthy\"}\n</code></pre>"},{"location":"api/#fast_healthchecks.integrations.base.healthcheck_shutdown","title":"<code>healthcheck_shutdown(probes)</code>","text":"<p>Return an async shutdown callback that closes the given probes' checks.</p> <p>Use this with framework lifespan/shutdown hooks (e.g. Litestar <code>on_shutdown</code>, FastStream shutdown) so that health check resources are closed on app shutdown.</p> <p>Parameters:</p> Name Type Description Default <code>probes</code> <code>Iterable[Probe]</code> <p>The same probes passed to your health routes.</p> required <p>Returns:</p> Type Description <code>Callable[[], Awaitable[None]]</code> <p>An async callable with no arguments that closes all checks with <code>aclose()</code>.</p> Source code in <code>fast_healthchecks/integrations/base.py</code> <pre><code>def healthcheck_shutdown(probes: Iterable[Probe]) -&gt; Callable[[], Awaitable[None]]:\n    \"\"\"Return an async shutdown callback that closes the given probes' checks.\n\n    Use this with framework lifespan/shutdown hooks (e.g. Litestar ``on_shutdown``,\n    FastStream shutdown) so that health check resources are closed on app shutdown.\n\n    Args:\n        probes: The same probes passed to your health routes.\n\n    Returns:\n        An async callable with no arguments that closes all checks with ``aclose()``.\n    \"\"\"\n\n    async def _shutdown() -&gt; None:\n        await close_probes(probes)\n\n    return _shutdown\n</code></pre>"},{"location":"api/#fast_healthchecks.integrations.base.make_probe_asgi","title":"<code>make_probe_asgi(probe, *, options=None)</code>","text":"<p>Create an ASGI probe from a probe.</p> <p>Parameters:</p> Name Type Description Default <code>probe</code> <code>Probe</code> <p>The probe to create the ASGI probe from.</p> required <code>options</code> <code>ProbeRouteOptions | None</code> <p>Route options. When None, defaults from build_probe_route_options().</p> <code>None</code> <p>Returns:</p> Type Description <code>Callable[[], Awaitable[tuple[bytes, dict[str, str] | None, int]]]</code> <p>An ASGI probe.</p> Source code in <code>fast_healthchecks/integrations/base.py</code> <pre><code>def make_probe_asgi(\n    probe: Probe,\n    *,\n    options: ProbeRouteOptions | None = None,\n) -&gt; Callable[[], Awaitable[tuple[bytes, dict[str, str] | None, int]]]:\n    \"\"\"Create an ASGI probe from a probe.\n\n    Args:\n        probe: The probe to create the ASGI probe from.\n        options: Route options. When None, defaults from build_probe_route_options().\n\n    Returns:\n        An ASGI probe.\n    \"\"\"\n    return ProbeAsgi(probe, options=options)\n</code></pre>"},{"location":"api/#fast_healthchecks.integrations.base.probe_path_suffix","title":"<code>probe_path_suffix(probe)</code>","text":"<p>Return the path suffix for a probe (name without leading slash).</p> Source code in <code>fast_healthchecks/integrations/base.py</code> <pre><code>def probe_path_suffix(probe: Probe) -&gt; str:\n    \"\"\"Return the path suffix for a probe (name without leading slash).\"\"\"\n    return probe.name.removeprefix(\"/\")\n</code></pre>"},{"location":"api/#fast_healthchecks.integrations.base.probe_route_path","title":"<code>probe_route_path(probe, prefix='/health')</code>","text":"<p>Return the route path for a probe given a prefix.</p> Source code in <code>fast_healthchecks/integrations/base.py</code> <pre><code>def probe_route_path(probe: Probe, prefix: str = \"/health\") -&gt; str:\n    \"\"\"Return the route path for a probe given a prefix.\"\"\"\n    return f\"{prefix.removesuffix('/')}/{probe_path_suffix(probe)}\"\n</code></pre>"},{"location":"api/#fast_healthchecks.integrations.base.run_probe","title":"<code>run_probe(probe, *, timeout=None, on_check_start=None, on_check_end=None, on_timeout_return_failure=False)</code>  <code>async</code>","text":"<p>Run a probe and return the health check report.</p> <p>Can be used without ASGI (CLI, cron, tests). ProbeAsgi uses this with on_timeout_return_failure=True so timeout behavior is unified.</p> <p>When <code>on_check_start</code> or <code>on_check_end</code> are provided, checks run sequentially (for ordering guarantees). Otherwise they run in parallel.</p> <p>Cleanup and cancellation: On cancellation or timeout, run_probe does not close cached clients (checks with <code>aclose</code>). The caller must call <code>healthcheck_shutdown(probes)</code> or <code>close_probes(probes)</code> to close them. There are no dangling background tasks after run_probe returns or raises. See lifecycle and run-probe docs for cleanup paths X and Y.</p> <p>Timeout semantics (probe-level only): When <code>timeout</code> is exceeded, all pending checks are cancelled. Mode A (on_timeout_return_failure=False): raise TimeoutError, no report. Mode B (on_timeout_return_failure=True): return HealthCheckReport with failed results for timed-out checks. ProbeAsgi uses Mode B. See docs run-probe.md for full semantics.</p> <p>Parameters:</p> Name Type Description Default <code>probe</code> <code>Probe</code> <p>The probe to run.</p> required <code>timeout</code> <code>float | None</code> <p>Maximum seconds for all checks. Raises asyncio.TimeoutError if exceeded unless on_timeout_return_failure is True.</p> <code>None</code> <code>on_check_start</code> <code>OnCheckStart | None</code> <p>Optional callback before each check runs. Receives (check, index).</p> <code>None</code> <code>on_check_end</code> <code>OnCheckEnd | None</code> <p>Optional callback after each check completes. Receives (check, index, result).</p> <code>None</code> <code>on_timeout_return_failure</code> <code>bool</code> <p>If True, on timeout return a report with failed results instead of raising TimeoutError.</p> <code>False</code> <p>Returns:</p> Type Description <code>HealthCheckReport</code> <p>HealthCheckReport with results from all checks.</p> <p>Raises:</p> Type Description <code>HealthCheckTimeoutError</code> <p>When timeout is exceeded and on_timeout_return_failure is False. (Subclass of asyncio.TimeoutError; existing <code>except TimeoutError</code> still works.)</p> Source code in <code>fast_healthchecks/integrations/base.py</code> <pre><code>async def run_probe(\n    probe: Probe,\n    *,\n    timeout: float | None = None,\n    on_check_start: OnCheckStart | None = None,\n    on_check_end: OnCheckEnd | None = None,\n    on_timeout_return_failure: bool = False,\n) -&gt; HealthCheckReport:\n    \"\"\"Run a probe and return the health check report.\n\n    Can be used without ASGI (CLI, cron, tests). ProbeAsgi uses this with\n    on_timeout_return_failure=True so timeout behavior is unified.\n\n    When ``on_check_start`` or ``on_check_end`` are provided, checks run\n    sequentially (for ordering guarantees). Otherwise they run in parallel.\n\n    **Cleanup and cancellation:** On cancellation or timeout, run_probe does not\n    close cached clients (checks with ``aclose``). The caller must call\n    ``healthcheck_shutdown(probes)`` or ``close_probes(probes)`` to close them.\n    There are no dangling background tasks after run_probe returns or raises.\n    See lifecycle and run-probe docs for cleanup paths X and Y.\n\n    **Timeout semantics (probe-level only):** When ``timeout`` is exceeded,\n    all pending checks are cancelled. Mode A (on_timeout_return_failure=False):\n    raise TimeoutError, no report. Mode B (on_timeout_return_failure=True):\n    return HealthCheckReport with failed results for timed-out checks.\n    ProbeAsgi uses Mode B. See docs run-probe.md for full semantics.\n\n    Args:\n        probe: The probe to run.\n        timeout: Maximum seconds for all checks. Raises asyncio.TimeoutError if exceeded\n            unless on_timeout_return_failure is True.\n        on_check_start: Optional callback before each check runs. Receives (check, index).\n        on_check_end: Optional callback after each check completes. Receives (check, index, result).\n        on_timeout_return_failure: If True, on timeout return a report with failed results\n            instead of raising TimeoutError.\n\n    Returns:\n        HealthCheckReport with results from all checks.\n\n    Raises:\n        HealthCheckTimeoutError: When timeout is exceeded and on_timeout_return_failure is False.\n            (Subclass of asyncio.TimeoutError; existing ``except TimeoutError`` still works.)\n    \"\"\"\n    get_probe_logger().log(\n        logging.INFO,\n        \"probe_start\",\n        probe=probe.name,\n        checks_count=len(probe.checks),\n    )\n    try:\n        if on_check_start is None and on_check_end is None:\n            results = await _gather_check_results(\n                probe,\n                timeout=timeout,\n                on_timeout_return_failure=on_timeout_return_failure,\n            )\n        else:\n\n            async def _run_with_hooks() -&gt; list[HealthCheckResult]:\n                out: list[HealthCheckResult] = []\n                for i, check in enumerate(probe.checks):\n                    if on_check_start is not None:\n                        await on_check_start(check, i)\n                    result = await _run_check_safe(check, i)\n                    if on_check_end is not None:\n                        await on_check_end(check, i, result)\n                    out.append(result)\n                return out\n\n            try:\n                if timeout is not None:\n                    results = await asyncio.wait_for(_run_with_hooks(), timeout=timeout)\n                else:\n                    results = await _run_with_hooks()\n            except asyncio.TimeoutError:\n                if on_timeout_return_failure:\n                    results = [\n                        HealthCheckResult(\n                            name=_get_check_name(check, i),\n                            healthy=False,\n                            error_details=\"Probe timed out\",\n                        )\n                        for i, check in enumerate(probe.checks)\n                    ]\n                else:\n                    raise HealthCheckTimeoutError from None\n\n        report = HealthCheckReport(\n            results=results,\n            allow_partial_failure=probe.allow_partial_failure,\n        )\n        get_probe_logger().log(\n            logging.INFO,\n            \"probe_end\",\n            probe=probe.name,\n            healthy=report.healthy,\n            results_summary=[(r.name, r.healthy) for r in results],\n        )\n        return report\n    finally:\n        # Cleanup of cached clients is not done here; caller must call\n        # healthcheck_shutdown(probes) or close_probes(probes). See lifecycle docs.\n        pass\n</code></pre>"},{"location":"api/#fast_healthchecks.integrations.fastapi.HealthcheckRouter","title":"<code>HealthcheckRouter</code>","text":"<p>               Bases: <code>APIRouter</code></p> <p>A router for health checks.</p> <p>Parameters:</p> Name Type Description Default <code>*probes</code> <code>Probe</code> <p>Probes to run (e.g. liveness, readiness, startup).</p> <code>()</code> <code>options</code> <code>ProbeRouteOptions | None</code> <p>Route options. When None, uses build_probe_route_options() defaults.</p> <code>None</code> <p>To close health check resources (e.g. cached clients) on app shutdown, call <code>await router.close()</code> from your FastAPI lifespan, or use <code>healthcheck_shutdown(probes)</code> and call the returned callback.</p> Source code in <code>fast_healthchecks/integrations/fastapi.py</code> <pre><code>class HealthcheckRouter(APIRouter):\n    \"\"\"A router for health checks.\n\n    Args:\n        *probes: Probes to run (e.g. liveness, readiness, startup).\n        options: Route options. When None, uses build_probe_route_options() defaults.\n\n    To close health check resources (e.g. cached clients) on app shutdown,\n    call ``await router.close()`` from your FastAPI lifespan, or use\n    ``healthcheck_shutdown(probes)`` and call the returned callback.\n    \"\"\"\n\n    def __init__(self, *probes: Probe, options: ProbeRouteOptions | None = None) -&gt; None:\n        \"\"\"Initialize the router.\"\"\"\n        if options is None:\n            options = build_probe_route_options()\n        super().__init__(prefix=options.prefix.removesuffix(\"/\"), tags=[\"Healthchecks\"])\n        self._healthcheck_probes: list[Probe] = list(probes)\n        for probe in probes:\n            self._add_probe_route(probe, options=options)\n\n    def _add_probe_route(self, probe: Probe, *, options: ProbeRouteOptions) -&gt; None:\n        params = options.to_route_params()\n        handle_request = create_probe_route_handler(\n            probe,\n            params,\n            response_factory=lambda c, h, s: Response(content=c, status_code=s, headers=h),\n        )\n\n        self.add_api_route(\n            path=f\"/{probe_path_suffix(probe)}\",\n            endpoint=handle_request,\n            status_code=options.success_status,\n            summary=probe.endpoint_summary,\n            include_in_schema=options.debug,\n            response_model=None,\n            response_class=Response,\n        )\n\n    async def close(self) -&gt; None:\n        \"\"\"Close resources owned by this router's health check probes.\n\n        Call this from your FastAPI lifespan shutdown (e.g. after ``yield``\n        in an ``@asynccontextmanager`` lifespan) so cached clients are closed.\n        \"\"\"\n        await close_probes(self._healthcheck_probes)\n</code></pre>"},{"location":"api/#fast_healthchecks.integrations.fastapi.HealthcheckRouter.__init__","title":"<code>__init__(*probes, options=None)</code>","text":"<p>Initialize the router.</p> Source code in <code>fast_healthchecks/integrations/fastapi.py</code> <pre><code>def __init__(self, *probes: Probe, options: ProbeRouteOptions | None = None) -&gt; None:\n    \"\"\"Initialize the router.\"\"\"\n    if options is None:\n        options = build_probe_route_options()\n    super().__init__(prefix=options.prefix.removesuffix(\"/\"), tags=[\"Healthchecks\"])\n    self._healthcheck_probes: list[Probe] = list(probes)\n    for probe in probes:\n        self._add_probe_route(probe, options=options)\n</code></pre>"},{"location":"api/#fast_healthchecks.integrations.fastapi.HealthcheckRouter.close","title":"<code>close()</code>  <code>async</code>","text":"<p>Close resources owned by this router's health check probes.</p> <p>Call this from your FastAPI lifespan shutdown (e.g. after <code>yield</code> in an <code>@asynccontextmanager</code> lifespan) so cached clients are closed.</p> Source code in <code>fast_healthchecks/integrations/fastapi.py</code> <pre><code>async def close(self) -&gt; None:\n    \"\"\"Close resources owned by this router's health check probes.\n\n    Call this from your FastAPI lifespan shutdown (e.g. after ``yield``\n    in an ``@asynccontextmanager`` lifespan) so cached clients are closed.\n    \"\"\"\n    await close_probes(self._healthcheck_probes)\n</code></pre>"},{"location":"api/#fast_healthchecks.integrations.fastapi.healthcheck_shutdown","title":"<code>healthcheck_shutdown(probes)</code>","text":"<p>Return an async shutdown callback that closes the given probes' checks.</p> <p>Use this with framework lifespan/shutdown hooks (e.g. Litestar <code>on_shutdown</code>, FastStream shutdown) so that health check resources are closed on app shutdown.</p> <p>Parameters:</p> Name Type Description Default <code>probes</code> <code>Iterable[Probe]</code> <p>The same probes passed to your health routes.</p> required <p>Returns:</p> Type Description <code>Callable[[], Awaitable[None]]</code> <p>An async callable with no arguments that closes all checks with <code>aclose()</code>.</p> Source code in <code>fast_healthchecks/integrations/base.py</code> <pre><code>def healthcheck_shutdown(probes: Iterable[Probe]) -&gt; Callable[[], Awaitable[None]]:\n    \"\"\"Return an async shutdown callback that closes the given probes' checks.\n\n    Use this with framework lifespan/shutdown hooks (e.g. Litestar ``on_shutdown``,\n    FastStream shutdown) so that health check resources are closed on app shutdown.\n\n    Args:\n        probes: The same probes passed to your health routes.\n\n    Returns:\n        An async callable with no arguments that closes all checks with ``aclose()``.\n    \"\"\"\n\n    async def _shutdown() -&gt; None:\n        await close_probes(probes)\n\n    return _shutdown\n</code></pre>"},{"location":"api/#fast_healthchecks.integrations.faststream.health","title":"<code>health(*probes, options=None)</code>","text":"<p>Make list of routes for healthchecks.</p> <p>Returns:</p> Type Description <code>Iterable[tuple[str, ASGIApp]]</code> <p>Iterable[tuple[str, ASGIApp]]: Generated healthcheck routes.</p> <p>To close health check resources on app shutdown, pass the same probes to <code>healthcheck_shutdown(probes)</code> and register the returned callback with your FastStream app's shutdown hooks (e.g. <code>@app.on_shutdown</code>).</p> Source code in <code>fast_healthchecks/integrations/faststream.py</code> <pre><code>def health(\n    *probes: Probe,\n    options: ProbeRouteOptions | None = None,\n) -&gt; Iterable[tuple[str, ASGIApp]]:\n    \"\"\"Make list of routes for healthchecks.\n\n    Returns:\n        Iterable[tuple[str, ASGIApp]]: Generated healthcheck routes.\n\n    To close health check resources on app shutdown, pass the same probes\n    to ``healthcheck_shutdown(probes)`` and register the returned callback\n    with your FastStream app's shutdown hooks (e.g. ``@app.on_shutdown``).\n    \"\"\"\n    return build_health_routes(probes, add_route=_add_probe_route, options=options)\n</code></pre>"},{"location":"api/#fast_healthchecks.integrations.faststream.healthcheck_shutdown","title":"<code>healthcheck_shutdown(probes)</code>","text":"<p>Return an async shutdown callback that closes the given probes' checks.</p> <p>Use this with framework lifespan/shutdown hooks (e.g. Litestar <code>on_shutdown</code>, FastStream shutdown) so that health check resources are closed on app shutdown.</p> <p>Parameters:</p> Name Type Description Default <code>probes</code> <code>Iterable[Probe]</code> <p>The same probes passed to your health routes.</p> required <p>Returns:</p> Type Description <code>Callable[[], Awaitable[None]]</code> <p>An async callable with no arguments that closes all checks with <code>aclose()</code>.</p> Source code in <code>fast_healthchecks/integrations/base.py</code> <pre><code>def healthcheck_shutdown(probes: Iterable[Probe]) -&gt; Callable[[], Awaitable[None]]:\n    \"\"\"Return an async shutdown callback that closes the given probes' checks.\n\n    Use this with framework lifespan/shutdown hooks (e.g. Litestar ``on_shutdown``,\n    FastStream shutdown) so that health check resources are closed on app shutdown.\n\n    Args:\n        probes: The same probes passed to your health routes.\n\n    Returns:\n        An async callable with no arguments that closes all checks with ``aclose()``.\n    \"\"\"\n\n    async def _shutdown() -&gt; None:\n        await close_probes(probes)\n\n    return _shutdown\n</code></pre>"},{"location":"api/#fast_healthchecks.integrations.litestar.health","title":"<code>health(*probes, options=None)</code>","text":"<p>Make list of routes for healthchecks.</p> <p>Returns:</p> Type Description <code>Iterable[HTTPRouteHandler]</code> <p>Iterable[HTTPRouteHandler]: Generated healthcheck route handlers.</p> <p>To close health check resources on app shutdown, pass the same probes to <code>healthcheck_shutdown(probes)</code> and add the returned callback to Litestar's <code>on_shutdown</code> list.</p> Source code in <code>fast_healthchecks/integrations/litestar.py</code> <pre><code>def health(\n    *probes: Probe,\n    options: ProbeRouteOptions | None = None,\n) -&gt; Iterable[HTTPRouteHandler]:\n    \"\"\"Make list of routes for healthchecks.\n\n    Returns:\n        Iterable[HTTPRouteHandler]: Generated healthcheck route handlers.\n\n    To close health check resources on app shutdown, pass the same probes\n    to ``healthcheck_shutdown(probes)`` and add the returned callback to\n    Litestar's ``on_shutdown`` list.\n    \"\"\"\n    return build_health_routes(probes, add_route=_add_probe_route, options=options)\n</code></pre>"},{"location":"api/#fast_healthchecks.integrations.litestar.healthcheck_shutdown","title":"<code>healthcheck_shutdown(probes)</code>","text":"<p>Return an async shutdown callback that closes the given probes' checks.</p> <p>Use this with framework lifespan/shutdown hooks (e.g. Litestar <code>on_shutdown</code>, FastStream shutdown) so that health check resources are closed on app shutdown.</p> <p>Parameters:</p> Name Type Description Default <code>probes</code> <code>Iterable[Probe]</code> <p>The same probes passed to your health routes.</p> required <p>Returns:</p> Type Description <code>Callable[[], Awaitable[None]]</code> <p>An async callable with no arguments that closes all checks with <code>aclose()</code>.</p> Source code in <code>fast_healthchecks/integrations/base.py</code> <pre><code>def healthcheck_shutdown(probes: Iterable[Probe]) -&gt; Callable[[], Awaitable[None]]:\n    \"\"\"Return an async shutdown callback that closes the given probes' checks.\n\n    Use this with framework lifespan/shutdown hooks (e.g. Litestar ``on_shutdown``,\n    FastStream shutdown) so that health check resources are closed on app shutdown.\n\n    Args:\n        probes: The same probes passed to your health routes.\n\n    Returns:\n        An async callable with no arguments that closes all checks with ``aclose()``.\n    \"\"\"\n\n    async def _shutdown() -&gt; None:\n        await close_probes(probes)\n\n    return _shutdown\n</code></pre>"},{"location":"api/#fast_healthchecks.utils.maybe_redact","title":"<code>maybe_redact(data, *, redact_secrets)</code>","text":"<p>Return data with secrets redacted if requested, otherwise return as-is.</p> Source code in <code>fast_healthchecks/utils.py</code> <pre><code>def maybe_redact(data: dict[str, Any], *, redact_secrets: bool) -&gt; dict[str, Any]:\n    \"\"\"Return data with secrets redacted if requested, otherwise return as-is.\"\"\"\n    return redact_secrets_in_dict(data) if redact_secrets else data\n</code></pre>"},{"location":"api/#fast_healthchecks.utils.parse_query_string","title":"<code>parse_query_string(query)</code>","text":"<p>Parse a URL query string into a dictionary.</p> <p>Keys and values are URL-decoded (unquoted). Pairs without '=' are stored with an empty value. Values containing '=' are preserved.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>The query string (e.g. 'key1=value1&amp;key2=value2').</p> required <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>A dictionary of key-value pairs.</p> Source code in <code>fast_healthchecks/utils.py</code> <pre><code>def parse_query_string(query: str) -&gt; dict[str, str]:\n    \"\"\"Parse a URL query string into a dictionary.\n\n    Keys and values are URL-decoded (unquoted). Pairs without '=' are stored\n    with an empty value. Values containing '=' are preserved.\n\n    Args:\n        query: The query string (e.g. 'key1=value1&amp;key2=value2').\n\n    Returns:\n        A dictionary of key-value pairs.\n    \"\"\"\n    if not query:\n        return {}\n    result: dict[str, str] = {}\n    for part in query.split(\"&amp;\"):\n        kv = part.split(\"=\", 1)\n        key = unquote(kv[0]) if kv[0] else \"\"\n        value = unquote(kv[1]) if len(kv) &gt; 1 else \"\"\n        result[key] = value\n    return result\n</code></pre>"},{"location":"api/#fast_healthchecks.utils.redact_secrets_in_dict","title":"<code>redact_secrets_in_dict(data)</code>","text":"<p>Return a copy of data with credential fields replaced by placeholder.</p> Source code in <code>fast_healthchecks/utils.py</code> <pre><code>def redact_secrets_in_dict(data: dict[str, Any]) -&gt; dict[str, Any]:\n    \"\"\"Return a copy of data with credential fields replaced by placeholder.\"\"\"\n    return {k: (REDACT_PLACEHOLDER if k in _SECRET_KEYS else v) for k, v in data.items()}\n</code></pre>"},{"location":"api/#fast_healthchecks.utils.validate_host_ssrf_async","title":"<code>validate_host_ssrf_async(host)</code>  <code>async</code>","text":"<p>Resolve host to IP(s) and reject if any are loopback/private/reserved (SSRF/DNS rebinding).</p> <p>Call this before making the request when block_private_hosts=True, so that hostnames that resolve to private IPs (e.g. internal DNS or DNS rebinding) are rejected.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>The hostname to resolve and validate.</p> required <p>Raises:</p> Type Description <code>HealthCheckSSRFError</code> <p>If any resolved IP is loopback, private, or reserved.</p> Source code in <code>fast_healthchecks/utils.py</code> <pre><code>async def validate_host_ssrf_async(host: str) -&gt; None:\n    \"\"\"Resolve host to IP(s) and reject if any are loopback/private/reserved (SSRF/DNS rebinding).\n\n    Call this before making the request when block_private_hosts=True, so that\n    hostnames that resolve to private IPs (e.g. internal DNS or DNS rebinding)\n    are rejected.\n\n    Args:\n        host: The hostname to resolve and validate.\n\n    Raises:\n        HealthCheckSSRFError: If any resolved IP is loopback, private, or reserved.\n    \"\"\"\n    host = (host or \"\").strip()\n    if not host:\n        return\n    if host.lower() in {\"localhost\", \"localhost.\", \"localhost6\", \"localhost6.localdomain6\"}:\n        msg = \"URL host must not be localhost when block_private_hosts=True\"\n        raise HealthCheckSSRFError(msg)\n    try:\n        loop = asyncio.get_running_loop()\n        infos = await loop.run_in_executor(None, lambda: socket.getaddrinfo(host, None))\n    except OSError:\n        # Resolution failed; let the subsequent request fail or handle\n        return\n    for _family, _type, _proto, _canon, sockaddr in infos:\n        if not sockaddr:\n            continue\n        ip_str = sockaddr[0] if isinstance(sockaddr, (list, tuple)) else getattr(sockaddr, \"host\", None)\n        if not ip_str:\n            continue\n        addr = _parse_ip_safe(ip_str)\n        if addr is None:\n            continue\n        if addr.is_loopback or addr.is_private or addr.is_reserved:\n            msg = \"URL host must not resolve to loopback or private when block_private_hosts=True\"\n            raise HealthCheckSSRFError(msg)\n</code></pre>"},{"location":"api/#fast_healthchecks.utils.validate_url_ssrf","title":"<code>validate_url_ssrf(url, *, allowed_schemes=frozenset({'http', 'https'}), block_private_hosts=False)</code>","text":"<p>Validate URL for SSRF-sensitive use (e.g. healthchecks from config).</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL string to validate.</p> required <code>allowed_schemes</code> <code>frozenset[str]</code> <p>Schemes permitted (default http, https).</p> <code>frozenset({'http', 'https'})</code> <code>block_private_hosts</code> <code>bool</code> <p>If True, reject localhost and private IP ranges.</p> <code>False</code> <p>Raises:</p> Type Description <code>HealthCheckSSRFError</code> <p>If scheme is not allowed or host is in blocked range.</p> Source code in <code>fast_healthchecks/utils.py</code> <pre><code>def validate_url_ssrf(\n    url: str,\n    *,\n    allowed_schemes: frozenset[str] = frozenset({\"http\", \"https\"}),\n    block_private_hosts: bool = False,\n) -&gt; None:\n    \"\"\"Validate URL for SSRF-sensitive use (e.g. healthchecks from config).\n\n    Args:\n        url: The URL string to validate.\n        allowed_schemes: Schemes permitted (default http, https).\n        block_private_hosts: If True, reject localhost and private IP ranges.\n\n    Raises:\n        HealthCheckSSRFError: If scheme is not allowed or host is in blocked range.\n    \"\"\"\n    parsed = urlparse(url)\n    scheme = (parsed.scheme or \"\").lower()\n    if scheme not in allowed_schemes:\n        msg = f\"URL scheme must be one of {sorted(allowed_schemes)}, got {scheme!r}\"\n        raise HealthCheckSSRFError(msg)\n    if not block_private_hosts:\n        return\n    host = (parsed.hostname or \"\").strip()\n    if not host:\n        return\n    if host.lower() in {\"localhost\", \"localhost.\", \"localhost6\", \"localhost6.localdomain6\"}:\n        msg = \"URL host must not be localhost when block_private_hosts=True\"\n        raise HealthCheckSSRFError(msg)\n    addr = _parse_ip_safe(host)\n    if addr is None:\n        return\n    if addr.is_loopback or addr.is_private or addr.is_reserved:\n        msg = \"URL host must not be loopback or private when block_private_hosts=True\"\n        raise HealthCheckSSRFError(msg)\n</code></pre>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#changelog_1","title":"Changelog","text":"<p>Versioning follows Semantic Versioning. Breaking changes and the deprecation process are documented in CONTRIBUTING (\u00a7 Backward compatibility and deprecation).</p>"},{"location":"changelog/#025-2026-02-16","title":"0.2.5 (2026-02-16)","text":""},{"location":"changelog/#fix","title":"Fix","text":"<ul> <li>checks: fixed <code>__slots__</code> in <code>RabbitMQHealthCheck</code>, renamed <code>check_pydantinc_installed</code> -&gt; <code>check_pydantic_installed</code>, <code>from_dsn</code> for <code>MongoHealthCheck</code> and <code>parse_dsn</code> for <code>BasePostgreSQLHealthCheck</code> more stable</li> </ul>"},{"location":"changelog/#024-2025-09-19","title":"0.2.4 (2025-09-19)","text":""},{"location":"changelog/#fix_1","title":"Fix","text":"<ul> <li>typing: prevent typing from failing</li> </ul>"},{"location":"changelog/#023-2025-09-19","title":"0.2.3 (2025-09-19)","text":""},{"location":"changelog/#fix_2","title":"Fix","text":"<ul> <li>all: upgrade dependencies, make tests more stable, switch <code>mypy</code> to <code>ty</code></li> </ul>"},{"location":"changelog/#022-2025-04-16","title":"0.2.2 (2025-04-16)","text":""},{"location":"changelog/#fix_3","title":"Fix","text":"<ul> <li>all: make PEP 561 compatible</li> </ul>"},{"location":"changelog/#021-2025-03-07","title":"0.2.1 (2025-03-07)","text":""},{"location":"changelog/#fix_4","title":"Fix","text":"<ul> <li>mongo: added multihost support for MongoDB</li> </ul>"},{"location":"changelog/#020-2025-02-20","title":"0.2.0 (2025-02-20)","text":""},{"location":"changelog/#feat","title":"Feat","text":"<ul> <li>healthchecks: added OpenSearch healthcheck</li> </ul>"},{"location":"changelog/#fix_5","title":"Fix","text":"<ul> <li>dependencies: upgrade github actions</li> <li>vscode: fixed ruff plugin setup</li> <li>dependencies: upgrade dependencies</li> <li>dependencies: upgrade pre-commit</li> <li>docs: typo in install commands</li> </ul>"},{"location":"changelog/#refactor","title":"Refactor","text":"<ul> <li>tests: move <code>to_dict</code> method out of tests</li> </ul>"},{"location":"changelog/#015-2025-01-23","title":"0.1.5 (2025-01-23)","text":""},{"location":"changelog/#fix_6","title":"Fix","text":"<ul> <li>redis: added support for SSL connections</li> </ul>"},{"location":"changelog/#014-2025-01-22","title":"0.1.4 (2025-01-22)","text":""},{"location":"changelog/#fix_7","title":"Fix","text":"<ul> <li>dependencies: upgrade dependencies and pre-commit</li> <li>mongo: fixed Mongo check</li> </ul>"},{"location":"changelog/#013-2024-12-10","title":"0.1.3 (2024-12-10)","text":""},{"location":"changelog/#fix_8","title":"Fix","text":"<ul> <li>validate_dsn: removed dummy validation isinstance</li> </ul>"},{"location":"changelog/#012-2024-12-10","title":"0.1.2 (2024-12-10)","text":""},{"location":"changelog/#fix_9","title":"Fix","text":"<ul> <li>setuptools: included packages</li> <li>docs: changed logo for documentation to green color</li> </ul>"},{"location":"changelog/#011-2024-12-09","title":"0.1.1 (2024-12-09)","text":""},{"location":"changelog/#fix_10","title":"Fix","text":"<ul> <li>docs: fixed <code>README.md</code></li> </ul>"},{"location":"changelog/#010-2024-12-09","title":"0.1.0 (2024-12-09)","text":""},{"location":"changelog/#feat_1","title":"Feat","text":"<ul> <li>all: \ud83d\ude80 INIT</li> </ul>"},{"location":"configuration/","title":"Configuration objects","text":"<p>Connection-based checks (Redis, Kafka, Mongo, RabbitMQ, OpenSearch, URL, PostgreSQL, Function) accept either keyword arguments or an optional <code>config</code> argument. When <code>config</code> is <code>None</code>, the check builds its config from <code>**kwargs</code>. Config types (e.g. <code>RedisConfig</code>, <code>UrlConfig</code>) are defined in <code>fast_healthchecks.checks.configs</code> and are used for typing and for <code>to_dict()</code> serialization. This keeps constructor signatures short and avoids long parameter lists. For the full list and field reference, see API Reference \u2014 fast_healthchecks.checks.configs.</p>"},{"location":"contributing/","title":"Contributing","text":""},{"location":"contributing/#contributing_1","title":"Contributing","text":""},{"location":"contributing/#project-name","title":"Project name","text":"<p>The canonical project name for documentation and UI is Fast Healthchecks (two words, with \"s\"). The PyPI package name is <code>fast-healthchecks</code>. Use this name consistently in these files (and any other project-facing text):</p> <ul> <li>README.md \u2014 main heading and project title</li> <li>docs/index.md \u2014 main heading and project title</li> <li>pyproject.toml \u2014 <code>description</code></li> <li>mkdocs.yml \u2014 <code>site_name</code></li> </ul>"},{"location":"contributing/#documentation-single-source-of-truth","title":"Documentation (single source of truth)","text":"<p>Each piece of documentation has one canonical source. When editing, change only the canonical source; other files may contain a short pointer or link.</p> Content Canonical source Contributing guide This file (CONTRIBUTING.md). docs/contributing.md includes it via MkDocs. Changelog CHANGELOG.md. docs/changelog.md includes it. Package version pyproject.toml <code>version</code>. commitizen syncs to <code>fast_healthchecks/__init__.py</code> <code>__version__</code>. Installation (pip/poetry/uv, extras) docs/installation.md. README has a short line and link to the documentation. Example code in docs Files in <code>examples/</code>. Included in docs/usage.md via <code>include-markdown</code>. Code in <code>examples/</code> is part of the codebase and must follow PEP 8 and the project style (Ruff, pre-commit). User-facing docs (configuration, lifecycle, probe options, DSN, run_probe, SSRF, PostgreSQL TLS rotation) docs/ (docs/index.md and related MkDocs pages). In case of conflict, docs are authoritative. README is the entry point with a short overview and links to the documentation. Public API boundary (configs, to_dict) docs/api.md is the single source of truth for the public API. README may have a one-line pointer to API Reference. Style guide (naming, docstrings, standards) This file. docs/style-guide.md is a pointer to the relevant sections. Security policy SECURITY.md (repo root). docs/security.md includes it for the documentation site. Test certificates policy This file, \u00a7 Test certificates. README may have a one-line pointer. Running tests (local) README \u00a7 Running tests. CONTRIBUTING \u00a7 CI and release references it. Task runner recipes (full list and descriptions) justfile (and <code>just</code> or <code>just --list</code>). README lists only the main recipes with short pointers. Doc structure (pages and order) <code>nav</code> in mkdocs.yml. When adding or removing a page, update both <code>nav</code> and the link list in docs/index.md so they stay in sync. <p>When adding or changing user-facing content, update the canonical source (docs or other as above); in README, add or keep only a short pointer or link if needed.</p> <p>Wrapper pages in <code>docs/</code> (e.g. <code>docs/security.md</code>, <code>docs/changelog.md</code>, <code>docs/contributing.md</code>) that only include a file from the repo root must not duplicate the H1 heading from the included file; the H1 is defined once in the canonical source.</p>"},{"location":"contributing/#naming-conventions","title":"Naming conventions","text":""},{"location":"contributing/#documentation-files-docs","title":"Documentation files (docs/)","text":"<p>Use lowercase; multi-word filenames use a hyphen (e.g. <code>probe-options.md</code>, <code>dsn-formats.md</code>, <code>style-guide.md</code>). The repo root keeps <code>SECURITY.md</code> (uppercase) for GitHub convention; the documentation site uses <code>docs/security.md</code>, which includes it. The doc filename should match the key used in <code>nav</code> in mkdocs.yml (e.g. <code>Changelog: changelog.md</code>).</p>"},{"location":"contributing/#files-and-modules","title":"Files and modules","text":"<ul> <li>Packages and modules: Use <code>snake_case</code> (e.g. <code>fast_healthchecks</code>, <code>dsn_parsing</code>). See PEP 8.</li> <li>Private modules: Use a leading underscore for internal implementation modules (e.g. <code>_base</code>, <code>_imports</code>). These are not part of the stable public import surface. Config types are available from <code>fast_healthchecks.checks.configs</code>.</li> <li>Tests: Test files are named <code>test_*.py</code>. The pre-commit hook <code>name-tests-test</code> enforces this. Exceptions (utility or helper modules that are not tests) are listed in <code>.pre-commit-config.yaml</code> under that hook: <code>tests/utils.py</code> (shared test utilities), <code>tests/unit/integrations/helpers.py</code> (unit-test helpers), <code>tests/integration/checks/httpbin_like_app.py</code> (helper ASGI app for integration tests, not a test case).</li> <li>Integrations: FastStream and Litestar integrations intentionally duplicate the structure (health, _add_probe_route); shared logic lives in <code>integrations.base</code>.</li> </ul>"},{"location":"contributing/#workflows","title":"Workflows","text":"<p>Files in <code>.github/workflows/</code> use a numeric prefix for order. In the GitHub Actions UI, each workflow has a display name (<code>name:</code> in the file). Reference:</p> File Display name Purpose <code>1_test.yml</code> Tests Pre-commit, import tests, unit tests, integration tests. <code>2_bump.yml</code> Bump version Manual version bump and tag (commitizen). <code>2_rollback.yml</code> Rollback release Delete GitHub release and tag, force-push branch to commit before tag. <code>3_release.yml</code> Release Build and publish to PyPI (Trusted Publishing). <code>4_codeql.yml</code> CodeQL Code security analysis. <code>5_dependency_review.yml</code> Dependency review Dependency review on pull requests."},{"location":"contributing/#identifiers","title":"Identifiers","text":"<ul> <li>Classes: <code>PascalCase</code> (e.g. <code>HealthCheckResult</code>, <code>RedisHealthCheck</code>, <code>ProbeRouteOptions</code>).</li> <li>Functions and methods: <code>snake_case</code> (e.g. <code>healthcheck_safe</code>, <code>build_probe_route_options</code>, <code>run_probe</code>).</li> <li>Module-level constants: <code>UPPER_SNAKE_CASE</code> (e.g. <code>DEFAULT_HC_TIMEOUT</code>, <code>VALID_SECURITY_PROTOCOLS</code>, <code>REDACT_PLACEHOLDER</code>).</li> <li>Private attributes and helpers: Leading underscore (e.g. <code>_name</code>, <code>_config</code>, <code>_create_client</code>, <code>_get_check_name</code>). Exported names like <code>_CLIENT_CACHING_SLOTS</code> in <code>__all__</code> are intentional when subclasses need them (e.g. for <code>__slots__</code>).</li> <li>TypeVars: Single capital or suffix per PEP 484 (e.g. <code>T_co</code>, <code>ClientT</code>, <code>P</code>); use a leading underscore for module-internal TypeVars (e.g. <code>_T</code>). In TypedDict, camelCase for fields is acceptable when it matches an external API or driver (e.g. <code>authSource</code> for MongoDB).</li> <li>Term in code: Use the single word healthcheck in identifiers (e.g. <code>HealthcheckRouter</code>, <code>healthcheck_safe</code>). In prose (README, docs, docstrings) use \"health check\" or \"health checks\" (two words). When adding new public modules, add them to <code>docs/api.md</code>. When changing the public contract (new stable imports, deprecation, or removal), update the description in <code>docs/api.md</code> and the API note in README if present, so the public API boundary stays documented.</li> </ul>"},{"location":"contributing/#docstrings","title":"Docstrings","text":"<p>Docstrings follow the Google convention. This is enforced by Ruff (<code>tool.ruff.lint.pydocstyle</code> in <code>pyproject.toml</code>). See Google Python Style Guide \u2014 Docstrings.</p> <p>Module docstrings: Use a single summary line (imperative or neutral, e.g. \"Provide \u2026\", \"Define \u2026\", or \"Health check for X\"). Add one or two lines of detail if needed. Optional sections such as Classes, Usage, or Example are acceptable for public modules that expose one main class; they are not required. New code and docstring refactors should follow this minimal template.</p>"},{"location":"contributing/#standards","title":"Standards","text":"<p>The project follows:</p> <ul> <li>PEP 8 \u2014 code style (enforced by Ruff).</li> <li>PEP 257 \u2014 docstrings; Google convention for format (set in Ruff).</li> <li>Semantic Versioning \u2014 versioning (commitizen, semver in <code>pyproject.toml</code>).</li> <li>Conventional Commits \u2014 commit message format (commitizen check in pre-commit).</li> <li>ADR \u2014 architecture decisions in <code>docs/decisions/</code> with numbering and status. When adding a new ADR: create <code>docs/decisions/NNN-short-title.md</code> (e.g. <code>002-some-topic.md</code>), include sections Status, Context, and Decision; update the table in docs/decisions/README.md with the new row (number, title, status, short summary).</li> </ul>"},{"location":"contributing/#backward-compatibility-and-deprecation","title":"Backward compatibility and deprecation","text":"<ul> <li>SemVer: We follow Semantic Versioning. Version is MAJOR.MINOR.PATCH. Breaking changes require a MAJOR bump; new backward-compatible features use MINOR; backward-compatible fixes use PATCH. Breaking changes are recorded in CHANGELOG (under Refactor or a dedicated Breaking section) and trigger a MAJOR version bump. CHANGELOG and commitizen are aligned with this: each release entry is categorized (Feat, Fix, Refactor, etc.), and breaking changes are called out explicitly.</li> <li>Stable surface: What we guarantee across MINOR and PATCH releases are the symbols in <code>fast_healthchecks.__all__</code> and <code>fast_healthchecks.checks.__all__</code>, the documented public API in docs/api.md, and the behavior described there. The supported public surface (import paths and stability across minor versions) is that API reference and those <code>__all__</code> lists; see docs/api.md for the full list. Subpackage import paths (e.g. <code>from fast_healthchecks.checks.redis import RedisHealthCheck</code>) that are documented or implied by the API reference are also stable unless deprecated.</li> <li>Internal: Modules or names not listed in the API reference or <code>__all__</code> (e.g. <code>_base</code>, <code>ToDictMixin.to_dict</code> on check instances) are internal. We may change or remove them without a MAJOR bump; avoid relying on them in production code.</li> <li>Deprecation: When we deprecate a public API, we (1) document the deprecation in CHANGELOG and in the relevant docstring or docs/api.md, (2) emit a <code>DeprecationWarning</code> at runtime where feasible (e.g. when the deprecated function or class is used), and (3) keep the deprecated API for at least one MINOR release before removal. Removal is done in a MAJOR release. The minimum timeline (one MINOR before removal) and this policy are documented here (CONTRIBUTING).</li> </ul>"},{"location":"contributing/#ci-and-release","title":"CI and release","text":"<p>Full description of release and CI (workflows, secrets, bump, rollback, pre-commit) is only in this section. README has a short pointer and link here.</p> <p>Security: Vulnerability reports are handled privately; see SECURITY.md. Do not open public issues for security-sensitive bugs.</p> <p>For running tests locally (<code>just tests-imports</code>, <code>just tests-unit</code>, <code>just tests-integration</code>, <code>just tests-all</code>), see README \u00a7 Running tests.</p>"},{"location":"contributing/#github-actions-secrets","title":"GitHub Actions secrets","text":"<ul> <li>Bump workflow (manual version bump): Uses <code>PERSONAL_ACCESS_TOKEN</code> for checkout and commitizen-action (push version bump and tag). Use a Fine-grained PAT or GitHub App with minimal scope: repository Contents (read and write). No PyPI token is used for this workflow.</li> <li>PyPI publish: Release is done via Trusted Publishing (OIDC). The workflow uses <code>id-token: write</code> and <code>pypa/gh-action-pypi-publish</code>; no PyPI API token is stored in GitHub Secrets. Do not add a PyPI token to the <code>pypi</code> environment.</li> </ul>"},{"location":"contributing/#test-certificates","title":"Test certificates","text":"<p>Files under <code>tests/certs/</code> (e.g. <code>key.key</code>, <code>ca.key</code>) are used only to run tests (unit and integration, e.g. TLS checks). They are excluded from the pre-commit hook <code>detect-private-key</code> by design. Do not use them outside local or CI test runs. In production, use your own certificates and secrets.</p>"},{"location":"contributing/#reproducible-build","title":"Reproducible build","text":"<p>On release (tag), the workflow runs a reproducible-build job: two builds in the same runner with the same Python version (3.14), same lockfile (<code>uv sync --frozen</code>), and <code>SOURCE_DATE_EPOCH=0</code>. Wheel hashes are compared; the job fails if they differ. Scope: reproducibility is defined within this fixed environment (same runner image, same Python patch version, same toolchain). We do not claim cross-version or cross-runner reproducibility.</p>"},{"location":"contributing/#pre-commit","title":"Pre-commit","text":"<p>Pre-commit runs the same checks as CI. The hook <code>no-commit-to-branch</code> is skipped on CI via <code>SKIP</code>. Pre-commit is executed with <code>uv run --no-sync pre-commit run ...</code>; <code>pre-commit-uv</code> is in the dev dependency group and locked in <code>uv.lock</code>.</p> <p>When updating uv, update the uv-pre-commit revision in <code>.pre-commit-config.yaml</code> to match: use the uv-pre-commit releases and set <code>rev</code> to the commit SHA that corresponds to the uv version (keep the <code># frozen: &lt;version&gt;</code> comment for readability).</p> <p>Periodically update hook revisions in <code>.pre-commit-config.yaml</code> (e.g. run <code>pre-commit autoupdate</code>), then run pre-commit and the test suite to verify.</p>"},{"location":"dsn-formats/","title":"DSN formats","text":"<p>Checks that support <code>from_dsn()</code> accept these URL schemes:</p> Check Scheme Example Redis <code>redis://</code> <code>redis://localhost:6379/0</code>, <code>redis://user:pass@host:6379</code> MongoDB <code>mongodb://</code> <code>mongodb://localhost:27017</code>, <code>mongodb://user:pass@host/db?authSource=admin</code> PostgreSQL <code>postgresql://</code> <code>postgresql://user:pass@localhost:5432/dbname</code> RabbitMQ <code>amqp://</code> <code>amqp://user:pass@localhost:5672/%2F</code> Kafka <code>kafka://</code> <code>kafka://broker1:9092,broker2:9092</code>, <code>kafka://user:pass@host:9092</code> OpenSearch <code>http://</code> or <code>https://</code> <code>https://admin:pass@localhost:9200</code>"},{"location":"dsn-formats/#postgresql-tls-certificate-rotation","title":"PostgreSQL TLS certificate rotation","text":"<p>PostgreSQL checks (<code>verify-full</code>, <code>verify-ca</code>) cache the SSL context. After rotating certificates, restart the process or call <code>fast_healthchecks.checks.postgresql.base.create_ssl_context.cache_clear()</code> to avoid using stale contexts.</p>"},{"location":"installation/","title":"Installation","text":"<p>With <code>pip</code>: <pre><code>pip install fast-healthchecks\n</code></pre></p> <p>With <code>poetry</code>: <pre><code>poetry add fast-healthchecks\n</code></pre></p> <p>With <code>uv</code>: <pre><code>uv add fast-healthchecks\n</code></pre></p> <p>Backends (Redis, Kafka, Mongo, PostgreSQL, etc.) and framework integrations are optional. Install the extras you need, e.g. <code>pip install fast-healthchecks[redis]</code> or <code>pip install fast-healthchecks[redis,mongo,fastapi]</code>. See the project's <code>pyproject.toml</code> for all extra names (asyncpg, psycopg, redis, aio-pika, httpx, aiokafka, motor, fastapi, faststream, litestar, opensearch).</p>"},{"location":"lifecycle/","title":"Lifecycle and shutdown","text":""},{"location":"lifecycle/#open-client-mechanics","title":"Open client mechanics","text":"<p>Checks that cache a client (Redis, Mongo, Kafka, OpenSearch, URL, RabbitMQ, PostgreSQL) keep one connection per instance. Such checks implement <code>aclose()</code> and are said to hold an open client. Open clients are not closed inside <code>run_probe</code>; they are closed only by the documented shutdown path below.</p> <ul> <li>Which checks have open clients: Any check that has an <code>aclose</code> method (e.g. those using <code>ClientCachingMixin</code>). Function-based checks and checks without <code>aclose</code> do not hold open clients.</li> <li>Which shutdown path closes them: Only <code>healthcheck_shutdown(probes)</code> or <code>close_probes(probes)</code> (path Y). On cancellation or timeout of <code>run_probe</code>, cached clients are not closed; the caller is responsible for calling the shutdown path (path X) so that Y runs.</li> </ul>"},{"location":"lifecycle/#cleanup-paths-x-and-y","title":"Cleanup paths (X and Y)","text":"<ul> <li>X (when cleanup runs): The caller invokes <code>healthcheck_shutdown(probes)</code> (or <code>close_probes(probes)</code>) after using the probes\u2014typically in the framework\u2019s lifespan/shutdown hook. On cancellation or timeout of <code>run_probe</code>, <code>run_probe</code> does not close cached clients; the caller should still call the shutdown path so that resources are closed.</li> <li>Y (what closes open clients): <code>close_probes(probes)</code> (and thus <code>healthcheck_shutdown(probes)</code>) calls <code>aclose()</code> on each check that has it. Cached clients are closed only by this path, not inside <code>run_probe</code>.</li> </ul> <p>After cancel or timeout there are no dangling background tasks from <code>run_probe</code> (the probe\u2019s check tasks are cancelled); a cached client may remain open until the caller invokes Y.</p>"},{"location":"lifecycle/#framework-shutdown","title":"Framework shutdown","text":"<p>To close health check resources on app shutdown:</p> <ul> <li>FastAPI: Store the router and call <code>await router.close()</code> in your lifespan context manager (after <code>yield</code>), or use <code>healthcheck_shutdown(probes)</code> and call the returned callback in lifespan.</li> <li>FastStream: Pass the callback from <code>healthcheck_shutdown(probes)</code> into your app's <code>on_shutdown</code> list, e.g. <code>AsgiFastStream(..., on_shutdown=[healthcheck_shutdown(probes)])</code>.</li> <li>Litestar: Pass the callback from <code>healthcheck_shutdown(probes)</code> into the app's <code>on_shutdown</code> list, e.g. <code>Litestar(..., on_shutdown=[healthcheck_shutdown(probes)])</code>.</li> </ul> <p>Import <code>healthcheck_shutdown</code> from <code>fast_healthchecks.integrations.fastapi</code>, <code>fast_healthchecks.integrations.faststream</code>, or <code>fast_healthchecks.integrations.litestar</code>.</p>"},{"location":"probe-options/","title":"Probe options","text":"Parameter Description <code>name</code> Probe identifier (e.g. <code>\"liveness\"</code>, <code>\"readiness\"</code>, <code>\"startup\"</code>). <code>checks</code> List of health checks to run. <code>summary</code> Custom description for the probe (used in responses). If omitted, a default is generated from <code>name</code>. <code>allow_partial_failure</code> If <code>True</code>, probe is healthy when at least one check passes. Default: <code>False</code>. <p>To customize HTTP responses, pass <code>options=build_probe_route_options(...)</code> to <code>HealthcheckRouter</code> or <code>health()</code>. Build options with:</p> Parameter Description <code>success_handler</code> Handler for healthy responses. Receives <code>ProbeAsgiResponse</code>, returns response body (or <code>None</code> for empty). <code>failure_handler</code> Handler for unhealthy responses. Same signature as <code>success_handler</code>. <code>success_status</code> HTTP status for healthy (default: <code>204</code> No Content). <code>failure_status</code> HTTP status for unhealthy (default: <code>503</code>). <code>debug</code> Include check details in responses (default: <code>False</code>). <code>prefix</code> URL prefix for probe routes (default: <code>\"/health\"</code>). <code>timeout</code> Max seconds for all checks; on exceed returns failure (default: <code>None</code> = no limit). <p>Example: <code>HealthcheckRouter(Probe(...), options=build_probe_route_options(debug=True, prefix=\"/health\"))</code>.</p>"},{"location":"run-probe/","title":"Running probes without ASGI","text":"<p>For CLI scripts, cron jobs, or tests, use <code>run_probe</code> instead of mounting ASGI routes:</p> <pre><code>import asyncio\nfrom fast_healthchecks.integrations.base import Probe, run_probe\nfrom fast_healthchecks.checks.function import FunctionHealthCheck\n\nasync def main():\n    probe = Probe(\n        name=\"readiness\",\n        checks=[FunctionHealthCheck(func=lambda: True, name=\"Ping\")],\n    )\n    report = await run_probe(probe)\n    print(report.healthy, report.results)\n\nasyncio.run(main())\n</code></pre> <p>Optional parameters: <code>timeout</code> (seconds), <code>on_check_start</code>, <code>on_check_end</code> (callbacks).</p>"},{"location":"run-probe/#hooks-for-metrics-and-tracing","title":"Hooks for metrics and tracing","text":"<p><code>on_check_start</code> and <code>on_check_end</code> are optional async callbacks that run before and after each check. Use them to record metrics (e.g. duration, success/failure) or to create tracing spans.</p> <ul> <li>on_check_start(probe_name, check_name, check_index) \u2014 called once per check before it runs. You can start a span or timer here and store it (e.g. in a context var or dict keyed by check_index).</li> <li>on_check_end(probe_name, check_name, check_index, result) \u2014 called after the check completes with the <code>HealthCheckResult</code>. Use <code>result.healthy</code> and optionally <code>result.error_details</code> for metrics or span status.</li> </ul> <p>Example: record check duration with a simple metrics callback (store start times by check index):</p> <pre><code>import time\nfrom fast_healthchecks.integrations.base import run_probe, Probe\n\nstarts: dict[int, float] = {}\n\nasync def on_start(probe_name: str, check_name: str, check_index: int) -&gt; None:\n    starts[check_index] = time.monotonic()\n\nasync def on_end(probe_name: str, check_name: str, check_index: int, result) -&gt; None:\n    duration = time.monotonic() - starts.get(check_index, time.monotonic())\n    # e.g. metrics.histogram(\"healthcheck_duration_seconds\", duration, tags=[check_name])\n    print(f\"{check_name} took {duration:.3f}s, healthy={result.healthy}\")\n\nreport = await run_probe(probe, on_check_start=on_start, on_check_end=on_end)\n</code></pre> <p>For OpenTelemetry or other backends, create a span in <code>on_check_start</code> and end it in <code>on_check_end</code> with the result status.</p>"},{"location":"run-probe/#timeout-semantics","title":"Timeout semantics","text":"<ul> <li>Probe-level timeout: The only timeout in the public contract is the probe-level <code>timeout</code> argument to <code>run_probe</code>. There is no per-check timeout; when the probe timeout is exceeded, all pending checks are cancelled (asyncio cancels the gather).</li> <li>One-check-hung vs others-done: If one check hangs and the others complete, the probe still waits until the probe-level timeout; then either an error is raised or a report with failures is returned (see modes below). No \"partial cancel\" of only the hung check\u2014cancel applies to the whole probe run.</li> <li>Two modes only:</li> <li>Mode A (<code>on_timeout_return_failure=False</code>): On timeout, <code>run_probe</code> raises <code>asyncio.TimeoutError</code> and does not return a report.</li> <li>Mode B (<code>on_timeout_return_failure=True</code>): On timeout, <code>run_probe</code> returns a <code>HealthCheckReport</code> with failed results for all checks (timed-out checks have <code>error_details</code> e.g. <code>\"Probe timed out\"</code>); <code>report.healthy</code> obeys <code>probe.allow_partial_failure</code>.</li> <li>Where Mode B is used: <code>ProbeAsgi</code> (and thus ASGI health routes) calls <code>run_probe(..., on_timeout_return_failure=True)</code> so that timeouts yield an HTTP response instead of raising.</li> </ul>"},{"location":"run-probe/#probe-logging-optional","title":"Probe logging (optional)","text":"<p>Structured logging for probe and check execution is optional and disabled by default. No external logging framework is required.</p> <ul> <li>Abstraction: Use <code>get_probe_logger()</code> / <code>set_probe_logger()</code> and <code>get_stdlib_probe_logger()</code> from <code>fast_healthchecks.logging</code>. The logger receives <code>log(level, msg, **extra)</code>; when using the stdlib adapter, <code>extra</code> is redacted (same keys as <code>utils.redact_secrets_in_dict</code>) so secrets never appear in log output.</li> <li>Events: When enabled, <code>run_probe</code> logs <code>probe_start</code> (probe name, checks count), and after completion <code>probe_end</code> (probe name, healthy, results summary). Per-check <code>check_start</code> / <code>check_end</code> (check name, index, healthy) are logged at DEBUG.</li> <li>Enable: Call <code>set_probe_logger(get_stdlib_probe_logger())</code> before running probes. Use <code>NullLogger()</code> or <code>set_probe_logger(NullLogger())</code> to disable (default).</li> </ul>"},{"location":"ssrf/","title":"URL check and SSRF protection","text":"<p>Use only trusted URLs from application configuration. Do not pass user-controlled input to <code>UrlHealthCheck</code> or to <code>validate_url_ssrf</code> / <code>validate_host_ssrf_async</code>; otherwise you risk SSRF and DNS rebinding.</p>"},{"location":"ssrf/#behaviour","title":"Behaviour","text":"<ul> <li>Schemes: Only <code>http</code> and <code>https</code> are allowed by default. Validation is done by <code>validate_url_ssrf</code> (and by <code>UrlHealthCheck</code> at construction). Custom schemes are not permitted for the URL check.</li> <li>block_private_hosts: When <code>True</code>:</li> <li>At construction: The URL host (if it is a literal IP) is checked; loopback and private/reserved ranges are rejected. Hostnames are not resolved at construction time.</li> <li>At run time: Before each request, the host is resolved via <code>validate_host_ssrf_async</code>. If the hostname resolves to any loopback, private, or reserved IP, the check fails with <code>HealthCheckSSRFError</code>. This mitigates DNS rebinding and internal hostnames that resolve to private IPs.</li> <li>Localhost names: The strings <code>localhost</code>, <code>localhost.</code>, <code>localhost6</code>, <code>localhost6.localdomain6</code> are rejected when <code>block_private_hosts=True</code> (whether or not they resolve).</li> </ul>"},{"location":"ssrf/#edge-cases","title":"Edge cases","text":"<ul> <li>Empty or missing host: URLs with no host (e.g. scheme-only or path-only) may pass scheme checks; validation skips host checks when host is empty.</li> <li>Hostname vs IP: Literal IPs are checked at init; hostnames are checked after resolution in <code>validate_host_ssrf_async</code>. Resolution is done at request time, so DNS changes between init and request are reflected.</li> <li>Resolution failure: If DNS resolution fails in <code>validate_host_ssrf_async</code>, the function returns without raising (the subsequent request may then fail). This avoids treating transient resolution errors as SSRF.</li> </ul>"},{"location":"ssrf/#api","title":"API","text":"<ul> <li>validate_url_ssrf (<code>fast_healthchecks.utils</code>): Validates scheme and, when <code>block_private_hosts=True</code>, rejects literal loopback/private IPs and localhost-like host names.</li> <li>validate_host_ssrf_async (<code>fast_healthchecks.utils</code>): Resolves the host and rejects if any resolved IP is loopback, private, or reserved. Used by <code>UrlHealthCheck</code> when <code>block_private_hosts=True</code> before each request.</li> <li>HealthCheckSSRFError: Raised when validation fails. See API reference.</li> </ul>"},{"location":"style-guide/","title":"Style guide","text":"<p>Naming, docstrings, and project standards are defined in the Contributing guide. Use these links to jump to the relevant sections:</p> <ul> <li>Project name</li> <li>Naming conventions</li> <li>Docstrings</li> <li>Standards</li> </ul> <p>For CI, release, and pre-commit see the rest of Contributing.</p>"},{"location":"usage/","title":"Usage","text":"<p>How you mount health checks depends on the framework:</p> <ul> <li>FastAPI: Use <code>HealthcheckRouter</code> with one or more <code>Probe</code> instances and pass it to <code>app.include_router()</code>.</li> <li>FastStream: Use the <code>health()</code> function from <code>fast_healthchecks.integrations.faststream</code> with your probes and options; it returns the routes to register with the app.</li> <li>Litestar: Use the <code>health()</code> function from <code>fast_healthchecks.integrations.litestar</code> with your probes and options; it returns the routes to register with the app.</li> </ul> <p>Create the health check endpoint dynamically using different conditions. Each condition is a callable, and you can even have dependencies inside it:</p> examples/probes.pyFastAPIFastStreamLitestar <pre><code>\"\"\"Probe and check factory helpers for example apps.\"\"\"\n\nimport asyncio\nimport os\nimport time\nfrom pathlib import Path\nfrom typing import Any\n\nfrom dotenv import load_dotenv\n\nfrom fast_healthchecks.checks.function import FunctionHealthCheck\nfrom fast_healthchecks.checks.kafka import KafkaHealthCheck\nfrom fast_healthchecks.checks.mongo import MongoHealthCheck\nfrom fast_healthchecks.checks.opensearch import OpenSearchHealthCheck\nfrom fast_healthchecks.checks.postgresql.asyncpg import PostgreSQLAsyncPGHealthCheck\nfrom fast_healthchecks.checks.postgresql.psycopg import PostgreSQLPsycopgHealthCheck\nfrom fast_healthchecks.checks.rabbitmq import RabbitMQHealthCheck\nfrom fast_healthchecks.checks.redis import RedisHealthCheck\nfrom fast_healthchecks.checks.types import Check\nfrom fast_healthchecks.checks.url import UrlHealthCheck\nfrom fast_healthchecks.integrations.base import ProbeAsgiResponse\n\n_ = load_dotenv(Path(__file__).parent.parent / \".env\")\n\n\ndef sync_dummy_check() -&gt; bool:\n    \"\"\"Run a synchronous dummy check that sleeps briefly and returns True.\n\n    Returns:\n        True.\n    \"\"\"\n    time.sleep(0.1)\n    return True\n\n\nasync def async_dummy_check() -&gt; bool:\n    \"\"\"Run an async dummy check that sleeps briefly and returns True.\n\n    Returns:\n        True.\n    \"\"\"\n    await asyncio.sleep(0.1)\n    return True\n\n\nasync def async_dummy_check_fail() -&gt; bool:\n    \"\"\"Run an async dummy check that raises ValueError.\n\n    Raises:\n        ValueError: Always.\n    \"\"\"\n    await asyncio.sleep(0)\n    msg = \"Failed\"\n    raise ValueError(msg) from None\n\n\ndef get_liveness_checks() -&gt; list[Check]:\n    \"\"\"Return new check instances (one set per app to avoid shared clients across event loops).\"\"\"\n    return [\n        FunctionHealthCheck(func=sync_dummy_check, name=\"Sync dummy\"),\n    ]\n\n\ndef get_readiness_checks() -&gt; list[Check]:\n    \"\"\"Return new check instances (one set per app to avoid shared clients across event loops).\"\"\"\n    return [\n        KafkaHealthCheck(\n            bootstrap_servers=os.environ[\"KAFKA_BOOTSTRAP_SERVERS\"],\n            name=\"Kafka\",\n        ),\n        MongoHealthCheck.from_dsn(os.environ[\"MONGO_DSN\"], name=\"Mongo\"),\n        OpenSearchHealthCheck(hosts=os.environ[\"OPENSEARCH_HOSTS\"].split(\",\"), name=\"OpenSearch\"),\n        PostgreSQLAsyncPGHealthCheck.from_dsn(os.environ[\"POSTGRES_DSN\"], name=\"PostgreSQL asyncpg\"),\n        PostgreSQLPsycopgHealthCheck.from_dsn(os.environ[\"POSTGRES_DSN\"], name=\"PostgreSQL psycopg\"),\n        RabbitMQHealthCheck.from_dsn(os.environ[\"RABBITMQ_DSN\"], name=\"RabbitMQ\"),\n        RedisHealthCheck.from_dsn(os.environ[\"REDIS_DSN\"], name=\"Redis\"),\n        UrlHealthCheck(url=\"https://httpbingo.org/status/200\", name=\"URL 200\"),\n    ]\n\n\ndef get_startup_checks() -&gt; list[Check]:\n    \"\"\"Return new check instances (one set per app to avoid shared clients across event loops).\"\"\"\n    return [\n        FunctionHealthCheck(func=async_dummy_check, name=\"Async dummy\"),\n    ]\n\n\ndef get_readiness_checks_success() -&gt; list[Check]:\n    \"\"\"Return new check instances for success-path tests.\"\"\"\n    return [\n        FunctionHealthCheck(func=async_dummy_check, name=\"Async dummy\"),\n    ]\n\n\ndef get_readiness_checks_fail() -&gt; list[Check]:\n    \"\"\"Return new check instances for failure-path tests.\"\"\"\n    return [\n        FunctionHealthCheck(func=async_dummy_check_fail, name=\"Async dummy fail\"),\n    ]\n\n\nLIVENESS_CHECKS: list[Check] = get_liveness_checks()\nREADINESS_CHECKS: list[Check] = get_readiness_checks()\nSTARTUP_CHECKS: list[Check] = get_startup_checks()\nREADINESS_CHECKS_SUCCESS: list[Check] = get_readiness_checks_success()\nREADINESS_CHECKS_FAIL: list[Check] = get_readiness_checks_fail()\n\n\nasync def custom_handler(response: ProbeAsgiResponse) -&gt; dict[str, Any] | None:\n    \"\"\"Custom handler for probes.\n\n    Returns:\n        Any: Probe response payload.\n    \"\"\"\n    await asyncio.sleep(0)\n    return response.data\n</code></pre> <pre><code>\"\"\"Example app for fast-healthchecks.\"\"\"\n\nfrom __future__ import annotations\n\nfrom contextlib import asynccontextmanager\nfrom typing import TYPE_CHECKING\n\nfrom fastapi import FastAPI, status\n\nif TYPE_CHECKING:\n    from collections.abc import AsyncIterator\n\nfrom examples.probes import (\n    custom_handler,\n    get_liveness_checks,\n    get_readiness_checks,\n    get_readiness_checks_fail,\n    get_readiness_checks_success,\n    get_startup_checks,\n)\nfrom fast_healthchecks.integrations.base import Probe, build_probe_route_options\nfrom fast_healthchecks.integrations.fastapi import HealthcheckRouter\n\nrouter_integration = HealthcheckRouter(\n    Probe(\n        name=\"liveness\",\n        checks=get_liveness_checks(),\n    ),\n    Probe(\n        name=\"readiness\",\n        checks=get_readiness_checks(),\n    ),\n    Probe(\n        name=\"startup\",\n        checks=get_startup_checks(),\n    ),\n    options=build_probe_route_options(debug=True, prefix=\"/health\"),\n)\n\n\n@asynccontextmanager\nasync def lifespan_integration(_app: FastAPI) -&gt; AsyncIterator[None]:\n    \"\"\"Lifespan for integration app: close healthcheck router on shutdown.\"\"\"\n    yield\n    await router_integration.close()\n\n\napp_integration = FastAPI(lifespan=lifespan_integration)\napp_integration.include_router(router_integration)\n\nrouter_success = HealthcheckRouter(\n    Probe(\n        name=\"liveness\",\n        checks=[],\n    ),\n    Probe(\n        name=\"readiness\",\n        checks=get_readiness_checks_success(),\n    ),\n    Probe(\n        name=\"startup\",\n        checks=[],\n    ),\n    options=build_probe_route_options(debug=True, prefix=\"/health\"),\n)\n\n\n@asynccontextmanager\nasync def lifespan_success(_app: FastAPI) -&gt; AsyncIterator[None]:\n    \"\"\"Lifespan for success app: close healthcheck router on shutdown.\"\"\"\n    yield\n    await router_success.close()\n\n\napp_success = FastAPI(lifespan=lifespan_success)\napp_success.include_router(router_success)\n\nrouter_fail = HealthcheckRouter(\n    Probe(\n        name=\"liveness\",\n        checks=[],\n    ),\n    Probe(\n        name=\"readiness\",\n        checks=get_readiness_checks_fail(),\n    ),\n    Probe(\n        name=\"startup\",\n        checks=[],\n    ),\n    options=build_probe_route_options(debug=True, prefix=\"/health\"),\n)\n\n\n@asynccontextmanager\nasync def lifespan_fail(_app: FastAPI) -&gt; AsyncIterator[None]:\n    \"\"\"Lifespan for fail app: close healthcheck router on shutdown.\"\"\"\n    yield\n    await router_fail.close()\n\n\napp_fail = FastAPI(lifespan=lifespan_fail)\napp_fail.include_router(router_fail)\n\nrouter_custom = HealthcheckRouter(\n    Probe(\n        name=\"liveness\",\n        checks=[],\n        summary=\"Check if the application is alive\",\n    ),\n    Probe(\n        name=\"readiness\",\n        checks=get_readiness_checks_success(),\n        summary=\"Check if the application is ready\",\n    ),\n    Probe(\n        name=\"startup\",\n        checks=[],\n        summary=\"Check if the application is starting up\",\n    ),\n    options=build_probe_route_options(\n        success_handler=custom_handler,\n        failure_handler=custom_handler,\n        success_status=status.HTTP_200_OK,\n        failure_status=status.HTTP_503_SERVICE_UNAVAILABLE,\n        debug=True,\n        prefix=\"/custom_health\",\n    ),\n)\n\n\n@asynccontextmanager\nasync def lifespan_custom(_app: FastAPI) -&gt; AsyncIterator[None]:\n    \"\"\"Lifespan for custom app: close healthcheck router on shutdown.\"\"\"\n    yield\n    await router_custom.close()\n\n\napp_custom = FastAPI(lifespan=lifespan_custom)\napp_custom.include_router(router_custom)\n</code></pre> <pre><code>\"\"\"Example app for fast-healthchecks.\"\"\"\n\nimport os\nfrom http import HTTPStatus\n\nfrom faststream.asgi import AsgiFastStream\nfrom faststream.kafka import KafkaBroker\n\nfrom examples.probes import (\n    LIVENESS_CHECKS,\n    READINESS_CHECKS,\n    READINESS_CHECKS_FAIL,\n    READINESS_CHECKS_SUCCESS,\n    STARTUP_CHECKS,\n    custom_handler,\n)\nfrom fast_healthchecks.integrations.base import Probe, build_probe_route_options\nfrom fast_healthchecks.integrations.faststream import health, healthcheck_shutdown\n\nbroker = KafkaBroker(\n    os.environ.get(\"KAFKA_BOOTSTRAP_SERVERS\", \"localhost:9094,localhost:9095\").split(\",\"),\n)\n\n_probes_integration = (\n    Probe(name=\"liveness\", checks=LIVENESS_CHECKS),\n    Probe(name=\"readiness\", checks=READINESS_CHECKS),\n    Probe(name=\"startup\", checks=STARTUP_CHECKS),\n)\napp_integration = AsgiFastStream(\n    broker,\n    asgi_routes=[\n        *health(\n            *_probes_integration,\n            options=build_probe_route_options(debug=False, prefix=\"/health\"),\n        ),\n    ],\n    on_shutdown=[healthcheck_shutdown(_probes_integration)],\n)\n\n_probes_success = (\n    Probe(name=\"liveness\", checks=[]),\n    Probe(name=\"readiness\", checks=READINESS_CHECKS_SUCCESS),\n    Probe(name=\"startup\", checks=[]),\n)\napp_success = AsgiFastStream(\n    broker,\n    asgi_routes=[\n        *health(\n            *_probes_success,\n            options=build_probe_route_options(debug=False, prefix=\"/health\"),\n        ),\n    ],\n    on_shutdown=[healthcheck_shutdown(_probes_success)],\n)\n\n_probes_fail = (\n    Probe(name=\"liveness\", checks=[]),\n    Probe(name=\"readiness\", checks=READINESS_CHECKS_FAIL),\n    Probe(name=\"startup\", checks=[]),\n)\napp_fail = AsgiFastStream(\n    broker,\n    asgi_routes=[\n        *health(\n            *_probes_fail,\n            options=build_probe_route_options(debug=False, prefix=\"/health\"),\n        ),\n    ],\n    on_shutdown=[healthcheck_shutdown(_probes_fail)],\n)\n\n_probes_custom = (\n    Probe(\n        name=\"liveness\",\n        checks=[],\n        summary=\"Check if the application is alive\",\n    ),\n    Probe(\n        name=\"readiness\",\n        checks=READINESS_CHECKS_SUCCESS,\n        summary=\"Check if the application is ready\",\n    ),\n    Probe(\n        name=\"startup\",\n        checks=[],\n        summary=\"Check if the application is starting up\",\n    ),\n)\napp_custom = AsgiFastStream(\n    broker,\n    asgi_routes=[\n        *health(\n            *_probes_custom,\n            options=build_probe_route_options(\n                success_handler=custom_handler,\n                failure_handler=custom_handler,\n                success_status=HTTPStatus.OK,\n                failure_status=HTTPStatus.SERVICE_UNAVAILABLE,\n                debug=True,\n                prefix=\"/custom_health\",\n            ),\n        ),\n    ],\n    on_shutdown=[healthcheck_shutdown(_probes_custom)],\n)\n</code></pre> <pre><code>\"\"\"Example app for fast-healthchecks.\"\"\"\n\nfrom litestar import Litestar\nfrom litestar.status_codes import HTTP_200_OK, HTTP_503_SERVICE_UNAVAILABLE\n\nfrom examples.probes import (\n    custom_handler,\n    get_liveness_checks,\n    get_readiness_checks,\n    get_readiness_checks_fail,\n    get_readiness_checks_success,\n    get_startup_checks,\n)\nfrom fast_healthchecks.integrations.base import Probe, build_probe_route_options\nfrom fast_healthchecks.integrations.litestar import health, healthcheck_shutdown\n\n_probes_integration = [\n    Probe(name=\"liveness\", checks=get_liveness_checks()),\n    Probe(name=\"readiness\", checks=get_readiness_checks()),\n    Probe(name=\"startup\", checks=get_startup_checks()),\n]\napp_integration = Litestar(\n    route_handlers=[\n        *health(\n            *_probes_integration,\n            options=build_probe_route_options(debug=False, prefix=\"/health\"),\n        ),\n    ],\n    on_shutdown=[healthcheck_shutdown(_probes_integration)],\n)\napp_integration.debug = True  # for integration tests (verbose errors/schema)\n\n_probes_success = [\n    Probe(name=\"liveness\", checks=[]),\n    Probe(name=\"readiness\", checks=get_readiness_checks_success()),\n    Probe(name=\"startup\", checks=[]),\n]\napp_success = Litestar(\n    route_handlers=[\n        *health(\n            *_probes_success,\n            options=build_probe_route_options(debug=False, prefix=\"/health\"),\n        ),\n    ],\n    on_shutdown=[healthcheck_shutdown(_probes_success)],\n)\napp_success.debug = True  # for unit/integration tests (verbose errors/schema)\n\n_probes_fail = [\n    Probe(name=\"liveness\", checks=[]),\n    Probe(name=\"readiness\", checks=get_readiness_checks_fail()),\n    Probe(name=\"startup\", checks=[]),\n]\napp_fail = Litestar(\n    route_handlers=[\n        *health(\n            *_probes_fail,\n            options=build_probe_route_options(debug=False, prefix=\"/health\"),\n        ),\n    ],\n    on_shutdown=[healthcheck_shutdown(_probes_fail)],\n)\n\n_probes_custom = [\n    Probe(\n        name=\"liveness\",\n        checks=[],\n        summary=\"Check if the application is alive\",\n    ),\n    Probe(\n        name=\"readiness\",\n        checks=get_readiness_checks_success(),\n        summary=\"Check if the application is ready\",\n    ),\n    Probe(\n        name=\"startup\",\n        checks=[],\n        summary=\"Check if the application is starting up\",\n    ),\n]\napp_custom = Litestar(\n    route_handlers=[\n        *health(\n            *_probes_custom,\n            options=build_probe_route_options(\n                success_handler=custom_handler,\n                failure_handler=custom_handler,\n                success_status=HTTP_200_OK,\n                failure_status=HTTP_503_SERVICE_UNAVAILABLE,\n                debug=True,\n                prefix=\"/custom_health\",\n            ),\n        ),\n    ],\n    on_shutdown=[healthcheck_shutdown(_probes_custom)],\n)\n</code></pre> <p>You can find examples for each framework here:</p> <ul> <li>FastAPI example</li> <li>FastStream example</li> <li>Litestar example</li> </ul>"},{"location":"decisions/","title":"Architecture Decision Records","text":"# Title Status Summary 001 Health check contract (DSN, name, lifecycle) Accepted Contract for DSN handling, display names (<code>_name</code>), and client lifecycle for check classes."},{"location":"decisions/001-check-contract/","title":"ADR 001: Health check contract (DSN, name, lifecycle)","text":""},{"location":"decisions/001-check-contract/#status","title":"Status","text":"<p>Accepted.</p>"},{"location":"decisions/001-check-contract/#context","title":"Context","text":"<p>Check classes need a consistent contract for DSN handling, display names, and client lifecycle.</p>"},{"location":"decisions/001-check-contract/#decision","title":"Decision","text":"<ul> <li>DSN: <code>fast_healthchecks.dsn</code> provides NewTypes (AmqpDsn, RedisDsn, etc.) for typing only. Each <code>HealthCheckDSN</code> subclass implements <code>parse_dsn()</code> and <code>validate_dsn()</code>; no shared DSN runtime logic.</li> <li>Name: All checks expose <code>_name</code> (str), used in <code>HealthCheckResult</code> and error reporting. <code>_get_check_name()</code> falls back to <code>name</code> or <code>\"Check-{index}\"</code>.</li> <li>Lifecycle: <code>ClientCachingMixin._close_client(client)</code> must return <code>Awaitable[None]</code> (not <code>None</code>). Per-call checks (RabbitMQ, PostgreSQL) do not use <code>ClientCachingMixin</code>.</li> <li>Config: Connection-based checks accept an optional <code>config: XConfig | None</code>; when <code>None</code>, config is built from <code>**kwargs</code>. Config dataclasses live in <code>fast_healthchecks.checks.configs</code>, are immutable (frozen), and provide <code>to_dict()</code> for serialization. This avoids long parameter lists and centralizes <code>_build_dict()</code> logic.</li> </ul>"}]}