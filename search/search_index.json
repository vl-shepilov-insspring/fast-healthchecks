{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"FastHealthcheck <p>Framework-agnostic health checks with integrations for the most popular ASGI frameworks: FastAPI / FastStream / Litestar to help you implement the Health Check API pattern</p>"},{"location":"#installation","title":"Installation","text":"<p>With <code>pip</code>: <pre><code>pip install fast-healthchecks\n</code></pre></p> <p>With <code>poetry</code>: <pre><code>poetry add fast-healthchecks\n</code></pre></p> <p>With <code>uv</code>: <pre><code>uv add fast-healthchecks\n</code></pre></p> <p>Backends (Redis, Kafka, Mongo, PostgreSQL, etc.) and framework integrations are optional. Install the extras you need, e.g. <code>pip install fast-healthchecks[redis]</code> or <code>pip install fast-healthchecks[redis,mongo,fastapi]</code>. See the project's <code>pyproject.toml</code> for all extra names (asyncpg, psycopg, redis, aio-pika, httpx, aiokafka, motor, fastapi, faststream, litestar, opensearch).</p>"},{"location":"#usage","title":"Usage","text":"<p>How you mount health checks depends on the framework:</p> <ul> <li>FastAPI: Use <code>HealthcheckRouter</code> with one or more <code>Probe</code> instances and pass it to <code>app.include_router()</code>.</li> <li>FastStream: Use the <code>health()</code> function from <code>fast_healthchecks.integrations.faststream</code> with your probes and options; it returns the routes to register with the app.</li> <li>Litestar: Use the <code>health()</code> function from <code>fast_healthchecks.integrations.litestar</code> with your probes and options; it returns the routes to register with the app.</li> </ul> <p>Create the health check endpoint dynamically using different conditions. Each condition is a callable, and you can even have dependencies inside it:</p> examples/probes.pyFastAPIFastStreamLitestar <pre><code>\"\"\"Probe and check factory helpers for example apps.\"\"\"\n\nimport asyncio\nimport os\nimport time\nfrom pathlib import Path\nfrom typing import Any\n\nfrom dotenv import load_dotenv\n\nfrom fast_healthchecks.checks.function import FunctionHealthCheck\nfrom fast_healthchecks.checks.kafka import KafkaHealthCheck\nfrom fast_healthchecks.checks.mongo import MongoHealthCheck\nfrom fast_healthchecks.checks.opensearch import OpenSearchHealthCheck\nfrom fast_healthchecks.checks.postgresql.asyncpg import PostgreSQLAsyncPGHealthCheck\nfrom fast_healthchecks.checks.postgresql.psycopg import PostgreSQLPsycopgHealthCheck\nfrom fast_healthchecks.checks.rabbitmq import RabbitMQHealthCheck\nfrom fast_healthchecks.checks.redis import RedisHealthCheck\nfrom fast_healthchecks.checks.types import Check\nfrom fast_healthchecks.checks.url import UrlHealthCheck\nfrom fast_healthchecks.integrations.base import ProbeAsgiResponse\n\n_ = load_dotenv(Path(__file__).parent.parent / \".env\")\n\n\ndef sync_dummy_check() -&gt; bool:\n    \"\"\"Run a synchronous dummy check that sleeps briefly and returns True.\n\n    Returns:\n        True.\n    \"\"\"\n    time.sleep(0.1)\n    return True\n\n\nasync def async_dummy_check() -&gt; bool:\n    \"\"\"Run an async dummy check that sleeps briefly and returns True.\n\n    Returns:\n        True.\n    \"\"\"\n    await asyncio.sleep(0.1)\n    return True\n\n\nasync def async_dummy_check_fail() -&gt; bool:\n    \"\"\"Run an async dummy check that raises ValueError.\n\n    Raises:\n        ValueError: Always.\n    \"\"\"\n    await asyncio.sleep(0)\n    msg = \"Failed\"\n    raise ValueError(msg) from None\n\n\ndef get_liveness_checks() -&gt; list[Check]:\n    \"\"\"Return new check instances (one set per app to avoid shared clients across event loops).\"\"\"\n    return [\n        FunctionHealthCheck(func=sync_dummy_check, name=\"Sync dummy\"),\n    ]\n\n\ndef get_readiness_checks() -&gt; list[Check]:\n    \"\"\"Return new check instances (one set per app to avoid shared clients across event loops).\"\"\"\n    return [\n        KafkaHealthCheck(\n            bootstrap_servers=os.environ[\"KAFKA_BOOTSTRAP_SERVERS\"],\n            name=\"Kafka\",\n        ),\n        MongoHealthCheck.from_dsn(os.environ[\"MONGO_DSN\"], name=\"Mongo\"),\n        OpenSearchHealthCheck(hosts=os.environ[\"OPENSEARCH_HOSTS\"].split(\",\"), name=\"OpenSearch\"),\n        PostgreSQLAsyncPGHealthCheck.from_dsn(os.environ[\"POSTGRES_DSN\"], name=\"PostgreSQL asyncpg\"),\n        PostgreSQLPsycopgHealthCheck.from_dsn(os.environ[\"POSTGRES_DSN\"], name=\"PostgreSQL psycopg\"),\n        RabbitMQHealthCheck.from_dsn(os.environ[\"RABBITMQ_DSN\"], name=\"RabbitMQ\"),\n        RedisHealthCheck.from_dsn(os.environ[\"REDIS_DSN\"], name=\"Redis\"),\n        UrlHealthCheck(url=\"https://httpbingo.org/status/200\", name=\"URL 200\"),\n    ]\n\n\ndef get_startup_checks() -&gt; list[Check]:\n    \"\"\"Return new check instances (one set per app to avoid shared clients across event loops).\"\"\"\n    return [\n        FunctionHealthCheck(func=async_dummy_check, name=\"Async dummy\"),\n    ]\n\n\ndef get_readiness_checks_success() -&gt; list[Check]:\n    \"\"\"Return new check instances for success-path tests.\"\"\"\n    return [\n        FunctionHealthCheck(func=async_dummy_check, name=\"Async dummy\"),\n    ]\n\n\ndef get_readiness_checks_fail() -&gt; list[Check]:\n    \"\"\"Return new check instances for failure-path tests.\"\"\"\n    return [\n        FunctionHealthCheck(func=async_dummy_check_fail, name=\"Async dummy fail\"),\n    ]\n\n\nLIVENESS_CHECKS: list[Check] = get_liveness_checks()\nREADINESS_CHECKS: list[Check] = get_readiness_checks()\nSTARTUP_CHECKS: list[Check] = get_startup_checks()\nREADINESS_CHECKS_SUCCESS: list[Check] = get_readiness_checks_success()\nREADINESS_CHECKS_FAIL: list[Check] = get_readiness_checks_fail()\n\n\nasync def custom_handler(response: ProbeAsgiResponse) -&gt; dict[str, Any] | None:\n    \"\"\"Custom handler for probes.\n\n    Returns:\n        Any: Probe response payload.\n    \"\"\"\n    await asyncio.sleep(0)\n    return response.data\n</code></pre> <pre><code>\"\"\"Example app for fast-healthchecks.\"\"\"\n\nfrom __future__ import annotations\n\nfrom contextlib import asynccontextmanager\nfrom typing import TYPE_CHECKING\n\nfrom fastapi import FastAPI, status\n\nif TYPE_CHECKING:\n    from collections.abc import AsyncIterator\n\nfrom examples.probes import (\n    custom_handler,\n    get_liveness_checks,\n    get_readiness_checks,\n    get_readiness_checks_fail,\n    get_readiness_checks_success,\n    get_startup_checks,\n)\nfrom fast_healthchecks.integrations.base import Probe, build_probe_route_options\nfrom fast_healthchecks.integrations.fastapi import HealthcheckRouter\n\nrouter_integration = HealthcheckRouter(\n    Probe(\n        name=\"liveness\",\n        checks=get_liveness_checks(),\n    ),\n    Probe(\n        name=\"readiness\",\n        checks=get_readiness_checks(),\n    ),\n    Probe(\n        name=\"startup\",\n        checks=get_startup_checks(),\n    ),\n    options=build_probe_route_options(debug=True, prefix=\"/health\"),\n)\n\n\n@asynccontextmanager\nasync def lifespan_integration(_app: FastAPI) -&gt; AsyncIterator[None]:\n    \"\"\"Lifespan for integration app: close healthcheck router on shutdown.\"\"\"\n    yield\n    await router_integration.close()\n\n\napp_integration = FastAPI(lifespan=lifespan_integration)\napp_integration.include_router(router_integration)\n\nrouter_success = HealthcheckRouter(\n    Probe(\n        name=\"liveness\",\n        checks=[],\n    ),\n    Probe(\n        name=\"readiness\",\n        checks=get_readiness_checks_success(),\n    ),\n    Probe(\n        name=\"startup\",\n        checks=[],\n    ),\n    options=build_probe_route_options(debug=True, prefix=\"/health\"),\n)\n\n\n@asynccontextmanager\nasync def lifespan_success(_app: FastAPI) -&gt; AsyncIterator[None]:\n    \"\"\"Lifespan for success app: close healthcheck router on shutdown.\"\"\"\n    yield\n    await router_success.close()\n\n\napp_success = FastAPI(lifespan=lifespan_success)\napp_success.include_router(router_success)\n\nrouter_fail = HealthcheckRouter(\n    Probe(\n        name=\"liveness\",\n        checks=[],\n    ),\n    Probe(\n        name=\"readiness\",\n        checks=get_readiness_checks_fail(),\n    ),\n    Probe(\n        name=\"startup\",\n        checks=[],\n    ),\n    options=build_probe_route_options(debug=True, prefix=\"/health\"),\n)\n\n\n@asynccontextmanager\nasync def lifespan_fail(_app: FastAPI) -&gt; AsyncIterator[None]:\n    \"\"\"Lifespan for fail app: close healthcheck router on shutdown.\"\"\"\n    yield\n    await router_fail.close()\n\n\napp_fail = FastAPI(lifespan=lifespan_fail)\napp_fail.include_router(router_fail)\n\nrouter_custom = HealthcheckRouter(\n    Probe(\n        name=\"liveness\",\n        checks=[],\n        summary=\"Check if the application is alive\",\n    ),\n    Probe(\n        name=\"readiness\",\n        checks=get_readiness_checks_success(),\n        summary=\"Check if the application is ready\",\n    ),\n    Probe(\n        name=\"startup\",\n        checks=[],\n        summary=\"Check if the application is starting up\",\n    ),\n    options=build_probe_route_options(\n        success_handler=custom_handler,\n        failure_handler=custom_handler,\n        success_status=status.HTTP_200_OK,\n        failure_status=status.HTTP_503_SERVICE_UNAVAILABLE,\n        debug=True,\n        prefix=\"/custom_health\",\n    ),\n)\n\n\n@asynccontextmanager\nasync def lifespan_custom(_app: FastAPI) -&gt; AsyncIterator[None]:\n    \"\"\"Lifespan for custom app: close healthcheck router on shutdown.\"\"\"\n    yield\n    await router_custom.close()\n\n\napp_custom = FastAPI(lifespan=lifespan_custom)\napp_custom.include_router(router_custom)\n</code></pre> <pre><code>\"\"\"Example app for fast-healthchecks.\"\"\"\n\nimport os\nfrom http import HTTPStatus\n\nfrom faststream.asgi import AsgiFastStream\nfrom faststream.kafka import KafkaBroker\n\nfrom examples.probes import (\n    LIVENESS_CHECKS,\n    READINESS_CHECKS,\n    READINESS_CHECKS_FAIL,\n    READINESS_CHECKS_SUCCESS,\n    STARTUP_CHECKS,\n    custom_handler,\n)\nfrom fast_healthchecks.integrations.base import Probe, build_probe_route_options\nfrom fast_healthchecks.integrations.faststream import health, healthcheck_shutdown\n\nbroker = KafkaBroker(\n    os.environ.get(\"KAFKA_BOOTSTRAP_SERVERS\", \"localhost:9094,localhost:9095\").split(\",\"),\n)\n\n_probes_integration = (\n    Probe(name=\"liveness\", checks=LIVENESS_CHECKS),\n    Probe(name=\"readiness\", checks=READINESS_CHECKS),\n    Probe(name=\"startup\", checks=STARTUP_CHECKS),\n)\napp_integration = AsgiFastStream(\n    broker,\n    asgi_routes=[\n        *health(\n            *_probes_integration,\n            options=build_probe_route_options(debug=False, prefix=\"/health\"),\n        ),\n    ],\n    on_shutdown=[healthcheck_shutdown(_probes_integration)],\n)\n\n_probes_success = (\n    Probe(name=\"liveness\", checks=[]),\n    Probe(name=\"readiness\", checks=READINESS_CHECKS_SUCCESS),\n    Probe(name=\"startup\", checks=[]),\n)\napp_success = AsgiFastStream(\n    broker,\n    asgi_routes=[\n        *health(\n            *_probes_success,\n            options=build_probe_route_options(debug=False, prefix=\"/health\"),\n        ),\n    ],\n    on_shutdown=[healthcheck_shutdown(_probes_success)],\n)\n\n_probes_fail = (\n    Probe(name=\"liveness\", checks=[]),\n    Probe(name=\"readiness\", checks=READINESS_CHECKS_FAIL),\n    Probe(name=\"startup\", checks=[]),\n)\napp_fail = AsgiFastStream(\n    broker,\n    asgi_routes=[\n        *health(\n            *_probes_fail,\n            options=build_probe_route_options(debug=False, prefix=\"/health\"),\n        ),\n    ],\n    on_shutdown=[healthcheck_shutdown(_probes_fail)],\n)\n\n_probes_custom = (\n    Probe(\n        name=\"liveness\",\n        checks=[],\n        summary=\"Check if the application is alive\",\n    ),\n    Probe(\n        name=\"readiness\",\n        checks=READINESS_CHECKS_SUCCESS,\n        summary=\"Check if the application is ready\",\n    ),\n    Probe(\n        name=\"startup\",\n        checks=[],\n        summary=\"Check if the application is starting up\",\n    ),\n)\napp_custom = AsgiFastStream(\n    broker,\n    asgi_routes=[\n        *health(\n            *_probes_custom,\n            options=build_probe_route_options(\n                success_handler=custom_handler,\n                failure_handler=custom_handler,\n                success_status=HTTPStatus.OK,\n                failure_status=HTTPStatus.SERVICE_UNAVAILABLE,\n                debug=True,\n                prefix=\"/custom_health\",\n            ),\n        ),\n    ],\n    on_shutdown=[healthcheck_shutdown(_probes_custom)],\n)\n</code></pre> <pre><code>\"\"\"Example app for fast-healthchecks.\"\"\"\n\nfrom litestar import Litestar\nfrom litestar.status_codes import HTTP_200_OK, HTTP_503_SERVICE_UNAVAILABLE\n\nfrom examples.probes import (\n    custom_handler,\n    get_liveness_checks,\n    get_readiness_checks,\n    get_readiness_checks_fail,\n    get_readiness_checks_success,\n    get_startup_checks,\n)\nfrom fast_healthchecks.integrations.base import Probe, build_probe_route_options\nfrom fast_healthchecks.integrations.litestar import health, healthcheck_shutdown\n\n_probes_integration = [\n    Probe(name=\"liveness\", checks=get_liveness_checks()),\n    Probe(name=\"readiness\", checks=get_readiness_checks()),\n    Probe(name=\"startup\", checks=get_startup_checks()),\n]\napp_integration = Litestar(\n    route_handlers=[\n        *health(\n            *_probes_integration,\n            options=build_probe_route_options(debug=False, prefix=\"/health\"),\n        ),\n    ],\n    on_shutdown=[healthcheck_shutdown(_probes_integration)],\n)\napp_integration.debug = True  # for integration tests (verbose errors/schema)\n\n_probes_success = [\n    Probe(name=\"liveness\", checks=[]),\n    Probe(name=\"readiness\", checks=get_readiness_checks_success()),\n    Probe(name=\"startup\", checks=[]),\n]\napp_success = Litestar(\n    route_handlers=[\n        *health(\n            *_probes_success,\n            options=build_probe_route_options(debug=False, prefix=\"/health\"),\n        ),\n    ],\n    on_shutdown=[healthcheck_shutdown(_probes_success)],\n)\napp_success.debug = True  # for unit/integration tests (verbose errors/schema)\n\n_probes_fail = [\n    Probe(name=\"liveness\", checks=[]),\n    Probe(name=\"readiness\", checks=get_readiness_checks_fail()),\n    Probe(name=\"startup\", checks=[]),\n]\napp_fail = Litestar(\n    route_handlers=[\n        *health(\n            *_probes_fail,\n            options=build_probe_route_options(debug=False, prefix=\"/health\"),\n        ),\n    ],\n    on_shutdown=[healthcheck_shutdown(_probes_fail)],\n)\n\n_probes_custom = [\n    Probe(\n        name=\"liveness\",\n        checks=[],\n        summary=\"Check if the application is alive\",\n    ),\n    Probe(\n        name=\"readiness\",\n        checks=get_readiness_checks_success(),\n        summary=\"Check if the application is ready\",\n    ),\n    Probe(\n        name=\"startup\",\n        checks=[],\n        summary=\"Check if the application is starting up\",\n    ),\n]\napp_custom = Litestar(\n    route_handlers=[\n        *health(\n            *_probes_custom,\n            options=build_probe_route_options(\n                success_handler=custom_handler,\n                failure_handler=custom_handler,\n                success_status=HTTP_200_OK,\n                failure_status=HTTP_503_SERVICE_UNAVAILABLE,\n                debug=True,\n                prefix=\"/custom_health\",\n            ),\n        ),\n    ],\n    on_shutdown=[healthcheck_shutdown(_probes_custom)],\n)\n</code></pre> <p>You can find examples for each framework here:</p> <ul> <li>FastAPI example</li> <li>FastStream example</li> <li>Litestar example</li> </ul>"},{"location":"#lifecycle-and-shutdown","title":"Lifecycle and shutdown","text":"<p>Checks that cache a client (Redis, Mongo, Kafka, OpenSearch, URL) keep one connection per instance. To close these resources on app shutdown:</p> <ul> <li>FastAPI: Store the router and call <code>await router.close()</code> in your lifespan context manager (after <code>yield</code>), or use <code>healthcheck_shutdown(probes)</code> and call the returned callback in lifespan.</li> <li>FastStream: Pass the callback from <code>healthcheck_shutdown(probes)</code> into your app's <code>on_shutdown</code> list, e.g. <code>AsgiFastStream(..., on_shutdown=[healthcheck_shutdown(probes)])</code>.</li> <li>Litestar: Pass the callback from <code>healthcheck_shutdown(probes)</code> into the app's <code>on_shutdown</code> list, e.g. <code>Litestar(..., on_shutdown=[healthcheck_shutdown(probes)])</code>.</li> </ul> <p>Import <code>healthcheck_shutdown</code> from <code>fast_healthchecks.integrations.fastapi</code>, <code>fast_healthchecks.integrations.faststream</code>, or <code>fast_healthchecks.integrations.litestar</code>.</p>"},{"location":"#probe-options","title":"Probe options","text":"Parameter Description <code>name</code> Probe identifier (e.g. <code>\"liveness\"</code>, <code>\"readiness\"</code>, <code>\"startup\"</code>). <code>checks</code> List of health checks to run. <code>summary</code> Custom description for the probe (used in responses). If omitted, a default is generated from <code>name</code>. <code>allow_partial_failure</code> If <code>True</code>, probe is healthy when at least one check passes. Default: <code>False</code>. <p>To customize HTTP responses, pass <code>options=build_probe_route_options(...)</code> to <code>HealthcheckRouter</code> or <code>health()</code>. Build options with:</p> Parameter Description <code>success_handler</code> Handler for healthy responses. Receives <code>ProbeAsgiResponse</code>, returns response body (or <code>None</code> for empty). <code>failure_handler</code> Handler for unhealthy responses. Same signature as <code>success_handler</code>. <code>success_status</code> HTTP status for healthy (default: <code>204</code> No Content). <code>failure_status</code> HTTP status for unhealthy (default: <code>503</code>). <code>debug</code> Include check details in responses (default: <code>False</code>). <code>prefix</code> URL prefix for probe routes (default: <code>\"/health\"</code>). <code>timeout</code> Max seconds for all checks; on exceed returns failure (default: <code>None</code> = no limit). <p>Example: <code>HealthcheckRouter(Probe(...), options=build_probe_route_options(debug=True, prefix=\"/health\"))</code>.</p>"},{"location":"#running-probes-without-asgi","title":"Running probes without ASGI","text":"<p>For CLI scripts, cron jobs, or tests, use <code>run_probe</code> instead of mounting ASGI routes:</p> <pre><code>import asyncio\nfrom fast_healthchecks.integrations.base import Probe, run_probe\nfrom fast_healthchecks.checks.function import FunctionHealthCheck\n\nasync def main():\n    probe = Probe(\n        name=\"readiness\",\n        checks=[FunctionHealthCheck(func=lambda: True, name=\"Ping\")],\n    )\n    report = await run_probe(probe)\n    print(report.healthy, report.results)\n\nasyncio.run(main())\n</code></pre> <p>Optional parameters: <code>timeout</code> (seconds), <code>on_check_start</code>, <code>on_check_end</code> (callbacks).</p>"},{"location":"#configuration-objects","title":"Configuration objects","text":"<p>Connection-based checks (Redis, Kafka, Mongo, RabbitMQ, OpenSearch, URL, PostgreSQL, Function) accept either keyword arguments or an optional <code>config</code> argument. When <code>config</code> is <code>None</code>, the check builds its config from <code>**kwargs</code>. Config types (e.g. <code>RedisConfig</code>, <code>UrlConfig</code>) are defined in <code>fast_healthchecks.checks._configs</code> and are used for typing and for <code>to_dict()</code> serialization. This keeps constructor signatures short and avoids long parameter lists.</p>"},{"location":"#url-check-and-ssrf-protection","title":"URL check and SSRF protection","text":"<p><code>UrlHealthCheck</code> supports <code>block_private_hosts</code>: when <code>True</code>, the check resolves the URL host before making the request and rejects if it is or resolves to loopback or private IPs. This mitigates SSRF and DNS rebinding when healthcheck URLs come from configuration. Do not use user-controlled input as the URL.</p>"},{"location":"#dsn-formats","title":"DSN formats","text":"<p>Checks that support <code>from_dsn()</code> accept these URL schemes:</p> Check Scheme Example Redis <code>redis://</code> <code>redis://localhost:6379/0</code>, <code>redis://user:pass@host:6379</code> MongoDB <code>mongodb://</code> <code>mongodb://localhost:27017</code>, <code>mongodb://user:pass@host/db?authSource=admin</code> PostgreSQL <code>postgresql://</code> <code>postgresql://user:pass@localhost:5432/dbname</code> RabbitMQ <code>amqp://</code> <code>amqp://user:pass@localhost:5672/%2F</code> Kafka <code>kafka://</code> <code>kafka://broker1:9092,broker2:9092</code>, <code>kafka://user:pass@host:9092</code> OpenSearch <code>http://</code> or <code>https://</code> <code>https://admin:pass@localhost:9200</code>"},{"location":"#postgresql-tls-certificate-rotation","title":"PostgreSQL TLS certificate rotation","text":"<p>PostgreSQL checks (<code>verify-full</code>, <code>verify-ca</code>) cache the SSL context. After rotating certificates, restart the process or call <code>fast_healthchecks.checks.postgresql.base.create_ssl_context.cache_clear()</code> to avoid using stale contexts.</p>"},{"location":"api/","title":"API Reference","text":"<p>Config dataclasses for checks (e.g. <code>RedisConfig</code>, <code>UrlConfig</code>) are in <code>fast_healthchecks.checks._configs</code>; they are used when passing <code>config=...</code> to a check constructor.</p> <p>Models for healthchecks.</p> <p>DSN NewTypes for type hints only.</p> <p>These types annotate DSN strings (e.g. AmqpDsn, RedisDsn) but are not used at runtime by check classes. Each HealthCheckDSN subclass implements its own parse_dsn() and validate_dsn(); dsn.py provides no parsing or validation logic. Use these types to annotate configuration or function parameters.</p>"},{"location":"api/#fast_healthchecks.models.HealthCheckReport","title":"<code>HealthCheckReport</code>  <code>dataclass</code>","text":"<p>Report of healthchecks.</p> <p>Attributes:</p> Name Type Description <code>results</code> <code>list[HealthCheckResult]</code> <p>List of healthcheck results.</p> <code>allow_partial_failure</code> <code>bool</code> <p>If True, report is healthy when at least one check passes.</p> Source code in <code>fast_healthchecks/models.py</code> <pre><code>@dataclass(frozen=True)\nclass HealthCheckReport:\n    \"\"\"Report of healthchecks.\n\n    Attributes:\n        results: List of healthcheck results.\n        allow_partial_failure: If True, report is healthy when at least one check passes.\n    \"\"\"\n\n    results: list[HealthCheckResult]\n    allow_partial_failure: bool = False\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return a string representation of the report.\"\"\"\n        return \"\\n\".join(str(result) for result in self.results)\n\n    @property\n    def healthy(self) -&gt; bool:\n        \"\"\"Return whether all healthchecks passed (or allowed partial failure).\"\"\"\n        if self.allow_partial_failure:\n            return any(result.healthy for result in self.results)\n        return all(result.healthy for result in self.results)\n</code></pre>"},{"location":"api/#fast_healthchecks.models.HealthCheckReport.healthy","title":"<code>healthy</code>  <code>property</code>","text":"<p>Return whether all healthchecks passed (or allowed partial failure).</p>"},{"location":"api/#fast_healthchecks.models.HealthCheckReport.__str__","title":"<code>__str__()</code>","text":"<p>Return a string representation of the report.</p> Source code in <code>fast_healthchecks/models.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of the report.\"\"\"\n    return \"\\n\".join(str(result) for result in self.results)\n</code></pre>"},{"location":"api/#fast_healthchecks.models.HealthCheckResult","title":"<code>HealthCheckResult</code>  <code>dataclass</code>","text":"<p>Result of a healthcheck.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of the healthcheck.</p> <code>healthy</code> <code>bool</code> <p>Whether the healthcheck passed.</p> <code>error_details</code> <code>str | None</code> <p>Details of the error if the healthcheck failed.</p> Source code in <code>fast_healthchecks/models.py</code> <pre><code>@dataclass(frozen=True)\nclass HealthCheckResult:\n    \"\"\"Result of a healthcheck.\n\n    Attributes:\n        name: Name of the healthcheck.\n        healthy: Whether the healthcheck passed.\n        error_details: Details of the error if the healthcheck failed.\n    \"\"\"\n\n    name: str\n    healthy: bool\n    error_details: str | None = None\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return a string representation of the result.\"\"\"\n        return f\"{self.name}: {'healthy' if self.healthy else 'unhealthy'}\"\n</code></pre>"},{"location":"api/#fast_healthchecks.models.HealthCheckResult.__str__","title":"<code>__str__()</code>","text":"<p>Return a string representation of the result.</p> Source code in <code>fast_healthchecks/models.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of the result.\"\"\"\n    return f\"{self.name}: {'healthy' if self.healthy else 'unhealthy'}\"\n</code></pre>"},{"location":"api/#checks","title":"Checks","text":"<p>Type aliases for health checks.</p> <p>Health check that runs a user-provided callable (sync or async).</p> <p>FunctionHealthCheck runs the callable each time the check is executed; sync functions are run in a thread pool via run_in_executor.</p> <p>This module provides a health check class for Redis.</p> <p>Classes:</p> Name Description <code>RedisHealthCheck</code> <p>A class to perform health checks on Redis.</p> Usage <p>The RedisHealthCheck class can be used to perform health checks on Redis by calling it.</p> Example <p>health_check = RedisHealthCheck(     host=\"localhost\",     port=6379, ) result = await health_check() print(result.healthy)</p> <p>This module provides a health check class for Kafka.</p> <p>Classes:</p> Name Description <code>KafkaHealthCheck</code> <p>A class to perform health checks on Kafka.</p> Usage <p>The KafkaHealthCheck class can be used to perform health checks on Kafka by calling it.</p> Example <p>health_check = KafkaHealthCheck(     bootstrap_servers=\"localhost:9092\",     security_protocol=\"PLAINTEXT\", ) result = await health_check() print(result.healthy)</p> <p>This module provides a health check class for MongoDB.</p> <p>Classes:</p> Name Description <code>MongoHealthCheck</code> <p>A class to perform health checks on MongoDB.</p> Usage <p>The MongoHealthCheck class can be used to perform health checks on MongoDB by calling it.</p> Example <p>health_check = MongoHealthCheck(     hosts=[\"host1:27017\", \"host2:27017\"],     # or hosts=\"localhost\",     port=27017,     user=\"myuser\",     password=\"mypassword\",     database=\"mydatabase\" ) result = await health_check() print(result.healthy)</p> <p>This module provides a health check class for OpenSearch.</p> <p>Classes:</p> Name Description <code>OpenSearchHealthCheck</code> <p>A class to perform health checks on OpenSearch.</p> Usage <p>The OpenSearchHealthCheck class can be used to perform health checks on OpenSearch by calling it.</p> Example <p>health_check = OpenSearchHealthCheck(     hosts=[\"localhost:9200\"],     http_auth=(\"username\", \"password\"),     use_ssl=True,     verify_certs=True,     ssl_show_warn=False,     ca_certs=\"/path/to/ca.pem\", ) result = await health_check() print(result.healthy)</p> <p>This module provides a health check class for RabbitMQ.</p> <p>Classes:</p> Name Description <code>RabbitMQHealthCheck</code> <p>A class to perform health checks on RabbitMQ.</p> Usage <p>The RabbitMQHealthCheck class can be used to perform health checks on RabbitMQ by calling it.</p> Example <p>health_check = RabbitMQHealthCheck(     host=\"localhost\",     port=5672,     username=\"guest\",     password=\"guest\", ) result = await health_check() print(result.healthy)</p> <p>Health check that performs an HTTP GET to a URL.</p> <p>UrlHealthCheck caches an httpx AsyncClient and supports optional basic auth, SSL verification, and SSRF protection (block_private_hosts).</p> <p>This module provides a health check class for PostgreSQL using asyncpg.</p> <p>Classes:</p> Name Description <code>PostgreSQLAsyncPGHealthCheck</code> <p>A class to perform health checks on a PostgreSQL database using asyncpg.</p> Usage <p>The PostgreSQLAsyncPGHealthCheck class can be used to perform health checks on a PostgreSQL database by connecting to the database and executing a simple query.</p> Example <p>health_check = PostgreSQLAsyncPGHealthCheck(     host=\"localhost\",     port=5432,     user=\"username\",     password=\"password\",     database=\"dbname\" )</p> <p>This module provides a health check for PostgreSQL using psycopg.</p> <p>Classes:</p> Name Description <code>PostgreSQLPsycopgHealthCheck</code> <p>A class for health checking PostgreSQL using psycopg.</p> Usage <p>The PostgreSQLPsycopgHealthCheck class can be used to perform health checks on a PostgreSQL database by connecting to the database and executing a simple query.</p> Example <p>health_check = PostgreSQLPsycopgHealthCheck(     host=\"localhost\",     port=5432,     user=\"username\",     password=\"password\",     database=\"dbname\" )</p>"},{"location":"api/#fast_healthchecks.checks.types.HealthCheck","title":"<code>HealthCheck</code>","text":"<p>               Bases: <code>Protocol[T_co]</code></p> <p>Base class for health checks.</p> Source code in <code>fast_healthchecks/checks/_base.py</code> <pre><code>class HealthCheck(Protocol[T_co]):\n    \"\"\"Base class for health checks.\"\"\"\n\n    async def __call__(self) -&gt; T_co: ...\n</code></pre>"},{"location":"api/#fast_healthchecks.checks.types.HealthCheckDSN","title":"<code>HealthCheckDSN</code>","text":"<p>               Bases: <code>ConfigDictMixin</code>, <code>HealthCheck[T_co]</code>, <code>Generic[T_co]</code></p> <p>Base class for health checks that can be created from a DSN.</p> <p>Contract: subclasses must define _allowed_schemes(), _default_name(), parse_dsn(), and _from_parsed_dsn(). The check stores its display name in _name (used in HealthCheckResult and error reporting). DSN validation uses validate_dsn(); fast_healthchecks.dsn NewTypes are typing-only, not runtime.</p> Source code in <code>fast_healthchecks/checks/_base.py</code> <pre><code>class HealthCheckDSN(ConfigDictMixin, HealthCheck[T_co], Generic[T_co]):\n    \"\"\"Base class for health checks that can be created from a DSN.\n\n    Contract: subclasses must define _allowed_schemes(), _default_name(),\n    parse_dsn(), and _from_parsed_dsn(). The check stores its display name in\n    _name (used in HealthCheckResult and error reporting). DSN validation uses\n    validate_dsn(); fast_healthchecks.dsn NewTypes are typing-only, not runtime.\n    \"\"\"\n\n    @classmethod\n    @abstractmethod\n    def _allowed_schemes(cls) -&gt; tuple[str, ...]:\n        \"\"\"Return DSN schemes allowed for this check (e.g. ('redis', 'rediss')).\"\"\"\n        raise NotImplementedError  # pragma: no cover\n\n    @classmethod\n    @abstractmethod\n    def _default_name(cls) -&gt; str:\n        \"\"\"Return the default check name for from_dsn (e.g. 'Redis').\"\"\"\n        raise NotImplementedError  # pragma: no cover\n\n    @classmethod\n    @abstractmethod\n    def parse_dsn(cls, dsn: str) -&gt; object:\n        \"\"\"Parse the DSN string. Subclasses must implement.\"\"\"\n        raise NotImplementedError  # pragma: no cover\n\n    @classmethod\n    @abstractmethod\n    def _from_parsed_dsn(\n        cls,\n        parsed: Any,  # noqa: ANN401\n        *,\n        name: str = \"Service\",\n        timeout: float = DEFAULT_HC_TIMEOUT,\n        **kwargs: Any,  # noqa: ANN401\n    ) -&gt; HealthCheckDSN[T_co]:\n        \"\"\"Create a check instance from parsed DSN.\"\"\"\n        raise NotImplementedError  # pragma: no cover\n\n    @classmethod\n    def from_dsn(\n        cls,\n        dsn: str,\n        *,\n        name: str | None = None,\n        timeout: float = DEFAULT_HC_TIMEOUT,\n        **kwargs: Any,  # noqa: ANN401\n    ) -&gt; HealthCheckDSN[T_co]:\n        \"\"\"Create a check instance from a DSN string.\n\n        Returns:\n            HealthCheckDSN: Configured check instance.\n        \"\"\"\n        if name is None:\n            name = cls._default_name()\n        dsn = cls.validate_dsn(dsn, allowed_schemes=cls._allowed_schemes())\n        parsed = cls.parse_dsn(dsn)\n        return cls._from_parsed_dsn(parsed, name=name, timeout=timeout, **kwargs)\n\n    @classmethod\n    def validate_dsn(cls, dsn: str, *, allowed_schemes: tuple[str, ...]) -&gt; str:\n        \"\"\"Validate the DSN has an allowed scheme.\n\n        Allows compound schemes (e.g. postgresql+asyncpg) when the base\n        part before '+' is in allowed_schemes. Scheme comparison is case-insensitive.\n\n        Returns:\n            str: The DSN string (stripped of leading/trailing whitespace).\n\n        Raises:\n            TypeError: If dsn is not a string.\n            ValueError: If DSN is empty or scheme is not in allowed_schemes.\n        \"\"\"\n        if not isinstance(dsn, str):\n            msg = f\"DSN must be str, got {type(dsn).__name__!r}\"\n            raise TypeError(msg) from None\n\n        dsn = dsn.strip()\n        if not dsn:\n            msg = \"DSN cannot be empty\"\n            raise ValueError(msg) from None\n\n        if not allowed_schemes:\n            msg = \"allowed_schemes cannot be empty\"\n            raise ValueError(msg) from None\n\n        parsed = urlsplit(dsn)\n        scheme = (parsed.scheme or \"\").lower()\n        base_scheme = scheme.split(\"+\", 1)[0] if \"+\" in scheme else scheme\n\n        allowed_set = frozenset(s.lower() for s in allowed_schemes)\n        if scheme not in allowed_set and base_scheme not in allowed_set:\n            schemes_str = \", \".join(sorted(allowed_set))\n            msg = f\"DSN scheme must be one of {schemes_str} (or compound e.g. postgresql+driver), got {scheme!r}\"\n            raise ValueError(msg) from None\n\n        return dsn\n</code></pre>"},{"location":"api/#fast_healthchecks.checks.types.HealthCheckDSN.from_dsn","title":"<code>from_dsn(dsn, *, name=None, timeout=DEFAULT_HC_TIMEOUT, **kwargs)</code>  <code>classmethod</code>","text":"<p>Create a check instance from a DSN string.</p> <p>Returns:</p> Name Type Description <code>HealthCheckDSN</code> <code>HealthCheckDSN[T_co]</code> <p>Configured check instance.</p> Source code in <code>fast_healthchecks/checks/_base.py</code> <pre><code>@classmethod\ndef from_dsn(\n    cls,\n    dsn: str,\n    *,\n    name: str | None = None,\n    timeout: float = DEFAULT_HC_TIMEOUT,\n    **kwargs: Any,  # noqa: ANN401\n) -&gt; HealthCheckDSN[T_co]:\n    \"\"\"Create a check instance from a DSN string.\n\n    Returns:\n        HealthCheckDSN: Configured check instance.\n    \"\"\"\n    if name is None:\n        name = cls._default_name()\n    dsn = cls.validate_dsn(dsn, allowed_schemes=cls._allowed_schemes())\n    parsed = cls.parse_dsn(dsn)\n    return cls._from_parsed_dsn(parsed, name=name, timeout=timeout, **kwargs)\n</code></pre>"},{"location":"api/#fast_healthchecks.checks.types.HealthCheckDSN.parse_dsn","title":"<code>parse_dsn(dsn)</code>  <code>abstractmethod</code> <code>classmethod</code>","text":"<p>Parse the DSN string. Subclasses must implement.</p> Source code in <code>fast_healthchecks/checks/_base.py</code> <pre><code>@classmethod\n@abstractmethod\ndef parse_dsn(cls, dsn: str) -&gt; object:\n    \"\"\"Parse the DSN string. Subclasses must implement.\"\"\"\n    raise NotImplementedError  # pragma: no cover\n</code></pre>"},{"location":"api/#fast_healthchecks.checks.types.HealthCheckDSN.validate_dsn","title":"<code>validate_dsn(dsn, *, allowed_schemes)</code>  <code>classmethod</code>","text":"<p>Validate the DSN has an allowed scheme.</p> <p>Allows compound schemes (e.g. postgresql+asyncpg) when the base part before '+' is in allowed_schemes. Scheme comparison is case-insensitive.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The DSN string (stripped of leading/trailing whitespace).</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If dsn is not a string.</p> <code>ValueError</code> <p>If DSN is empty or scheme is not in allowed_schemes.</p> Source code in <code>fast_healthchecks/checks/_base.py</code> <pre><code>@classmethod\ndef validate_dsn(cls, dsn: str, *, allowed_schemes: tuple[str, ...]) -&gt; str:\n    \"\"\"Validate the DSN has an allowed scheme.\n\n    Allows compound schemes (e.g. postgresql+asyncpg) when the base\n    part before '+' is in allowed_schemes. Scheme comparison is case-insensitive.\n\n    Returns:\n        str: The DSN string (stripped of leading/trailing whitespace).\n\n    Raises:\n        TypeError: If dsn is not a string.\n        ValueError: If DSN is empty or scheme is not in allowed_schemes.\n    \"\"\"\n    if not isinstance(dsn, str):\n        msg = f\"DSN must be str, got {type(dsn).__name__!r}\"\n        raise TypeError(msg) from None\n\n    dsn = dsn.strip()\n    if not dsn:\n        msg = \"DSN cannot be empty\"\n        raise ValueError(msg) from None\n\n    if not allowed_schemes:\n        msg = \"allowed_schemes cannot be empty\"\n        raise ValueError(msg) from None\n\n    parsed = urlsplit(dsn)\n    scheme = (parsed.scheme or \"\").lower()\n    base_scheme = scheme.split(\"+\", 1)[0] if \"+\" in scheme else scheme\n\n    allowed_set = frozenset(s.lower() for s in allowed_schemes)\n    if scheme not in allowed_set and base_scheme not in allowed_set:\n        schemes_str = \", \".join(sorted(allowed_set))\n        msg = f\"DSN scheme must be one of {schemes_str} (or compound e.g. postgresql+driver), got {scheme!r}\"\n        raise ValueError(msg) from None\n\n    return dsn\n</code></pre>"},{"location":"api/#fast_healthchecks.checks.function.FunctionHealthCheck","title":"<code>FunctionHealthCheck</code>","text":"<p>               Bases: <code>ConfigDictMixin</code>, <code>HealthCheck[HealthCheckResult]</code></p> <p>Health check that runs a callable (sync or async) each time it is executed.</p> <p>Synchronous functions are run via <code>loop.run_in_executor(executor, ...)</code>. The default executor is <code>None</code> (shared thread pool). Long-running blocking sync checks can exhaust the pool; pass a dedicated :class:<code>Executor</code> if needed.</p> Source code in <code>fast_healthchecks/checks/function.py</code> <pre><code>@final\nclass FunctionHealthCheck(ConfigDictMixin, HealthCheck[HealthCheckResult]):\n    \"\"\"Health check that runs a callable (sync or async) each time it is executed.\n\n    Synchronous functions are run via ``loop.run_in_executor(executor, ...)``.\n    The default executor is ``None`` (shared thread pool). Long-running blocking\n    sync checks can exhaust the pool; pass a dedicated :class:`Executor` if needed.\n    \"\"\"\n\n    __slots__ = (\"_config\", \"_executor\", \"_func\", \"_name\")\n\n    _config: FunctionConfig\n    _func: Callable[..., Any]\n    _executor: Executor | None\n    _name: str\n\n    def __init__(\n        self,\n        *,\n        config: FunctionConfig | None = None,\n        func: Callable[..., Any] | None = None,\n        name: str = \"Function\",\n        executor: Executor | None = None,\n        **kwargs: Any,  # noqa: ANN401\n    ) -&gt; None:\n        \"\"\"Initialize the FunctionHealthCheck.\n\n        Args:\n            config: Config (args, kwargs, timeout). If None, built from kwargs.\n            func: The function to perform the health check on (required if config is None).\n            name: The name of the health check.\n            executor: Executor for sync functions. Defaults to None (thread pool).\n            **kwargs: Passed to FunctionConfig when config is None (args, kwargs, timeout).\n\n        Raises:\n            TypeError: When func is not provided.\n        \"\"\"\n        if config is None:\n            kwargs_copy = dict(kwargs)\n            func = kwargs_copy.pop(\"func\", func)\n            executor = kwargs_copy.pop(\"executor\", executor)\n            if func is None:\n                msg = \"func is required when config is not provided\"\n                raise TypeError(msg)\n            config = FunctionConfig(**kwargs_copy)\n        elif func is None:\n            msg = \"func is required\"\n            raise TypeError(msg)\n        self._config = config\n        self._func = func\n        self._executor = executor\n        self._name = name\n\n    @healthcheck_safe(invalidate_on_error=False)\n    async def __call__(self) -&gt; HealthCheckResult:\n        \"\"\"Perform the health check on the function.\n\n        Sync functions run in the given executor (default: shared thread pool).\n\n        Returns:\n            HealthCheckResult: The result of the health check.\n        \"\"\"\n        c = self._config\n        args = c.args or ()\n        kwargs = dict(c.kwargs) if c.kwargs else {}\n        task: asyncio.Future[Any]\n        if inspect.iscoroutinefunction(self._func):\n            task = self._func(*args, **kwargs)\n        else:\n            loop = asyncio.get_running_loop()\n            task = loop.run_in_executor(\n                self._executor,\n                functools.partial(self._func, *args, **kwargs),\n            )\n        result = await asyncio.wait_for(task, timeout=c.timeout)\n        healthy = bool(result) if isinstance(result, bool) else True\n        return HealthCheckResult(name=self._name, healthy=healthy)\n</code></pre>"},{"location":"api/#fast_healthchecks.checks.function.FunctionHealthCheck.__call__","title":"<code>__call__()</code>  <code>async</code>","text":"<p>Perform the health check on the function.</p> <p>Sync functions run in the given executor (default: shared thread pool).</p> <p>Returns:</p> Name Type Description <code>HealthCheckResult</code> <code>HealthCheckResult</code> <p>The result of the health check.</p> Source code in <code>fast_healthchecks/checks/function.py</code> <pre><code>@healthcheck_safe(invalidate_on_error=False)\nasync def __call__(self) -&gt; HealthCheckResult:\n    \"\"\"Perform the health check on the function.\n\n    Sync functions run in the given executor (default: shared thread pool).\n\n    Returns:\n        HealthCheckResult: The result of the health check.\n    \"\"\"\n    c = self._config\n    args = c.args or ()\n    kwargs = dict(c.kwargs) if c.kwargs else {}\n    task: asyncio.Future[Any]\n    if inspect.iscoroutinefunction(self._func):\n        task = self._func(*args, **kwargs)\n    else:\n        loop = asyncio.get_running_loop()\n        task = loop.run_in_executor(\n            self._executor,\n            functools.partial(self._func, *args, **kwargs),\n        )\n    result = await asyncio.wait_for(task, timeout=c.timeout)\n    healthy = bool(result) if isinstance(result, bool) else True\n    return HealthCheckResult(name=self._name, healthy=healthy)\n</code></pre>"},{"location":"api/#fast_healthchecks.checks.function.FunctionHealthCheck.__init__","title":"<code>__init__(*, config=None, func=None, name='Function', executor=None, **kwargs)</code>","text":"<p>Initialize the FunctionHealthCheck.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>FunctionConfig | None</code> <p>Config (args, kwargs, timeout). If None, built from kwargs.</p> <code>None</code> <code>func</code> <code>Callable[..., Any] | None</code> <p>The function to perform the health check on (required if config is None).</p> <code>None</code> <code>name</code> <code>str</code> <p>The name of the health check.</p> <code>'Function'</code> <code>executor</code> <code>Executor | None</code> <p>Executor for sync functions. Defaults to None (thread pool).</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Passed to FunctionConfig when config is None (args, kwargs, timeout).</p> <code>{}</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>When func is not provided.</p> Source code in <code>fast_healthchecks/checks/function.py</code> <pre><code>def __init__(\n    self,\n    *,\n    config: FunctionConfig | None = None,\n    func: Callable[..., Any] | None = None,\n    name: str = \"Function\",\n    executor: Executor | None = None,\n    **kwargs: Any,  # noqa: ANN401\n) -&gt; None:\n    \"\"\"Initialize the FunctionHealthCheck.\n\n    Args:\n        config: Config (args, kwargs, timeout). If None, built from kwargs.\n        func: The function to perform the health check on (required if config is None).\n        name: The name of the health check.\n        executor: Executor for sync functions. Defaults to None (thread pool).\n        **kwargs: Passed to FunctionConfig when config is None (args, kwargs, timeout).\n\n    Raises:\n        TypeError: When func is not provided.\n    \"\"\"\n    if config is None:\n        kwargs_copy = dict(kwargs)\n        func = kwargs_copy.pop(\"func\", func)\n        executor = kwargs_copy.pop(\"executor\", executor)\n        if func is None:\n            msg = \"func is required when config is not provided\"\n            raise TypeError(msg)\n        config = FunctionConfig(**kwargs_copy)\n    elif func is None:\n        msg = \"func is required\"\n        raise TypeError(msg)\n    self._config = config\n    self._func = func\n    self._executor = executor\n    self._name = name\n</code></pre>"},{"location":"api/#fast_healthchecks.checks.redis.RedisHealthCheck","title":"<code>RedisHealthCheck</code>","text":"<p>               Bases: <code>ClientCachingMixin['Redis']</code>, <code>HealthCheckDSN[HealthCheckResult]</code></p> <p>A class to perform health checks on Redis.</p> <p>Attributes:</p> Name Type Description <code>_database</code> <p>The database to connect to.</p> <code>_host</code> <p>The host to connect to.</p> <code>_name</code> <code>str</code> <p>The name of the health check.</p> <code>_password</code> <code>str</code> <p>The password to authenticate with.</p> <code>_port</code> <code>str</code> <p>The port to connect to.</p> <code>_timeout</code> <code>str</code> <p>The timeout for the connection.</p> <code>_user</code> <code>str</code> <p>The user to authenticate with.</p> <code>_ssl</code> <code>str</code> <p>Whether to use SSL or not.</p> <code>_ssl_ca_certs</code> <code>str</code> <p>The path to the CA certificate.</p> Source code in <code>fast_healthchecks/checks/redis.py</code> <pre><code>@final\nclass RedisHealthCheck(ClientCachingMixin[\"Redis\"], HealthCheckDSN[HealthCheckResult]):\n    \"\"\"A class to perform health checks on Redis.\n\n    Attributes:\n        _database: The database to connect to.\n        _host: The host to connect to.\n        _name: The name of the health check.\n        _password: The password to authenticate with.\n        _port: The port to connect to.\n        _timeout: The timeout for the connection.\n        _user: The user to authenticate with.\n        _ssl: Whether to use SSL or not.\n        _ssl_ca_certs: The path to the CA certificate.\n    \"\"\"\n\n    __slots__ = (*_CLIENT_CACHING_SLOTS, \"_config\", \"_name\")\n\n    _config: RedisConfig\n    _name: str\n    _client: Redis | None\n    _client_loop: asyncio.AbstractEventLoop | None\n\n    def __init__(\n        self,\n        *,\n        config: RedisConfig | None = None,\n        name: str = \"Redis\",\n        close_client_fn: Callable[[Redis], Awaitable[None]] = _close_redis_client,\n        **kwargs: Any,  # noqa: ANN401\n    ) -&gt; None:\n        \"\"\"Initialize the RedisHealthCheck class.\n\n        Args:\n            config: Connection config. If None, built from kwargs (host, port, database, etc.).\n            name: The name of the health check.\n            close_client_fn: Callable to close the cached client. Defaults to the\n                standard Redis aclose.\n            **kwargs: Passed to RedisConfig when config is None (host, port, database,\n                user, password, ssl, ssl_ca_certs, timeout).\n        \"\"\"\n        if config is None:\n            config = RedisConfig(**kwargs)\n        self._config = config\n        self._name = name\n        super().__init__(close_client_fn=close_client_fn)\n\n    def _create_client(self) -&gt; Redis:\n        c = self._config\n        return Redis(\n            host=c.host,\n            port=c.port,\n            db=c.database,\n            username=c.user,\n            password=c.password,\n            socket_timeout=c.timeout,\n            single_connection_client=True,\n            ssl=c.ssl,\n            ssl_ca_certs=c.ssl_ca_certs,\n        )\n\n    @classmethod\n    def _allowed_schemes(cls) -&gt; tuple[str, ...]:\n        return (\"redis\", \"rediss\")\n\n    @classmethod\n    def _default_name(cls) -&gt; str:\n        return \"Redis\"\n\n    @classmethod\n    def parse_dsn(cls, dsn: str) -&gt; RedisParseDSNResult:\n        \"\"\"Parse the DSN and return the results.\n\n        Args:\n            dsn: The DSN to parse.\n\n        Returns:\n            RedisParseDSNResult: The results of parsing the DSN.\n        \"\"\"\n        parse_result: ConnectKwargs = parse_url(str(dsn))\n        scheme = urlsplit(dsn).scheme.lower()\n        return {\"parse_result\": parse_result, \"scheme\": scheme}\n\n    @classmethod\n    def _from_parsed_dsn(\n        cls,\n        parsed: RedisParseDSNResult,\n        *,\n        name: str = \"Redis\",\n        timeout: float = DEFAULT_HC_TIMEOUT,\n        **_kwargs: object,\n    ) -&gt; RedisHealthCheck:\n        parse_result = parsed[\"parse_result\"]\n        scheme = parsed.get(\"scheme\", \"\")\n        ssl_ca_certs: str | None = parse_result.get(\"ssl_ca_certs\")\n        ssl = parse_result.get(\"ssl\", False) or bool(ssl_ca_certs) or (scheme == \"rediss\")\n        config = RedisConfig(\n            host=parse_result.get(\"host\", \"localhost\"),\n            port=parse_result.get(\"port\", 6379),\n            database=parse_result.get(\"db\", 0),\n            user=parse_result.get(\"username\"),\n            password=parse_result.get(\"password\"),\n            ssl=ssl,\n            ssl_ca_certs=ssl_ca_certs,\n            timeout=timeout,\n        )\n        return cls(config=config, name=name)\n\n    @healthcheck_safe(invalidate_on_error=True)\n    async def __call__(self) -&gt; HealthCheckResult:\n        \"\"\"Perform a health check on Redis.\n\n        Returns:\n            HealthCheckResult: The result of the health check.\n        \"\"\"\n        redis = await self._ensure_client()\n        ping_result = redis.ping()\n        healthy = bool(await ping_result) if asyncio.iscoroutine(ping_result) else bool(ping_result)\n        return HealthCheckResult(name=self._name, healthy=healthy)\n</code></pre>"},{"location":"api/#fast_healthchecks.checks.redis.RedisHealthCheck.__call__","title":"<code>__call__()</code>  <code>async</code>","text":"<p>Perform a health check on Redis.</p> <p>Returns:</p> Name Type Description <code>HealthCheckResult</code> <code>HealthCheckResult</code> <p>The result of the health check.</p> Source code in <code>fast_healthchecks/checks/redis.py</code> <pre><code>@healthcheck_safe(invalidate_on_error=True)\nasync def __call__(self) -&gt; HealthCheckResult:\n    \"\"\"Perform a health check on Redis.\n\n    Returns:\n        HealthCheckResult: The result of the health check.\n    \"\"\"\n    redis = await self._ensure_client()\n    ping_result = redis.ping()\n    healthy = bool(await ping_result) if asyncio.iscoroutine(ping_result) else bool(ping_result)\n    return HealthCheckResult(name=self._name, healthy=healthy)\n</code></pre>"},{"location":"api/#fast_healthchecks.checks.redis.RedisHealthCheck.__init__","title":"<code>__init__(*, config=None, name='Redis', close_client_fn=_close_redis_client, **kwargs)</code>","text":"<p>Initialize the RedisHealthCheck class.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>RedisConfig | None</code> <p>Connection config. If None, built from kwargs (host, port, database, etc.).</p> <code>None</code> <code>name</code> <code>str</code> <p>The name of the health check.</p> <code>'Redis'</code> <code>close_client_fn</code> <code>Callable[[Redis], Awaitable[None]]</code> <p>Callable to close the cached client. Defaults to the standard Redis aclose.</p> <code>_close_redis_client</code> <code>**kwargs</code> <code>Any</code> <p>Passed to RedisConfig when config is None (host, port, database, user, password, ssl, ssl_ca_certs, timeout).</p> <code>{}</code> Source code in <code>fast_healthchecks/checks/redis.py</code> <pre><code>def __init__(\n    self,\n    *,\n    config: RedisConfig | None = None,\n    name: str = \"Redis\",\n    close_client_fn: Callable[[Redis], Awaitable[None]] = _close_redis_client,\n    **kwargs: Any,  # noqa: ANN401\n) -&gt; None:\n    \"\"\"Initialize the RedisHealthCheck class.\n\n    Args:\n        config: Connection config. If None, built from kwargs (host, port, database, etc.).\n        name: The name of the health check.\n        close_client_fn: Callable to close the cached client. Defaults to the\n            standard Redis aclose.\n        **kwargs: Passed to RedisConfig when config is None (host, port, database,\n            user, password, ssl, ssl_ca_certs, timeout).\n    \"\"\"\n    if config is None:\n        config = RedisConfig(**kwargs)\n    self._config = config\n    self._name = name\n    super().__init__(close_client_fn=close_client_fn)\n</code></pre>"},{"location":"api/#fast_healthchecks.checks.redis.RedisHealthCheck.parse_dsn","title":"<code>parse_dsn(dsn)</code>  <code>classmethod</code>","text":"<p>Parse the DSN and return the results.</p> <p>Parameters:</p> Name Type Description Default <code>dsn</code> <code>str</code> <p>The DSN to parse.</p> required <p>Returns:</p> Name Type Description <code>RedisParseDSNResult</code> <code>RedisParseDSNResult</code> <p>The results of parsing the DSN.</p> Source code in <code>fast_healthchecks/checks/redis.py</code> <pre><code>@classmethod\ndef parse_dsn(cls, dsn: str) -&gt; RedisParseDSNResult:\n    \"\"\"Parse the DSN and return the results.\n\n    Args:\n        dsn: The DSN to parse.\n\n    Returns:\n        RedisParseDSNResult: The results of parsing the DSN.\n    \"\"\"\n    parse_result: ConnectKwargs = parse_url(str(dsn))\n    scheme = urlsplit(dsn).scheme.lower()\n    return {\"parse_result\": parse_result, \"scheme\": scheme}\n</code></pre>"},{"location":"api/#fast_healthchecks.checks.kafka.KafkaHealthCheck","title":"<code>KafkaHealthCheck</code>","text":"<p>               Bases: <code>ClientCachingMixin['AIOKafkaAdminClient']</code>, <code>HealthCheckDSN[HealthCheckResult]</code></p> <p>A class to perform health checks on Kafka.</p> <p>Attributes:</p> Name Type Description <code>_bootstrap_servers</code> <p>The Kafka bootstrap servers.</p> <code>_name</code> <code>str</code> <p>The name of the health check.</p> <code>_sasl_mechanism</code> <code>str</code> <p>The SASL mechanism to use.</p> <code>_sasl_plain_password</code> <code>str</code> <p>The SASL plain password.</p> <code>_sasl_plain_username</code> <code>str</code> <p>The SASL plain username.</p> <code>_security_protocol</code> <code>str</code> <p>The security protocol to use.</p> <code>_ssl_context</code> <code>str</code> <p>The SSL context to use.</p> <code>_timeout</code> <code>str</code> <p>The timeout for the health check.</p> Source code in <code>fast_healthchecks/checks/kafka.py</code> <pre><code>@final\nclass KafkaHealthCheck(ClientCachingMixin[\"AIOKafkaAdminClient\"], HealthCheckDSN[HealthCheckResult]):\n    \"\"\"A class to perform health checks on Kafka.\n\n    Attributes:\n        _bootstrap_servers: The Kafka bootstrap servers.\n        _name: The name of the health check.\n        _sasl_mechanism: The SASL mechanism to use.\n        _sasl_plain_password: The SASL plain password.\n        _sasl_plain_username: The SASL plain username.\n        _security_protocol: The security protocol to use.\n        _ssl_context: The SSL context to use.\n        _timeout: The timeout for the health check.\n    \"\"\"\n\n    __slots__ = (*_CLIENT_CACHING_SLOTS, \"_config\", \"_name\")\n\n    _config: KafkaConfig\n    _name: str\n    _client: AIOKafkaAdminClient | None\n    _client_loop: asyncio.AbstractEventLoop | None\n\n    def __init__(\n        self,\n        *,\n        config: KafkaConfig | None = None,\n        name: str = \"Kafka\",\n        close_client_fn: Callable[[AIOKafkaAdminClient], Awaitable[None]] = _close_kafka_client,\n        **kwargs: Any,  # noqa: ANN401\n    ) -&gt; None:\n        \"\"\"Initialize the KafkaHealthCheck.\n\n        Args:\n            config: Connection config. If None, built from kwargs (bootstrap_servers, etc.).\n            name: The name of the health check.\n            close_client_fn: Callable to close the cached client.\n            **kwargs: Passed to KafkaConfig when config is None.\n        \"\"\"\n        if config is None:\n            config = KafkaConfig(**kwargs)\n        self._config = config\n        self._name = name\n        super().__init__(close_client_fn=close_client_fn)\n\n    def _create_client(self) -&gt; AIOKafkaAdminClient:\n        c = self._config\n        return AIOKafkaAdminClient(\n            bootstrap_servers=c.bootstrap_servers,\n            client_id=\"fast_healthchecks\",\n            request_timeout_ms=int(c.timeout * 1000),\n            ssl_context=c.ssl_context,\n            security_protocol=c.security_protocol,\n            sasl_mechanism=c.sasl_mechanism,\n            sasl_plain_username=c.sasl_plain_username,\n            sasl_plain_password=c.sasl_plain_password,\n        )\n\n    @classmethod\n    def _allowed_schemes(cls) -&gt; tuple[str, ...]:\n        return (\"kafka\", \"kafkas\")\n\n    @classmethod\n    def _default_name(cls) -&gt; str:\n        return \"Kafka\"\n\n    @classmethod\n    def parse_dsn(cls, dsn: str) -&gt; KafkaParseDSNResult:\n        \"\"\"Parse the Kafka DSN and return the results.\n\n        Scheme ``kafkas`` implies SSL (SASL_SSL when credentials present).\n        Scheme ``kafka`` implies PLAINTEXT (SASL_PLAINTEXT when credentials present).\n        Kwargs to from_dsn override DSN-derived values.\n\n        Args:\n            dsn: The DSN to parse.\n\n        Returns:\n            KafkaParseDSNResult: The results of parsing the DSN.\n\n        Raises:\n            ValueError: If bootstrap servers are missing.\n        \"\"\"\n        parsed = urlsplit(dsn)\n        scheme = (parsed.scheme or \"kafka\").lower()\n        netloc = parsed.netloc\n        sasl_plain_username: str | None = None\n        sasl_plain_password: str | None = None\n        if \"@\" in netloc:\n            userinfo, hosts = netloc.rsplit(\"@\", 1)\n            netloc = hosts\n            if \":\" in userinfo:\n                username, password = userinfo.split(\":\", 1)\n                sasl_plain_username = unquote(username) or None\n                sasl_plain_password = unquote(password) or None\n            else:\n                sasl_plain_username = unquote(userinfo) or None\n\n        bootstrap_servers = netloc or parsed.path.lstrip(\"/\")\n        if not bootstrap_servers:\n            msg = \"Kafka DSN must include bootstrap servers\"\n            raise ValueError(msg) from None\n\n        if scheme == \"kafkas\":\n            security_protocol = \"SASL_SSL\" if (sasl_plain_username or sasl_plain_password) else \"SSL\"\n        else:\n            security_protocol = \"SASL_PLAINTEXT\" if (sasl_plain_username or sasl_plain_password) else \"PLAINTEXT\"\n\n        return {\n            \"bootstrap_servers\": bootstrap_servers,\n            \"sasl_plain_username\": sasl_plain_username,\n            \"sasl_plain_password\": sasl_plain_password,\n            \"security_protocol\": security_protocol,\n        }\n\n    @classmethod\n    def _from_parsed_dsn(\n        cls,\n        parsed: KafkaParseDSNResult,\n        *,\n        name: str = \"Kafka\",\n        timeout: float = DEFAULT_HC_TIMEOUT,\n        **kwargs: Any,  # noqa: ANN401\n    ) -&gt; KafkaHealthCheck:\n        config = KafkaConfig(\n            bootstrap_servers=parsed[\"bootstrap_servers\"],\n            ssl_context=cast(\"ssl.SSLContext | None\", kwargs.get(\"ssl_context\")),\n            security_protocol=kwargs.get(\"security_protocol\", parsed[\"security_protocol\"]) or \"PLAINTEXT\",\n            sasl_mechanism=kwargs.get(\"sasl_mechanism\", \"PLAIN\"),\n            sasl_plain_username=parsed[\"sasl_plain_username\"],\n            sasl_plain_password=parsed[\"sasl_plain_password\"],\n            timeout=timeout,\n        )\n        return cls(config=config, name=name)\n\n    @healthcheck_safe(invalidate_on_error=True)\n    async def __call__(self) -&gt; HealthCheckResult:\n        \"\"\"Perform the health check on Kafka.\n\n        Returns:\n            HealthCheckResult: The result of the health check.\n        \"\"\"\n        client = await self._ensure_client()\n        await client.start()\n        await client.list_topics()\n        return HealthCheckResult(name=self._name, healthy=True)\n</code></pre>"},{"location":"api/#fast_healthchecks.checks.kafka.KafkaHealthCheck.__call__","title":"<code>__call__()</code>  <code>async</code>","text":"<p>Perform the health check on Kafka.</p> <p>Returns:</p> Name Type Description <code>HealthCheckResult</code> <code>HealthCheckResult</code> <p>The result of the health check.</p> Source code in <code>fast_healthchecks/checks/kafka.py</code> <pre><code>@healthcheck_safe(invalidate_on_error=True)\nasync def __call__(self) -&gt; HealthCheckResult:\n    \"\"\"Perform the health check on Kafka.\n\n    Returns:\n        HealthCheckResult: The result of the health check.\n    \"\"\"\n    client = await self._ensure_client()\n    await client.start()\n    await client.list_topics()\n    return HealthCheckResult(name=self._name, healthy=True)\n</code></pre>"},{"location":"api/#fast_healthchecks.checks.kafka.KafkaHealthCheck.__init__","title":"<code>__init__(*, config=None, name='Kafka', close_client_fn=_close_kafka_client, **kwargs)</code>","text":"<p>Initialize the KafkaHealthCheck.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>KafkaConfig | None</code> <p>Connection config. If None, built from kwargs (bootstrap_servers, etc.).</p> <code>None</code> <code>name</code> <code>str</code> <p>The name of the health check.</p> <code>'Kafka'</code> <code>close_client_fn</code> <code>Callable[[AIOKafkaAdminClient], Awaitable[None]]</code> <p>Callable to close the cached client.</p> <code>_close_kafka_client</code> <code>**kwargs</code> <code>Any</code> <p>Passed to KafkaConfig when config is None.</p> <code>{}</code> Source code in <code>fast_healthchecks/checks/kafka.py</code> <pre><code>def __init__(\n    self,\n    *,\n    config: KafkaConfig | None = None,\n    name: str = \"Kafka\",\n    close_client_fn: Callable[[AIOKafkaAdminClient], Awaitable[None]] = _close_kafka_client,\n    **kwargs: Any,  # noqa: ANN401\n) -&gt; None:\n    \"\"\"Initialize the KafkaHealthCheck.\n\n    Args:\n        config: Connection config. If None, built from kwargs (bootstrap_servers, etc.).\n        name: The name of the health check.\n        close_client_fn: Callable to close the cached client.\n        **kwargs: Passed to KafkaConfig when config is None.\n    \"\"\"\n    if config is None:\n        config = KafkaConfig(**kwargs)\n    self._config = config\n    self._name = name\n    super().__init__(close_client_fn=close_client_fn)\n</code></pre>"},{"location":"api/#fast_healthchecks.checks.kafka.KafkaHealthCheck.parse_dsn","title":"<code>parse_dsn(dsn)</code>  <code>classmethod</code>","text":"<p>Parse the Kafka DSN and return the results.</p> <p>Scheme <code>kafkas</code> implies SSL (SASL_SSL when credentials present). Scheme <code>kafka</code> implies PLAINTEXT (SASL_PLAINTEXT when credentials present). Kwargs to from_dsn override DSN-derived values.</p> <p>Parameters:</p> Name Type Description Default <code>dsn</code> <code>str</code> <p>The DSN to parse.</p> required <p>Returns:</p> Name Type Description <code>KafkaParseDSNResult</code> <code>KafkaParseDSNResult</code> <p>The results of parsing the DSN.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If bootstrap servers are missing.</p> Source code in <code>fast_healthchecks/checks/kafka.py</code> <pre><code>@classmethod\ndef parse_dsn(cls, dsn: str) -&gt; KafkaParseDSNResult:\n    \"\"\"Parse the Kafka DSN and return the results.\n\n    Scheme ``kafkas`` implies SSL (SASL_SSL when credentials present).\n    Scheme ``kafka`` implies PLAINTEXT (SASL_PLAINTEXT when credentials present).\n    Kwargs to from_dsn override DSN-derived values.\n\n    Args:\n        dsn: The DSN to parse.\n\n    Returns:\n        KafkaParseDSNResult: The results of parsing the DSN.\n\n    Raises:\n        ValueError: If bootstrap servers are missing.\n    \"\"\"\n    parsed = urlsplit(dsn)\n    scheme = (parsed.scheme or \"kafka\").lower()\n    netloc = parsed.netloc\n    sasl_plain_username: str | None = None\n    sasl_plain_password: str | None = None\n    if \"@\" in netloc:\n        userinfo, hosts = netloc.rsplit(\"@\", 1)\n        netloc = hosts\n        if \":\" in userinfo:\n            username, password = userinfo.split(\":\", 1)\n            sasl_plain_username = unquote(username) or None\n            sasl_plain_password = unquote(password) or None\n        else:\n            sasl_plain_username = unquote(userinfo) or None\n\n    bootstrap_servers = netloc or parsed.path.lstrip(\"/\")\n    if not bootstrap_servers:\n        msg = \"Kafka DSN must include bootstrap servers\"\n        raise ValueError(msg) from None\n\n    if scheme == \"kafkas\":\n        security_protocol = \"SASL_SSL\" if (sasl_plain_username or sasl_plain_password) else \"SSL\"\n    else:\n        security_protocol = \"SASL_PLAINTEXT\" if (sasl_plain_username or sasl_plain_password) else \"PLAINTEXT\"\n\n    return {\n        \"bootstrap_servers\": bootstrap_servers,\n        \"sasl_plain_username\": sasl_plain_username,\n        \"sasl_plain_password\": sasl_plain_password,\n        \"security_protocol\": security_protocol,\n    }\n</code></pre>"},{"location":"api/#fast_healthchecks.checks.mongo.MongoHealthCheck","title":"<code>MongoHealthCheck</code>","text":"<p>               Bases: <code>ClientCachingMixin['AsyncIOMotorClient[dict[str, Any]]']</code>, <code>HealthCheckDSN[HealthCheckResult]</code></p> <p>A class to perform health checks on MongoDB.</p> <p>Attributes:</p> Name Type Description <code>_auth_source</code> <p>The MongoDB authentication source.</p> <code>_database</code> <p>The MongoDB database to use.</p> <code>_hosts</code> <p>The MongoDB host or a list of hosts.</p> <code>_name</code> <code>str</code> <p>The name of the health check.</p> <code>_password</code> <code>str</code> <p>The MongoDB password.</p> <code>_port</code> <code>str</code> <p>The MongoDB port.</p> <code>_timeout</code> <code>str</code> <p>The timeout for the health check.</p> <code>_user</code> <code>str</code> <p>The MongoDB user.</p> Source code in <code>fast_healthchecks/checks/mongo.py</code> <pre><code>@final\nclass MongoHealthCheck(ClientCachingMixin[\"AsyncIOMotorClient[dict[str, Any]]\"], HealthCheckDSN[HealthCheckResult]):\n    \"\"\"A class to perform health checks on MongoDB.\n\n    Attributes:\n        _auth_source: The MongoDB authentication source.\n        _database: The MongoDB database to use.\n        _hosts: The MongoDB host or a list of hosts.\n        _name: The name of the health check.\n        _password: The MongoDB password.\n        _port: The MongoDB port.\n        _timeout: The timeout for the health check.\n        _user: The MongoDB user.\n    \"\"\"\n\n    __slots__ = (*_CLIENT_CACHING_SLOTS, \"_config\", \"_name\")\n\n    _config: MongoConfig\n    _name: str\n    _client: AsyncIOMotorClient[dict[str, Any]] | None\n    _client_loop: asyncio.AbstractEventLoop | None\n\n    def __init__(\n        self,\n        *,\n        config: MongoConfig | None = None,\n        name: str = \"MongoDB\",\n        close_client_fn: Callable[\n            [AsyncIOMotorClient[dict[str, Any]]],\n            Awaitable[None],\n        ] = _close_mongo_client,\n        **kwargs: Any,  # noqa: ANN401\n    ) -&gt; None:\n        \"\"\"Initialize the MongoHealthCheck.\n\n        Args:\n            config: Connection config. If None, built from kwargs (hosts, port, etc.).\n            name: The name of the health check.\n            close_client_fn: Callable to close the cached client.\n            **kwargs: Passed to MongoConfig when config is None.\n        \"\"\"\n        if config is None:\n            config = MongoConfig(**kwargs)\n        self._config = config\n        self._name = name\n        super().__init__(close_client_fn=close_client_fn)\n\n    def _create_client(self) -&gt; AsyncIOMotorClient[dict[str, Any]]:\n        c = self._config\n        return AsyncIOMotorClient(\n            host=c.hosts,\n            port=c.port,\n            username=c.user,\n            password=c.password,\n            authSource=c.auth_source,\n            serverSelectionTimeoutMS=int(c.timeout * 1000),\n        )\n\n    @classmethod\n    def _allowed_schemes(cls) -&gt; tuple[str, ...]:\n        return (\"mongodb\", \"mongodb+srv\")\n\n    @classmethod\n    def _default_name(cls) -&gt; str:\n        return \"MongoDB\"\n\n    @classmethod\n    def parse_dsn(cls, dsn: str) -&gt; MongoParseDSNResult:\n        \"\"\"Parse the DSN and return the results.\n\n        Args:\n            dsn: The DSN to parse.\n\n        Returns:\n            MongoParseDSNResult: The results of parsing the DSN.\n        \"\"\"\n        parse_result = urlsplit(dsn)\n        query = parse_query_string(parse_result.query)\n        return {\"parse_result\": parse_result, \"authSource\": query.get(\"authSource\", \"admin\")}\n\n    @classmethod\n    def _from_parsed_dsn(\n        cls,\n        parsed: MongoParseDSNResult,\n        *,\n        name: str = \"MongoDB\",\n        timeout: float = DEFAULT_HC_TIMEOUT,\n        **_kwargs: object,\n    ) -&gt; MongoHealthCheck:\n        parse_result = parsed[\"parse_result\"]\n        hosts: str | list[str]\n        port: int | None\n        if \",\" in parse_result.netloc:\n            hosts = parse_result.netloc.split(\"@\")[-1].split(\",\")\n            port = None\n        else:\n            hosts = parse_result.hostname or \"localhost\"\n            port = parse_result.port or 27017\n        config = MongoConfig(\n            hosts=hosts,\n            port=port,\n            user=parse_result.username,\n            password=parse_result.password,\n            database=parse_result.path.lstrip(\"/\") or None,\n            auth_source=parsed[\"authSource\"],\n            timeout=timeout,\n        )\n        return cls(config=config, name=name)\n\n    @healthcheck_safe(invalidate_on_error=True)\n    async def __call__(self) -&gt; HealthCheckResult:\n        \"\"\"Perform the health check on MongoDB.\n\n        Returns:\n            HealthCheckResult: The result of the health check.\n        \"\"\"\n        client = await self._ensure_client()\n        database = client[self._config.database] if self._config.database else client[self._config.auth_source]\n        res = await database.command(\"ping\")\n        ok_raw = res.get(\"ok\")\n        ok_value = ok_raw if isinstance(ok_raw, (bool, int, float)) else 0\n        return HealthCheckResult(name=self._name, healthy=int(ok_value) == 1)\n</code></pre>"},{"location":"api/#fast_healthchecks.checks.mongo.MongoHealthCheck.__call__","title":"<code>__call__()</code>  <code>async</code>","text":"<p>Perform the health check on MongoDB.</p> <p>Returns:</p> Name Type Description <code>HealthCheckResult</code> <code>HealthCheckResult</code> <p>The result of the health check.</p> Source code in <code>fast_healthchecks/checks/mongo.py</code> <pre><code>@healthcheck_safe(invalidate_on_error=True)\nasync def __call__(self) -&gt; HealthCheckResult:\n    \"\"\"Perform the health check on MongoDB.\n\n    Returns:\n        HealthCheckResult: The result of the health check.\n    \"\"\"\n    client = await self._ensure_client()\n    database = client[self._config.database] if self._config.database else client[self._config.auth_source]\n    res = await database.command(\"ping\")\n    ok_raw = res.get(\"ok\")\n    ok_value = ok_raw if isinstance(ok_raw, (bool, int, float)) else 0\n    return HealthCheckResult(name=self._name, healthy=int(ok_value) == 1)\n</code></pre>"},{"location":"api/#fast_healthchecks.checks.mongo.MongoHealthCheck.__init__","title":"<code>__init__(*, config=None, name='MongoDB', close_client_fn=_close_mongo_client, **kwargs)</code>","text":"<p>Initialize the MongoHealthCheck.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>MongoConfig | None</code> <p>Connection config. If None, built from kwargs (hosts, port, etc.).</p> <code>None</code> <code>name</code> <code>str</code> <p>The name of the health check.</p> <code>'MongoDB'</code> <code>close_client_fn</code> <code>Callable[[AsyncIOMotorClient[dict[str, Any]]], Awaitable[None]]</code> <p>Callable to close the cached client.</p> <code>_close_mongo_client</code> <code>**kwargs</code> <code>Any</code> <p>Passed to MongoConfig when config is None.</p> <code>{}</code> Source code in <code>fast_healthchecks/checks/mongo.py</code> <pre><code>def __init__(\n    self,\n    *,\n    config: MongoConfig | None = None,\n    name: str = \"MongoDB\",\n    close_client_fn: Callable[\n        [AsyncIOMotorClient[dict[str, Any]]],\n        Awaitable[None],\n    ] = _close_mongo_client,\n    **kwargs: Any,  # noqa: ANN401\n) -&gt; None:\n    \"\"\"Initialize the MongoHealthCheck.\n\n    Args:\n        config: Connection config. If None, built from kwargs (hosts, port, etc.).\n        name: The name of the health check.\n        close_client_fn: Callable to close the cached client.\n        **kwargs: Passed to MongoConfig when config is None.\n    \"\"\"\n    if config is None:\n        config = MongoConfig(**kwargs)\n    self._config = config\n    self._name = name\n    super().__init__(close_client_fn=close_client_fn)\n</code></pre>"},{"location":"api/#fast_healthchecks.checks.mongo.MongoHealthCheck.parse_dsn","title":"<code>parse_dsn(dsn)</code>  <code>classmethod</code>","text":"<p>Parse the DSN and return the results.</p> <p>Parameters:</p> Name Type Description Default <code>dsn</code> <code>str</code> <p>The DSN to parse.</p> required <p>Returns:</p> Name Type Description <code>MongoParseDSNResult</code> <code>MongoParseDSNResult</code> <p>The results of parsing the DSN.</p> Source code in <code>fast_healthchecks/checks/mongo.py</code> <pre><code>@classmethod\ndef parse_dsn(cls, dsn: str) -&gt; MongoParseDSNResult:\n    \"\"\"Parse the DSN and return the results.\n\n    Args:\n        dsn: The DSN to parse.\n\n    Returns:\n        MongoParseDSNResult: The results of parsing the DSN.\n    \"\"\"\n    parse_result = urlsplit(dsn)\n    query = parse_query_string(parse_result.query)\n    return {\"parse_result\": parse_result, \"authSource\": query.get(\"authSource\", \"admin\")}\n</code></pre>"},{"location":"api/#fast_healthchecks.checks.opensearch.OpenSearchHealthCheck","title":"<code>OpenSearchHealthCheck</code>","text":"<p>               Bases: <code>ClientCachingMixin['AsyncOpenSearch']</code>, <code>HealthCheckDSN[HealthCheckResult]</code></p> <p>A class to perform health checks on OpenSearch.</p> <p>Attributes:</p> Name Type Description <code>_hosts</code> <p>The OpenSearch hosts.</p> <code>_name</code> <code>str</code> <p>The name of the health check.</p> <code>_http_auth</code> <code>str</code> <p>The HTTP authentication.</p> <code>_use_ssl</code> <code>str</code> <p>Whether to use SSL or not.</p> <code>_verify_certs</code> <code>str</code> <p>Whether to verify certificates or not.</p> <code>_ssl_show_warn</code> <code>str</code> <p>Whether to show SSL warnings or not.</p> <code>_ca_certs</code> <code>str</code> <p>The CA certificates.</p> <code>_timeout</code> <code>str</code> <p>The timeout for the health check.</p> Source code in <code>fast_healthchecks/checks/opensearch.py</code> <pre><code>@final\nclass OpenSearchHealthCheck(ClientCachingMixin[\"AsyncOpenSearch\"], HealthCheckDSN[HealthCheckResult]):\n    \"\"\"A class to perform health checks on OpenSearch.\n\n    Attributes:\n        _hosts: The OpenSearch hosts.\n        _name: The name of the health check.\n        _http_auth: The HTTP authentication.\n        _use_ssl: Whether to use SSL or not.\n        _verify_certs: Whether to verify certificates or not.\n        _ssl_show_warn: Whether to show SSL warnings or not.\n        _ca_certs: The CA certificates.\n        _timeout: The timeout for the health check.\n    \"\"\"\n\n    __slots__ = (*_CLIENT_CACHING_SLOTS, \"_config\", \"_name\")\n\n    _config: OpenSearchConfig\n    _name: str\n    _client: AsyncOpenSearch | None\n    _client_loop: asyncio.AbstractEventLoop | None\n\n    def __init__(\n        self,\n        *,\n        config: OpenSearchConfig | None = None,\n        name: str = \"OpenSearch\",\n        close_client_fn: Callable[[AsyncOpenSearch], Awaitable[None]] = _close_opensearch_client,\n        **kwargs: Any,  # noqa: ANN401\n    ) -&gt; None:\n        \"\"\"Initialize the OpenSearchHealthCheck.\n\n        Args:\n            config: Connection config. If None, built from kwargs (hosts, http_auth, etc.).\n            name: The name of the health check.\n            close_client_fn: Callable to close the cached client.\n            **kwargs: Passed to OpenSearchConfig when config is None.\n        \"\"\"\n        if config is None:\n            config = OpenSearchConfig(**kwargs)\n        self._config = config\n        self._name = name\n        super().__init__(close_client_fn=close_client_fn)\n\n    def _create_client(self) -&gt; AsyncOpenSearch:\n        c = self._config\n        return AsyncOpenSearch(\n            hosts=c.hosts,\n            http_auth=c.http_auth,\n            use_ssl=c.use_ssl,\n            verify_certs=c.verify_certs,\n            ssl_show_warn=c.ssl_show_warn,\n            ca_certs=c.ca_certs,\n            timeout=c.timeout,\n        )\n\n    @classmethod\n    def _allowed_schemes(cls) -&gt; tuple[str, ...]:\n        return (\"http\", \"https\")\n\n    @classmethod\n    def _default_name(cls) -&gt; str:\n        return \"OpenSearch\"\n\n    @classmethod\n    def parse_dsn(cls, dsn: str) -&gt; OpenSearchParseDSNResult:\n        \"\"\"Parse the OpenSearch DSN and return the results.\n\n        Args:\n            dsn: The DSN to parse.\n\n        Returns:\n            OpenSearchParseDSNResult: The results of parsing the DSN.\n\n        Raises:\n            ValueError: If DSN has missing host.\n        \"\"\"\n        parsed = urlsplit(dsn)\n        if not parsed.hostname:\n            msg = \"OpenSearch DSN must include a host\"\n            raise ValueError(msg) from None\n\n        http_auth: tuple[str, str] | None = None\n        if parsed.username is not None:\n            http_auth = (unquote(parsed.username), unquote(parsed.password or \"\"))\n\n        port = parsed.port or (443 if parsed.scheme == \"https\" else 9200)\n        return {\n            \"hosts\": [f\"{parsed.hostname}:{port}\"],\n            \"http_auth\": http_auth,\n            \"use_ssl\": parsed.scheme == \"https\",\n        }\n\n    @classmethod\n    def _from_parsed_dsn(\n        cls,\n        parsed: OpenSearchParseDSNResult,\n        *,\n        name: str = \"OpenSearch\",\n        timeout: float = DEFAULT_HC_TIMEOUT,\n        **kwargs: Any,  # noqa: ANN401\n    ) -&gt; OpenSearchHealthCheck:\n        config = OpenSearchConfig(\n            hosts=parsed[\"hosts\"],\n            http_auth=parsed[\"http_auth\"],\n            use_ssl=parsed[\"use_ssl\"],\n            verify_certs=cast(\"bool\", kwargs.get(\"verify_certs\", False)),\n            ssl_show_warn=cast(\"bool\", kwargs.get(\"ssl_show_warn\", False)),\n            ca_certs=cast(\"str | None\", kwargs.get(\"ca_certs\")),\n            timeout=timeout,\n        )\n        return cls(config=config, name=name)\n\n    @healthcheck_safe(invalidate_on_error=True)\n    async def __call__(self) -&gt; HealthCheckResult:\n        \"\"\"Perform the health check on OpenSearch.\n\n        Returns:\n            HealthCheckResult: The result of the health check.\n        \"\"\"\n        client = await self._ensure_client()\n        await client.info()\n        return HealthCheckResult(name=self._name, healthy=True)\n</code></pre>"},{"location":"api/#fast_healthchecks.checks.opensearch.OpenSearchHealthCheck.__call__","title":"<code>__call__()</code>  <code>async</code>","text":"<p>Perform the health check on OpenSearch.</p> <p>Returns:</p> Name Type Description <code>HealthCheckResult</code> <code>HealthCheckResult</code> <p>The result of the health check.</p> Source code in <code>fast_healthchecks/checks/opensearch.py</code> <pre><code>@healthcheck_safe(invalidate_on_error=True)\nasync def __call__(self) -&gt; HealthCheckResult:\n    \"\"\"Perform the health check on OpenSearch.\n\n    Returns:\n        HealthCheckResult: The result of the health check.\n    \"\"\"\n    client = await self._ensure_client()\n    await client.info()\n    return HealthCheckResult(name=self._name, healthy=True)\n</code></pre>"},{"location":"api/#fast_healthchecks.checks.opensearch.OpenSearchHealthCheck.__init__","title":"<code>__init__(*, config=None, name='OpenSearch', close_client_fn=_close_opensearch_client, **kwargs)</code>","text":"<p>Initialize the OpenSearchHealthCheck.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>OpenSearchConfig | None</code> <p>Connection config. If None, built from kwargs (hosts, http_auth, etc.).</p> <code>None</code> <code>name</code> <code>str</code> <p>The name of the health check.</p> <code>'OpenSearch'</code> <code>close_client_fn</code> <code>Callable[[AsyncOpenSearch], Awaitable[None]]</code> <p>Callable to close the cached client.</p> <code>_close_opensearch_client</code> <code>**kwargs</code> <code>Any</code> <p>Passed to OpenSearchConfig when config is None.</p> <code>{}</code> Source code in <code>fast_healthchecks/checks/opensearch.py</code> <pre><code>def __init__(\n    self,\n    *,\n    config: OpenSearchConfig | None = None,\n    name: str = \"OpenSearch\",\n    close_client_fn: Callable[[AsyncOpenSearch], Awaitable[None]] = _close_opensearch_client,\n    **kwargs: Any,  # noqa: ANN401\n) -&gt; None:\n    \"\"\"Initialize the OpenSearchHealthCheck.\n\n    Args:\n        config: Connection config. If None, built from kwargs (hosts, http_auth, etc.).\n        name: The name of the health check.\n        close_client_fn: Callable to close the cached client.\n        **kwargs: Passed to OpenSearchConfig when config is None.\n    \"\"\"\n    if config is None:\n        config = OpenSearchConfig(**kwargs)\n    self._config = config\n    self._name = name\n    super().__init__(close_client_fn=close_client_fn)\n</code></pre>"},{"location":"api/#fast_healthchecks.checks.opensearch.OpenSearchHealthCheck.parse_dsn","title":"<code>parse_dsn(dsn)</code>  <code>classmethod</code>","text":"<p>Parse the OpenSearch DSN and return the results.</p> <p>Parameters:</p> Name Type Description Default <code>dsn</code> <code>str</code> <p>The DSN to parse.</p> required <p>Returns:</p> Name Type Description <code>OpenSearchParseDSNResult</code> <code>OpenSearchParseDSNResult</code> <p>The results of parsing the DSN.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If DSN has missing host.</p> Source code in <code>fast_healthchecks/checks/opensearch.py</code> <pre><code>@classmethod\ndef parse_dsn(cls, dsn: str) -&gt; OpenSearchParseDSNResult:\n    \"\"\"Parse the OpenSearch DSN and return the results.\n\n    Args:\n        dsn: The DSN to parse.\n\n    Returns:\n        OpenSearchParseDSNResult: The results of parsing the DSN.\n\n    Raises:\n        ValueError: If DSN has missing host.\n    \"\"\"\n    parsed = urlsplit(dsn)\n    if not parsed.hostname:\n        msg = \"OpenSearch DSN must include a host\"\n        raise ValueError(msg) from None\n\n    http_auth: tuple[str, str] | None = None\n    if parsed.username is not None:\n        http_auth = (unquote(parsed.username), unquote(parsed.password or \"\"))\n\n    port = parsed.port or (443 if parsed.scheme == \"https\" else 9200)\n    return {\n        \"hosts\": [f\"{parsed.hostname}:{port}\"],\n        \"http_auth\": http_auth,\n        \"use_ssl\": parsed.scheme == \"https\",\n    }\n</code></pre>"},{"location":"api/#fast_healthchecks.checks.rabbitmq.RabbitMQHealthCheck","title":"<code>RabbitMQHealthCheck</code>","text":"<p>               Bases: <code>ClientCachingMixin['AbstractRobustConnection']</code>, <code>HealthCheckDSN[HealthCheckResult]</code></p> <p>A class to perform health checks on RabbitMQ.</p> <p>Uses ClientCachingMixin to reuse a single connection instead of opening a new one on every check.</p> <p>Attributes:</p> Name Type Description <code>_host</code> <p>The RabbitMQ host.</p> <code>_name</code> <code>str</code> <p>The name of the health check.</p> <code>_password</code> <code>str</code> <p>The RabbitMQ password.</p> <code>_port</code> <code>str</code> <p>The RabbitMQ port.</p> <code>_secure</code> <code>str</code> <p>Whether to use a secure connection.</p> <code>_timeout</code> <code>str</code> <p>The timeout for the health check.</p> <code>_user</code> <code>str</code> <p>The RabbitMQ user.</p> <code>_vhost</code> <code>str</code> <p>The RabbitMQ virtual host.</p> Source code in <code>fast_healthchecks/checks/rabbitmq.py</code> <pre><code>@final\nclass RabbitMQHealthCheck(ClientCachingMixin[\"AbstractRobustConnection\"], HealthCheckDSN[HealthCheckResult]):\n    \"\"\"A class to perform health checks on RabbitMQ.\n\n    Uses ClientCachingMixin to reuse a single connection instead of opening\n    a new one on every check.\n\n    Attributes:\n        _host: The RabbitMQ host.\n        _name: The name of the health check.\n        _password: The RabbitMQ password.\n        _port: The RabbitMQ port.\n        _secure: Whether to use a secure connection.\n        _timeout: The timeout for the health check.\n        _user: The RabbitMQ user.\n        _vhost: The RabbitMQ virtual host.\n    \"\"\"\n\n    __slots__ = (*_CLIENT_CACHING_SLOTS, \"_config\", \"_name\")\n\n    _config: RabbitMQConfig\n    _name: str\n    _client: AbstractRobustConnection | None\n    _client_loop: asyncio.AbstractEventLoop | None\n\n    def __init__(\n        self,\n        *,\n        config: RabbitMQConfig | None = None,\n        name: str = \"RabbitMQ\",\n        close_client_fn: Callable[[AbstractRobustConnection], Awaitable[None]] = _close_rabbitmq_client,\n        **kwargs: Any,  # noqa: ANN401\n    ) -&gt; None:\n        \"\"\"Initialize the RabbitMQHealthCheck.\n\n        Args:\n            config: Connection config. If None, built from kwargs (host, user, password, etc.).\n            name: The name of the health check.\n            close_client_fn: Callable to close the cached connection.\n            **kwargs: Passed to RabbitMQConfig when config is None.\n        \"\"\"\n        if config is None:\n            config = RabbitMQConfig(**kwargs)\n        self._config = config\n        self._name = name\n        super().__init__(close_client_fn=close_client_fn)\n\n    def _create_client(self) -&gt; Awaitable[AbstractRobustConnection]:\n        c = self._config\n        return aio_pika.connect_robust(\n            host=c.host,\n            port=c.port,\n            login=c.user,\n            password=c.password,\n            ssl=c.secure,\n            virtualhost=c.vhost,\n            timeout=c.timeout,\n        )\n\n    @classmethod\n    def _allowed_schemes(cls) -&gt; tuple[str, ...]:\n        return (\"amqp\", \"amqps\")\n\n    @classmethod\n    def _default_name(cls) -&gt; str:\n        return \"RabbitMQ\"\n\n    @classmethod\n    def parse_dsn(cls, dsn: str) -&gt; RabbitMQParseDSNResult:\n        \"\"\"Parse the DSN and return the results.\n\n        Args:\n            dsn: The DSN to parse.\n\n        Returns:\n            RabbitMQParseDSNResult: The results of parsing the DSN.\n        \"\"\"\n        parse_result = urlsplit(dsn)\n        return {\"parse_result\": parse_result}\n\n    @classmethod\n    def _from_parsed_dsn(\n        cls,\n        parsed: RabbitMQParseDSNResult,\n        *,\n        name: str = \"RabbitMQ\",\n        timeout: float = DEFAULT_HC_TIMEOUT,\n        **_kwargs: object,\n    ) -&gt; RabbitMQHealthCheck:\n        parse_result = parsed[\"parse_result\"]\n        config = RabbitMQConfig(\n            host=parse_result.hostname or \"localhost\",\n            user=parse_result.username or \"guest\",\n            password=parse_result.password or \"guest\",\n            port=parse_result.port or 5672,\n            vhost=parse_result.path.lstrip(\"/\") or \"/\",\n            secure=parse_result.scheme == \"amqps\",\n            timeout=timeout,\n        )\n        return cls(config=config, name=name)\n\n    @healthcheck_safe(invalidate_on_error=True)\n    async def __call__(self) -&gt; HealthCheckResult:\n        \"\"\"Perform the health check on RabbitMQ.\n\n        ClientCachingMixin handles connection persistence; _ensure_client\n        validates the connection via aio-pika's robust logic.\n\n        Returns:\n            HealthCheckResult: The result of the health check.\n        \"\"\"\n        _ = await self._ensure_client()\n        return HealthCheckResult(name=self._name, healthy=True)\n</code></pre>"},{"location":"api/#fast_healthchecks.checks.rabbitmq.RabbitMQHealthCheck.__call__","title":"<code>__call__()</code>  <code>async</code>","text":"<p>Perform the health check on RabbitMQ.</p> <p>ClientCachingMixin handles connection persistence; _ensure_client validates the connection via aio-pika's robust logic.</p> <p>Returns:</p> Name Type Description <code>HealthCheckResult</code> <code>HealthCheckResult</code> <p>The result of the health check.</p> Source code in <code>fast_healthchecks/checks/rabbitmq.py</code> <pre><code>@healthcheck_safe(invalidate_on_error=True)\nasync def __call__(self) -&gt; HealthCheckResult:\n    \"\"\"Perform the health check on RabbitMQ.\n\n    ClientCachingMixin handles connection persistence; _ensure_client\n    validates the connection via aio-pika's robust logic.\n\n    Returns:\n        HealthCheckResult: The result of the health check.\n    \"\"\"\n    _ = await self._ensure_client()\n    return HealthCheckResult(name=self._name, healthy=True)\n</code></pre>"},{"location":"api/#fast_healthchecks.checks.rabbitmq.RabbitMQHealthCheck.__init__","title":"<code>__init__(*, config=None, name='RabbitMQ', close_client_fn=_close_rabbitmq_client, **kwargs)</code>","text":"<p>Initialize the RabbitMQHealthCheck.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>RabbitMQConfig | None</code> <p>Connection config. If None, built from kwargs (host, user, password, etc.).</p> <code>None</code> <code>name</code> <code>str</code> <p>The name of the health check.</p> <code>'RabbitMQ'</code> <code>close_client_fn</code> <code>Callable[[AbstractRobustConnection], Awaitable[None]]</code> <p>Callable to close the cached connection.</p> <code>_close_rabbitmq_client</code> <code>**kwargs</code> <code>Any</code> <p>Passed to RabbitMQConfig when config is None.</p> <code>{}</code> Source code in <code>fast_healthchecks/checks/rabbitmq.py</code> <pre><code>def __init__(\n    self,\n    *,\n    config: RabbitMQConfig | None = None,\n    name: str = \"RabbitMQ\",\n    close_client_fn: Callable[[AbstractRobustConnection], Awaitable[None]] = _close_rabbitmq_client,\n    **kwargs: Any,  # noqa: ANN401\n) -&gt; None:\n    \"\"\"Initialize the RabbitMQHealthCheck.\n\n    Args:\n        config: Connection config. If None, built from kwargs (host, user, password, etc.).\n        name: The name of the health check.\n        close_client_fn: Callable to close the cached connection.\n        **kwargs: Passed to RabbitMQConfig when config is None.\n    \"\"\"\n    if config is None:\n        config = RabbitMQConfig(**kwargs)\n    self._config = config\n    self._name = name\n    super().__init__(close_client_fn=close_client_fn)\n</code></pre>"},{"location":"api/#fast_healthchecks.checks.rabbitmq.RabbitMQHealthCheck.parse_dsn","title":"<code>parse_dsn(dsn)</code>  <code>classmethod</code>","text":"<p>Parse the DSN and return the results.</p> <p>Parameters:</p> Name Type Description Default <code>dsn</code> <code>str</code> <p>The DSN to parse.</p> required <p>Returns:</p> Name Type Description <code>RabbitMQParseDSNResult</code> <code>RabbitMQParseDSNResult</code> <p>The results of parsing the DSN.</p> Source code in <code>fast_healthchecks/checks/rabbitmq.py</code> <pre><code>@classmethod\ndef parse_dsn(cls, dsn: str) -&gt; RabbitMQParseDSNResult:\n    \"\"\"Parse the DSN and return the results.\n\n    Args:\n        dsn: The DSN to parse.\n\n    Returns:\n        RabbitMQParseDSNResult: The results of parsing the DSN.\n    \"\"\"\n    parse_result = urlsplit(dsn)\n    return {\"parse_result\": parse_result}\n</code></pre>"},{"location":"api/#fast_healthchecks.checks.url.UrlHealthCheck","title":"<code>UrlHealthCheck</code>","text":"<p>               Bases: <code>ClientCachingMixin['AsyncClient']</code>, <code>ConfigDictMixin</code>, <code>HealthCheck[HealthCheckResult]</code></p> <p>Health check that performs an HTTP GET to a configurable URL.</p> <p>Supports basic auth, custom timeout, SSL verification, and optional SSRF protection via <code>block_private_hosts</code> (see config).</p> Source code in <code>fast_healthchecks/checks/url.py</code> <pre><code>@final\nclass UrlHealthCheck(ClientCachingMixin[\"AsyncClient\"], ConfigDictMixin, HealthCheck[HealthCheckResult]):\n    \"\"\"Health check that performs an HTTP GET to a configurable URL.\n\n    Supports basic auth, custom timeout, SSL verification, and optional\n    SSRF protection via ``block_private_hosts`` (see config).\n    \"\"\"\n\n    __slots__ = (*_CLIENT_CACHING_SLOTS, \"_config\", \"_name\")\n\n    _config: UrlConfig\n    _name: str\n    _client: AsyncClient | None\n    _client_loop: asyncio.AbstractEventLoop | None\n\n    @property\n    def _auth(self) -&gt; BasicAuth | None:\n        c = self._config\n        return BasicAuth(c.username, c.password or \"\") if c.username else None\n\n    @property\n    def _transport(self) -&gt; AsyncHTTPTransport:\n        return AsyncHTTPTransport(verify=self._config.verify_ssl)\n\n    @property\n    def _block_private_hosts(self) -&gt; bool:\n        return self._config.block_private_hosts\n\n    def __init__(\n        self,\n        *,\n        config: UrlConfig | None = None,\n        name: str = \"HTTP\",\n        close_client_fn: Callable[[AsyncClient], Awaitable[None]] = _close_url_client,\n        **kwargs: Any,  # noqa: ANN401\n    ) -&gt; None:\n        \"\"\"Initialize the health check.\n\n        Warning:\n            Pass only trusted URLs from application configuration. Do not use\n            user-controlled input for ``url`` to avoid SSRF.\n\n        Args:\n            config: Connection config. If None, built from kwargs (url, username, etc.).\n            name: The name of the health check.\n            close_client_fn: Callable to close the cached client.\n            **kwargs: Passed to UrlConfig when config is None (url required).\n        \"\"\"\n        if config is None:\n            kwargs = dict(kwargs)\n            if \"url\" in kwargs:\n                kwargs[\"url\"] = str(kwargs[\"url\"])\n            config = UrlConfig(**kwargs)\n        validate_url_ssrf(config.url, block_private_hosts=config.block_private_hosts)\n        self._config = config\n        self._name = name\n        super().__init__(close_client_fn=close_client_fn)\n\n    def _create_client(self) -&gt; AsyncClient:\n        c = self._config\n        transport = AsyncHTTPTransport(verify=c.verify_ssl)\n        return AsyncClient(\n            auth=self._auth,\n            timeout=c.timeout,\n            transport=transport,\n            follow_redirects=c.follow_redirects,\n        )\n\n    @healthcheck_safe(invalidate_on_error=True)\n    async def __call__(self) -&gt; HealthCheckResult:\n        \"\"\"Perform the health check.\n\n        When block_private_hosts is True, resolves the URL host before the request\n        and rejects if it resolves to loopback/private (SSRF/DNS rebinding protection).\n\n        Returns:\n            HealthCheckResult: Result with healthy=True if response is success.\n        \"\"\"\n        if self._config.block_private_hosts:\n            parsed = urlparse(self._config.url)\n            host = parsed.hostname or \"\"\n            await validate_host_ssrf_async(host)\n        client = await self._ensure_client()\n        response: Response = await client.get(self._config.url)\n        if response.status_code &gt;= HTTPStatus.INTERNAL_SERVER_ERROR or (\n            self._config.username and response.status_code in {HTTPStatus.UNAUTHORIZED, HTTPStatus.FORBIDDEN}\n        ):\n            response.raise_for_status()\n        return HealthCheckResult(name=self._name, healthy=response.is_success)\n</code></pre>"},{"location":"api/#fast_healthchecks.checks.url.UrlHealthCheck.__call__","title":"<code>__call__()</code>  <code>async</code>","text":"<p>Perform the health check.</p> <p>When block_private_hosts is True, resolves the URL host before the request and rejects if it resolves to loopback/private (SSRF/DNS rebinding protection).</p> <p>Returns:</p> Name Type Description <code>HealthCheckResult</code> <code>HealthCheckResult</code> <p>Result with healthy=True if response is success.</p> Source code in <code>fast_healthchecks/checks/url.py</code> <pre><code>@healthcheck_safe(invalidate_on_error=True)\nasync def __call__(self) -&gt; HealthCheckResult:\n    \"\"\"Perform the health check.\n\n    When block_private_hosts is True, resolves the URL host before the request\n    and rejects if it resolves to loopback/private (SSRF/DNS rebinding protection).\n\n    Returns:\n        HealthCheckResult: Result with healthy=True if response is success.\n    \"\"\"\n    if self._config.block_private_hosts:\n        parsed = urlparse(self._config.url)\n        host = parsed.hostname or \"\"\n        await validate_host_ssrf_async(host)\n    client = await self._ensure_client()\n    response: Response = await client.get(self._config.url)\n    if response.status_code &gt;= HTTPStatus.INTERNAL_SERVER_ERROR or (\n        self._config.username and response.status_code in {HTTPStatus.UNAUTHORIZED, HTTPStatus.FORBIDDEN}\n    ):\n        response.raise_for_status()\n    return HealthCheckResult(name=self._name, healthy=response.is_success)\n</code></pre>"},{"location":"api/#fast_healthchecks.checks.url.UrlHealthCheck.__init__","title":"<code>__init__(*, config=None, name='HTTP', close_client_fn=_close_url_client, **kwargs)</code>","text":"<p>Initialize the health check.</p> Warning <p>Pass only trusted URLs from application configuration. Do not use user-controlled input for <code>url</code> to avoid SSRF.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>UrlConfig | None</code> <p>Connection config. If None, built from kwargs (url, username, etc.).</p> <code>None</code> <code>name</code> <code>str</code> <p>The name of the health check.</p> <code>'HTTP'</code> <code>close_client_fn</code> <code>Callable[[AsyncClient], Awaitable[None]]</code> <p>Callable to close the cached client.</p> <code>_close_url_client</code> <code>**kwargs</code> <code>Any</code> <p>Passed to UrlConfig when config is None (url required).</p> <code>{}</code> Source code in <code>fast_healthchecks/checks/url.py</code> <pre><code>def __init__(\n    self,\n    *,\n    config: UrlConfig | None = None,\n    name: str = \"HTTP\",\n    close_client_fn: Callable[[AsyncClient], Awaitable[None]] = _close_url_client,\n    **kwargs: Any,  # noqa: ANN401\n) -&gt; None:\n    \"\"\"Initialize the health check.\n\n    Warning:\n        Pass only trusted URLs from application configuration. Do not use\n        user-controlled input for ``url`` to avoid SSRF.\n\n    Args:\n        config: Connection config. If None, built from kwargs (url, username, etc.).\n        name: The name of the health check.\n        close_client_fn: Callable to close the cached client.\n        **kwargs: Passed to UrlConfig when config is None (url required).\n    \"\"\"\n    if config is None:\n        kwargs = dict(kwargs)\n        if \"url\" in kwargs:\n            kwargs[\"url\"] = str(kwargs[\"url\"])\n        config = UrlConfig(**kwargs)\n    validate_url_ssrf(config.url, block_private_hosts=config.block_private_hosts)\n    self._config = config\n    self._name = name\n    super().__init__(close_client_fn=close_client_fn)\n</code></pre>"},{"location":"api/#fast_healthchecks.checks.postgresql.asyncpg--or","title":"or","text":"<p>health_check = PostgreSQLAsyncPGHealthCheck.from_dsn(     \"postgresql://username:password@localhost:5432/dbname\", ) result = await health_check() print(result.healthy)</p>"},{"location":"api/#fast_healthchecks.checks.postgresql.asyncpg.PostgreSQLAsyncPGHealthCheck","title":"<code>PostgreSQLAsyncPGHealthCheck</code>","text":"<p>               Bases: <code>BasePostgreSQLHealthCheck[HealthCheckResult]</code></p> <p>Health check class for PostgreSQL using asyncpg.</p> <p>Attributes:</p> Name Type Description <code>_name</code> <code>str</code> <p>The name of the health check.</p> <code>_host</code> <code>str</code> <p>The hostname of the PostgreSQL server.</p> <code>_port</code> <code>str</code> <p>The port number of the PostgreSQL server.</p> <code>_user</code> <code>str</code> <p>The username for authentication.</p> <code>_password</code> <code>str</code> <p>The password for authentication.</p> <code>_database</code> <code>str</code> <p>The database name.</p> <code>_ssl</code> <code>str</code> <p>The SSL context for secure connections.</p> <code>_direct_tls</code> <code>str</code> <p>Whether to use direct TLS.</p> <code>_timeout</code> <code>str</code> <p>The timeout for the connection.</p> Source code in <code>fast_healthchecks/checks/postgresql/asyncpg.py</code> <pre><code>class PostgreSQLAsyncPGHealthCheck(BasePostgreSQLHealthCheck[HealthCheckResult]):\n    \"\"\"Health check class for PostgreSQL using asyncpg.\n\n    Attributes:\n        _name: The name of the health check.\n        _host: The hostname of the PostgreSQL server.\n        _port: The port number of the PostgreSQL server.\n        _user: The username for authentication.\n        _password: The password for authentication.\n        _database: The database name.\n        _ssl: The SSL context for secure connections.\n        _direct_tls: Whether to use direct TLS.\n        _timeout: The timeout for the connection.\n    \"\"\"\n\n    __slots__ = (\"_config\", \"_name\")\n\n    _config: PostgresAsyncPGConfig\n    _name: str\n\n    def __init__(\n        self,\n        *,\n        config: PostgresAsyncPGConfig | None = None,\n        name: str = \"PostgreSQL\",\n        **kwargs: Any,  # noqa: ANN401\n    ) -&gt; None:\n        \"\"\"Initialize the PostgreSQLAsyncPGHealthCheck.\n\n        Args:\n            config: Connection config. If None, built from kwargs (host, port, user, etc.).\n            name: The name of the health check.\n            **kwargs: Passed to PostgresAsyncPGConfig when config is None.\n        \"\"\"\n        if config is None:\n            config = PostgresAsyncPGConfig(**kwargs)\n        self._config = config\n        self._name = name\n\n    @classmethod\n    def _from_parsed_dsn(\n        cls,\n        parsed: PostgresParseDSNResult,\n        *,\n        name: str = \"PostgreSQL\",\n        timeout: float = DEFAULT_HC_TIMEOUT,\n        **_kwargs: object,\n    ) -&gt; PostgreSQLAsyncPGHealthCheck:\n        parse_result = parsed[\"parse_result\"]\n        sslctx = parsed[\"sslctx\"]\n        config = PostgresAsyncPGConfig(\n            host=parse_result.hostname or \"localhost\",\n            port=parse_result.port or 5432,\n            user=parse_result.username,\n            password=parse_result.password,\n            database=parse_result.path.lstrip(\"/\"),\n            ssl=sslctx,\n            direct_tls=parsed[\"direct_tls\"],\n            timeout=timeout,\n        )\n        return cls(config=config, name=name)\n\n    @healthcheck_safe(invalidate_on_error=False)\n    async def __call__(self) -&gt; HealthCheckResult:\n        \"\"\"Perform the health check.\n\n        Returns:\n            HealthCheckResult: The result of the health check.\n        \"\"\"\n        c = self._config\n        connection: Connection | None = None\n        try:\n            connection = await asyncpg.connect(\n                host=c.host,\n                port=c.port,\n                user=c.user,\n                password=c.password,\n                database=c.database,\n                timeout=c.timeout,\n                ssl=c.ssl,\n                direct_tls=c.direct_tls,\n            )\n            async with connection.transaction(readonly=True):\n                healthy: bool = bool(await connection.fetchval(\"SELECT 1\"))\n                return HealthCheckResult(name=self._name, healthy=healthy)\n        finally:\n            if connection is not None and not connection.is_closed():\n                await connection.close(timeout=c.timeout)\n</code></pre>"},{"location":"api/#fast_healthchecks.checks.postgresql.asyncpg.PostgreSQLAsyncPGHealthCheck.__call__","title":"<code>__call__()</code>  <code>async</code>","text":"<p>Perform the health check.</p> <p>Returns:</p> Name Type Description <code>HealthCheckResult</code> <code>HealthCheckResult</code> <p>The result of the health check.</p> Source code in <code>fast_healthchecks/checks/postgresql/asyncpg.py</code> <pre><code>@healthcheck_safe(invalidate_on_error=False)\nasync def __call__(self) -&gt; HealthCheckResult:\n    \"\"\"Perform the health check.\n\n    Returns:\n        HealthCheckResult: The result of the health check.\n    \"\"\"\n    c = self._config\n    connection: Connection | None = None\n    try:\n        connection = await asyncpg.connect(\n            host=c.host,\n            port=c.port,\n            user=c.user,\n            password=c.password,\n            database=c.database,\n            timeout=c.timeout,\n            ssl=c.ssl,\n            direct_tls=c.direct_tls,\n        )\n        async with connection.transaction(readonly=True):\n            healthy: bool = bool(await connection.fetchval(\"SELECT 1\"))\n            return HealthCheckResult(name=self._name, healthy=healthy)\n    finally:\n        if connection is not None and not connection.is_closed():\n            await connection.close(timeout=c.timeout)\n</code></pre>"},{"location":"api/#fast_healthchecks.checks.postgresql.asyncpg.PostgreSQLAsyncPGHealthCheck.__init__","title":"<code>__init__(*, config=None, name='PostgreSQL', **kwargs)</code>","text":"<p>Initialize the PostgreSQLAsyncPGHealthCheck.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>PostgresAsyncPGConfig | None</code> <p>Connection config. If None, built from kwargs (host, port, user, etc.).</p> <code>None</code> <code>name</code> <code>str</code> <p>The name of the health check.</p> <code>'PostgreSQL'</code> <code>**kwargs</code> <code>Any</code> <p>Passed to PostgresAsyncPGConfig when config is None.</p> <code>{}</code> Source code in <code>fast_healthchecks/checks/postgresql/asyncpg.py</code> <pre><code>def __init__(\n    self,\n    *,\n    config: PostgresAsyncPGConfig | None = None,\n    name: str = \"PostgreSQL\",\n    **kwargs: Any,  # noqa: ANN401\n) -&gt; None:\n    \"\"\"Initialize the PostgreSQLAsyncPGHealthCheck.\n\n    Args:\n        config: Connection config. If None, built from kwargs (host, port, user, etc.).\n        name: The name of the health check.\n        **kwargs: Passed to PostgresAsyncPGConfig when config is None.\n    \"\"\"\n    if config is None:\n        config = PostgresAsyncPGConfig(**kwargs)\n    self._config = config\n    self._name = name\n</code></pre>"},{"location":"api/#fast_healthchecks.checks.postgresql.psycopg--or","title":"or","text":"<p>health_check = PostgreSQLPsycopgHealthCheck.from_dsn(     \"postgresql://username:password@localhost:5432/dbname\", ) result = await health_check() print(result.healthy)</p>"},{"location":"api/#fast_healthchecks.checks.postgresql.psycopg.PostgreSQLPsycopgHealthCheck","title":"<code>PostgreSQLPsycopgHealthCheck</code>","text":"<p>               Bases: <code>BasePostgreSQLHealthCheck[HealthCheckResult]</code></p> <p>Health check class for PostgreSQL using psycopg.</p> <p>Attributes:</p> Name Type Description <code>_name</code> <code>str</code> <p>The name of the health check.</p> <code>_host</code> <code>str</code> <p>The hostname of the PostgreSQL server.</p> <code>_port</code> <code>str</code> <p>The port number of the PostgreSQL server.</p> <code>_user</code> <code>str</code> <p>The username for authentication.</p> <code>_password</code> <code>str</code> <p>The password for authentication.</p> <code>_database</code> <code>str</code> <p>The database name.</p> <code>_sslmode</code> <code>str</code> <p>The SSL mode to use for the connection.</p> <code>_sslcert</code> <code>str</code> <p>The path to the SSL certificate file.</p> <code>_sslkey</code> <code>str</code> <p>The path to the SSL key file.</p> <code>_sslrootcert</code> <code>str</code> <p>The path to the SSL root certificate file.</p> <code>_timeout</code> <code>str</code> <p>The timeout for the health check.</p> Source code in <code>fast_healthchecks/checks/postgresql/psycopg.py</code> <pre><code>class PostgreSQLPsycopgHealthCheck(BasePostgreSQLHealthCheck[HealthCheckResult]):\n    \"\"\"Health check class for PostgreSQL using psycopg.\n\n    Attributes:\n        _name: The name of the health check.\n        _host: The hostname of the PostgreSQL server.\n        _port: The port number of the PostgreSQL server.\n        _user: The username for authentication.\n        _password: The password for authentication.\n        _database: The database name.\n        _sslmode: The SSL mode to use for the connection.\n        _sslcert: The path to the SSL certificate file.\n        _sslkey: The path to the SSL key file.\n        _sslrootcert: The path to the SSL root certificate file.\n        _timeout: The timeout for the health check.\n    \"\"\"\n\n    __slots__ = (\"_config\", \"_name\")\n\n    _config: PostgresPsycopgConfig\n    _name: str\n\n    def __init__(\n        self,\n        *,\n        config: PostgresPsycopgConfig | None = None,\n        name: str = \"PostgreSQL\",\n        **kwargs: Any,  # noqa: ANN401\n    ) -&gt; None:\n        \"\"\"Initialize the PostgreSQLPsycopgHealthCheck.\n\n        Args:\n            config: Connection config. If None, built from kwargs (host, port, user, etc.).\n            name: The name of the health check.\n            **kwargs: Passed to PostgresPsycopgConfig when config is None.\n        \"\"\"\n        if config is None:\n            config = PostgresPsycopgConfig(**kwargs)\n        self._config = config\n        self._name = name\n\n    @classmethod\n    def _from_parsed_dsn(\n        cls,\n        parsed: PostgresParseDSNResult,\n        *,\n        name: str = \"PostgreSQL\",\n        timeout: float = DEFAULT_HC_TIMEOUT,\n        **_kwargs: object,\n    ) -&gt; PostgreSQLPsycopgHealthCheck:\n        parse_result = parsed[\"parse_result\"]\n        config = PostgresPsycopgConfig(\n            host=parse_result.hostname or \"localhost\",\n            port=parse_result.port or 5432,\n            user=parse_result.username,\n            password=parse_result.password,\n            database=parse_result.path.lstrip(\"/\"),\n            sslmode=parsed[\"sslmode\"],\n            sslcert=parsed[\"sslcert\"],\n            sslkey=parsed[\"sslkey\"],\n            sslrootcert=parsed[\"sslrootcert\"],\n            timeout=timeout,\n        )\n        return cls(config=config, name=name)\n\n    @healthcheck_safe(invalidate_on_error=False)\n    async def __call__(self) -&gt; HealthCheckResult:\n        \"\"\"Perform the health check.\n\n        Returns:\n            HealthCheckResult: The result of the health check.\n        \"\"\"\n        c = self._config\n        connection: AsyncConnection | None = None\n        try:\n            connection = await psycopg.AsyncConnection.connect(\n                host=c.host,\n                port=c.port,\n                user=c.user,\n                password=c.password,\n                dbname=c.database,\n                sslmode=c.sslmode,\n                sslcert=c.sslcert,\n                sslkey=c.sslkey,\n                sslrootcert=c.sslrootcert,\n                connect_timeout=int(c.timeout),\n            )\n            async with connection.cursor() as cursor:\n                await cursor.execute(\"SELECT 1\")\n                healthy: bool = bool(await cursor.fetchone())\n                return HealthCheckResult(name=self._name, healthy=healthy)\n        finally:\n            if connection is not None and not connection.closed:\n                await connection.cancel_safe(timeout=c.timeout)\n                await connection.close()\n</code></pre>"},{"location":"api/#fast_healthchecks.checks.postgresql.psycopg.PostgreSQLPsycopgHealthCheck.__call__","title":"<code>__call__()</code>  <code>async</code>","text":"<p>Perform the health check.</p> <p>Returns:</p> Name Type Description <code>HealthCheckResult</code> <code>HealthCheckResult</code> <p>The result of the health check.</p> Source code in <code>fast_healthchecks/checks/postgresql/psycopg.py</code> <pre><code>@healthcheck_safe(invalidate_on_error=False)\nasync def __call__(self) -&gt; HealthCheckResult:\n    \"\"\"Perform the health check.\n\n    Returns:\n        HealthCheckResult: The result of the health check.\n    \"\"\"\n    c = self._config\n    connection: AsyncConnection | None = None\n    try:\n        connection = await psycopg.AsyncConnection.connect(\n            host=c.host,\n            port=c.port,\n            user=c.user,\n            password=c.password,\n            dbname=c.database,\n            sslmode=c.sslmode,\n            sslcert=c.sslcert,\n            sslkey=c.sslkey,\n            sslrootcert=c.sslrootcert,\n            connect_timeout=int(c.timeout),\n        )\n        async with connection.cursor() as cursor:\n            await cursor.execute(\"SELECT 1\")\n            healthy: bool = bool(await cursor.fetchone())\n            return HealthCheckResult(name=self._name, healthy=healthy)\n    finally:\n        if connection is not None and not connection.closed:\n            await connection.cancel_safe(timeout=c.timeout)\n            await connection.close()\n</code></pre>"},{"location":"api/#fast_healthchecks.checks.postgresql.psycopg.PostgreSQLPsycopgHealthCheck.__init__","title":"<code>__init__(*, config=None, name='PostgreSQL', **kwargs)</code>","text":"<p>Initialize the PostgreSQLPsycopgHealthCheck.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>PostgresPsycopgConfig | None</code> <p>Connection config. If None, built from kwargs (host, port, user, etc.).</p> <code>None</code> <code>name</code> <code>str</code> <p>The name of the health check.</p> <code>'PostgreSQL'</code> <code>**kwargs</code> <code>Any</code> <p>Passed to PostgresPsycopgConfig when config is None.</p> <code>{}</code> Source code in <code>fast_healthchecks/checks/postgresql/psycopg.py</code> <pre><code>def __init__(\n    self,\n    *,\n    config: PostgresPsycopgConfig | None = None,\n    name: str = \"PostgreSQL\",\n    **kwargs: Any,  # noqa: ANN401\n) -&gt; None:\n    \"\"\"Initialize the PostgreSQLPsycopgHealthCheck.\n\n    Args:\n        config: Connection config. If None, built from kwargs (host, port, user, etc.).\n        name: The name of the health check.\n        **kwargs: Passed to PostgresPsycopgConfig when config is None.\n    \"\"\"\n    if config is None:\n        config = PostgresPsycopgConfig(**kwargs)\n    self._config = config\n    self._name = name\n</code></pre>"},{"location":"api/#integrations","title":"Integrations","text":"<p>Base for FastAPI, FastStream, and Litestar integrations.</p> <p>Provides Probe, run_probe(), healthcheck_shutdown(), and helpers to build health routes. Framework-specific routers use these to expose liveness/readiness.</p> <p>FastAPI integration for health checks.</p> <p>FastStream integration for health checks.</p> <p>Litestar integration for health checks.</p> <p>Utility functions for fast-healthchecks.</p>"},{"location":"api/#fast_healthchecks.integrations.base.Probe","title":"<code>Probe</code>","text":"<p>               Bases: <code>NamedTuple</code></p> <p>A probe is a collection of health checks that can be run together.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the probe.</p> <code>checks</code> <code>Sequence[Check]</code> <p>A sequence of health checks to run.</p> <code>summary</code> <code>str | None</code> <p>A summary of the probe. If not provided, a default summary will be generated.</p> <code>allow_partial_failure</code> <code>bool</code> <p>If True, probe is healthy when at least one check passes.</p> Source code in <code>fast_healthchecks/integrations/base.py</code> <pre><code>class Probe(NamedTuple):\n    \"\"\"A probe is a collection of health checks that can be run together.\n\n    Attributes:\n        name: The name of the probe.\n        checks: A sequence of health checks to run.\n        summary: A summary of the probe. If not provided, a default summary will be generated.\n        allow_partial_failure: If True, probe is healthy when at least one check passes.\n    \"\"\"\n\n    name: str\n    checks: Sequence[Check]\n    summary: str | None = None\n    allow_partial_failure: bool = False\n\n    @property\n    def endpoint_summary(self) -&gt; str:\n        \"\"\"Return a summary for the endpoint.\n\n        If a summary is provided, it will be used. Otherwise, a default summary will be generated.\n        \"\"\"\n        if self.summary:\n            return self.summary\n        title = re.sub(\n            pattern=r\"[^a-z0-9]+\",\n            repl=\" \",\n            string=self.name.lower().capitalize(),\n            flags=re.IGNORECASE,\n        )\n        return f\"{title} probe\"\n</code></pre>"},{"location":"api/#fast_healthchecks.integrations.base.Probe.endpoint_summary","title":"<code>endpoint_summary</code>  <code>property</code>","text":"<p>Return a summary for the endpoint.</p> <p>If a summary is provided, it will be used. Otherwise, a default summary will be generated.</p>"},{"location":"api/#fast_healthchecks.integrations.base.ProbeAsgi","title":"<code>ProbeAsgi</code>","text":"<p>An ASGI probe.</p> <p>Parameters:</p> Name Type Description Default <code>probe</code> <code>Probe</code> <p>The probe to run.</p> required <code>options</code> <code>ProbeRouteOptions | None</code> <p>Route options (handlers, status codes, debug, timeout). When None, defaults from build_probe_route_options() are used.</p> <code>None</code> Source code in <code>fast_healthchecks/integrations/base.py</code> <pre><code>class ProbeAsgi:\n    \"\"\"An ASGI probe.\n\n    Args:\n        probe: The probe to run.\n        options: Route options (handlers, status codes, debug, timeout).\n            When None, defaults from build_probe_route_options() are used.\n    \"\"\"\n\n    __slots__ = (\n        \"_debug\",\n        \"_exclude_fields\",\n        \"_failure_handler\",\n        \"_failure_status\",\n        \"_map_handler\",\n        \"_map_status\",\n        \"_probe\",\n        \"_success_handler\",\n        \"_success_status\",\n        \"_timeout\",\n    )\n\n    _probe: Probe\n    _success_handler: HandlerType\n    _failure_handler: HandlerType\n    _success_status: int\n    _failure_status: int\n    _debug: bool\n    _exclude_fields: set[str]\n    _map_status: dict[bool, int]\n    _map_handler: dict[bool, HandlerType]\n    _timeout: float | None\n\n    def __init__(self, probe: Probe, *, options: ProbeRouteOptions | None = None) -&gt; None:\n        \"\"\"Initialize the ASGI probe.\"\"\"\n        if options is None:\n            options = build_probe_route_options()\n        params = options.to_route_params()\n        self._probe = probe\n        self._success_handler = params.success_handler\n        self._failure_handler = params.failure_handler\n        self._success_status = params.success_status\n        self._failure_status = params.failure_status\n        self._debug = params.debug\n        self._timeout = params.timeout\n        self._exclude_fields = {\"allow_partial_failure\", \"error_details\"} if not params.debug else set()\n        self._map_status = {True: params.success_status, False: params.failure_status}\n        self._map_handler = {True: params.success_handler, False: params.failure_handler}\n\n    async def __call__(self) -&gt; tuple[bytes, dict[str, str] | None, int]:\n        \"\"\"Run the probe via run_probe (unified execution and timeout handling).\n\n        Returns:\n            A tuple containing the response body, headers, and status code.\n        \"\"\"\n        report = await run_probe(\n            self._probe,\n            timeout=self._timeout,\n            on_timeout_return_failure=True,\n        )\n        response = ProbeAsgiResponse(\n            data=asdict(\n                report,\n                dict_factory=lambda x: {k: v for (k, v) in x if k not in self._exclude_fields},\n            ),\n            healthy=report.healthy,\n        )\n\n        actual_status = self._map_status[response.healthy]\n        content_needed = actual_status not in {\n            HTTPStatus.NO_CONTENT,\n            HTTPStatus.NOT_MODIFIED,\n        } and not (response.healthy and actual_status &lt; HTTPStatus.OK)\n\n        content = b\"\"\n        headers = None\n        if content_needed:\n            # When debug=True and unhealthy, return full report so assertion/logs show which check failed\n            if self._debug and not response.healthy:\n                content_ = response.data\n            else:\n                handler = self._map_handler[response.healthy]\n                content_ = await handler(response)\n            if content_ is not None:\n                content = json.dumps(\n                    content_,\n                    ensure_ascii=False,\n                    allow_nan=False,\n                    indent=None,\n                    separators=(\",\", \":\"),\n                ).encode(\"utf-8\")\n                headers = {\n                    \"content-type\": \"application/json\",\n                    \"content-length\": str(len(content)),\n                }\n\n        return content, headers, self._map_status[response.healthy]\n</code></pre>"},{"location":"api/#fast_healthchecks.integrations.base.ProbeAsgi.__call__","title":"<code>__call__()</code>  <code>async</code>","text":"<p>Run the probe via run_probe (unified execution and timeout handling).</p> <p>Returns:</p> Type Description <code>tuple[bytes, dict[str, str] | None, int]</code> <p>A tuple containing the response body, headers, and status code.</p> Source code in <code>fast_healthchecks/integrations/base.py</code> <pre><code>async def __call__(self) -&gt; tuple[bytes, dict[str, str] | None, int]:\n    \"\"\"Run the probe via run_probe (unified execution and timeout handling).\n\n    Returns:\n        A tuple containing the response body, headers, and status code.\n    \"\"\"\n    report = await run_probe(\n        self._probe,\n        timeout=self._timeout,\n        on_timeout_return_failure=True,\n    )\n    response = ProbeAsgiResponse(\n        data=asdict(\n            report,\n            dict_factory=lambda x: {k: v for (k, v) in x if k not in self._exclude_fields},\n        ),\n        healthy=report.healthy,\n    )\n\n    actual_status = self._map_status[response.healthy]\n    content_needed = actual_status not in {\n        HTTPStatus.NO_CONTENT,\n        HTTPStatus.NOT_MODIFIED,\n    } and not (response.healthy and actual_status &lt; HTTPStatus.OK)\n\n    content = b\"\"\n    headers = None\n    if content_needed:\n        # When debug=True and unhealthy, return full report so assertion/logs show which check failed\n        if self._debug and not response.healthy:\n            content_ = response.data\n        else:\n            handler = self._map_handler[response.healthy]\n            content_ = await handler(response)\n        if content_ is not None:\n            content = json.dumps(\n                content_,\n                ensure_ascii=False,\n                allow_nan=False,\n                indent=None,\n                separators=(\",\", \":\"),\n            ).encode(\"utf-8\")\n            headers = {\n                \"content-type\": \"application/json\",\n                \"content-length\": str(len(content)),\n            }\n\n    return content, headers, self._map_status[response.healthy]\n</code></pre>"},{"location":"api/#fast_healthchecks.integrations.base.ProbeAsgi.__init__","title":"<code>__init__(probe, *, options=None)</code>","text":"<p>Initialize the ASGI probe.</p> Source code in <code>fast_healthchecks/integrations/base.py</code> <pre><code>def __init__(self, probe: Probe, *, options: ProbeRouteOptions | None = None) -&gt; None:\n    \"\"\"Initialize the ASGI probe.\"\"\"\n    if options is None:\n        options = build_probe_route_options()\n    params = options.to_route_params()\n    self._probe = probe\n    self._success_handler = params.success_handler\n    self._failure_handler = params.failure_handler\n    self._success_status = params.success_status\n    self._failure_status = params.failure_status\n    self._debug = params.debug\n    self._timeout = params.timeout\n    self._exclude_fields = {\"allow_partial_failure\", \"error_details\"} if not params.debug else set()\n    self._map_status = {True: params.success_status, False: params.failure_status}\n    self._map_handler = {True: params.success_handler, False: params.failure_handler}\n</code></pre>"},{"location":"api/#fast_healthchecks.integrations.base.ProbeAsgiResponse","title":"<code>ProbeAsgiResponse</code>","text":"<p>               Bases: <code>NamedTuple</code></p> <p>A response from an ASGI probe.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>dict[str, Any]</code> <p>The response data (healthcheck results).</p> <code>healthy</code> <code>bool</code> <p>Whether all healthchecks passed.</p> Source code in <code>fast_healthchecks/integrations/base.py</code> <pre><code>class ProbeAsgiResponse(NamedTuple):\n    \"\"\"A response from an ASGI probe.\n\n    Attributes:\n        data: The response data (healthcheck results).\n        healthy: Whether all healthchecks passed.\n    \"\"\"\n\n    data: dict[str, Any]\n    healthy: bool\n</code></pre>"},{"location":"api/#fast_healthchecks.integrations.base.ProbeRouteOptions","title":"<code>ProbeRouteOptions</code>","text":"<p>               Bases: <code>NamedTuple</code></p> <p>Options for probe routes. Combines handler params and path prefix.</p> Source code in <code>fast_healthchecks/integrations/base.py</code> <pre><code>class ProbeRouteOptions(NamedTuple):\n    \"\"\"Options for probe routes. Combines handler params and path prefix.\"\"\"\n\n    success_handler: HandlerType\n    failure_handler: HandlerType\n    success_status: int\n    failure_status: int\n    debug: bool\n    timeout: float | None\n    prefix: str\n\n    def to_route_params(self) -&gt; ProbeRouteParams:\n        \"\"\"Return ProbeRouteParams for create_probe_route_handler.\"\"\"\n        return ProbeRouteParams(\n            success_handler=self.success_handler,\n            failure_handler=self.failure_handler,\n            success_status=self.success_status,\n            failure_status=self.failure_status,\n            debug=self.debug,\n            timeout=self.timeout,\n        )\n</code></pre>"},{"location":"api/#fast_healthchecks.integrations.base.ProbeRouteOptions.to_route_params","title":"<code>to_route_params()</code>","text":"<p>Return ProbeRouteParams for create_probe_route_handler.</p> Source code in <code>fast_healthchecks/integrations/base.py</code> <pre><code>def to_route_params(self) -&gt; ProbeRouteParams:\n    \"\"\"Return ProbeRouteParams for create_probe_route_handler.\"\"\"\n    return ProbeRouteParams(\n        success_handler=self.success_handler,\n        failure_handler=self.failure_handler,\n        success_status=self.success_status,\n        failure_status=self.failure_status,\n        debug=self.debug,\n        timeout=self.timeout,\n    )\n</code></pre>"},{"location":"api/#fast_healthchecks.integrations.base.ProbeRouteParams","title":"<code>ProbeRouteParams</code>","text":"<p>               Bases: <code>NamedTuple</code></p> <p>Parameters for probe route handlers. Used by framework integrations.</p> Source code in <code>fast_healthchecks/integrations/base.py</code> <pre><code>class ProbeRouteParams(NamedTuple):\n    \"\"\"Parameters for probe route handlers. Used by framework integrations.\"\"\"\n\n    success_handler: HandlerType\n    failure_handler: HandlerType\n    success_status: int\n    failure_status: int\n    debug: bool\n    timeout: float | None\n\n    def to_options(self, prefix: str = \"/health\") -&gt; ProbeRouteOptions:\n        \"\"\"Return ProbeRouteOptions with the given prefix.\"\"\"\n        return ProbeRouteOptions(\n            success_handler=self.success_handler,\n            failure_handler=self.failure_handler,\n            success_status=self.success_status,\n            failure_status=self.failure_status,\n            debug=self.debug,\n            timeout=self.timeout,\n            prefix=prefix,\n        )\n</code></pre>"},{"location":"api/#fast_healthchecks.integrations.base.ProbeRouteParams.to_options","title":"<code>to_options(prefix='/health')</code>","text":"<p>Return ProbeRouteOptions with the given prefix.</p> Source code in <code>fast_healthchecks/integrations/base.py</code> <pre><code>def to_options(self, prefix: str = \"/health\") -&gt; ProbeRouteOptions:\n    \"\"\"Return ProbeRouteOptions with the given prefix.\"\"\"\n    return ProbeRouteOptions(\n        success_handler=self.success_handler,\n        failure_handler=self.failure_handler,\n        success_status=self.success_status,\n        failure_status=self.failure_status,\n        debug=self.debug,\n        timeout=self.timeout,\n        prefix=prefix,\n    )\n</code></pre>"},{"location":"api/#fast_healthchecks.integrations.base.build_health_routes","title":"<code>build_health_routes(probes, add_route, *, options=None)</code>","text":"<p>Build health route entries for framework integrations.</p> <p>Used by Litestar and FastStream health() functions. When options is None, uses build_probe_route_options() defaults.</p> <p>Parameters:</p> Name Type Description Default <code>probes</code> <code>Iterable[Probe]</code> <p>Probes to build routes for.</p> required <code>add_route</code> <code>Callable[[Probe, ProbeRouteOptions], _T]</code> <p>Callback (probe, options) -&gt; route entry for the framework.</p> required <code>options</code> <code>ProbeRouteOptions | None</code> <p>Route options. When None, defaults from build_probe_route_options().</p> <code>None</code> <p>Returns:</p> Type Description <code>list[_T]</code> <p>List of route entries produced by add_route for each probe.</p> Source code in <code>fast_healthchecks/integrations/base.py</code> <pre><code>def build_health_routes(\n    probes: Iterable[Probe],\n    add_route: Callable[[Probe, ProbeRouteOptions], _T],\n    *,\n    options: ProbeRouteOptions | None = None,\n) -&gt; list[_T]:\n    \"\"\"Build health route entries for framework integrations.\n\n    Used by Litestar and FastStream health() functions. When options is None,\n    uses build_probe_route_options() defaults.\n\n    Args:\n        probes: Probes to build routes for.\n        add_route: Callback (probe, options) -&gt; route entry for the framework.\n        options: Route options. When None, defaults from build_probe_route_options().\n\n    Returns:\n        List of route entries produced by add_route for each probe.\n    \"\"\"\n    if options is None:\n        options = build_probe_route_options()\n    return _build_health_routes(probes, add_route=add_route, options=options)\n</code></pre>"},{"location":"api/#fast_healthchecks.integrations.base.build_probe_route_options","title":"<code>build_probe_route_options(*, success_handler=default_handler, failure_handler=default_handler, success_status=HTTPStatus.NO_CONTENT, failure_status=HTTPStatus.SERVICE_UNAVAILABLE, debug=False, prefix='/health', timeout=None)</code>","text":"<p>Build ProbeRouteOptions with defaults. Used by health() and _add_probe_route.</p> <p>Parameters:</p> Name Type Description Default <code>success_handler</code> <code>HandlerType</code> <p>Handler for healthy responses. Receives ProbeAsgiResponse.</p> <code>default_handler</code> <code>failure_handler</code> <code>HandlerType</code> <p>Handler for unhealthy responses. Same signature.</p> <code>default_handler</code> <code>success_status</code> <code>int</code> <p>HTTP status for healthy (default 204 No Content).</p> <code>NO_CONTENT</code> <code>failure_status</code> <code>int</code> <p>HTTP status for unhealthy (default 503).</p> <code>SERVICE_UNAVAILABLE</code> <code>debug</code> <code>bool</code> <p>Include check details in responses.</p> <code>False</code> <code>prefix</code> <code>str</code> <p>URL prefix for probe routes (e.g. \"/health\").</p> <code>'/health'</code> <code>timeout</code> <code>float | None</code> <p>Max seconds for all checks; on exceed returns failure. None = no limit.</p> <code>None</code> <p>Returns:</p> Type Description <code>ProbeRouteOptions</code> <p>ProbeRouteOptions for use with HealthcheckRouter or health().</p> Source code in <code>fast_healthchecks/integrations/base.py</code> <pre><code>def build_probe_route_options(  # noqa: PLR0913\n    *,\n    success_handler: HandlerType = default_handler,\n    failure_handler: HandlerType = default_handler,\n    success_status: int = HTTPStatus.NO_CONTENT,\n    failure_status: int = HTTPStatus.SERVICE_UNAVAILABLE,\n    debug: bool = False,\n    prefix: str = \"/health\",\n    timeout: float | None = None,\n) -&gt; ProbeRouteOptions:\n    \"\"\"Build ProbeRouteOptions with defaults. Used by health() and _add_probe_route.\n\n    Args:\n        success_handler: Handler for healthy responses. Receives ProbeAsgiResponse.\n        failure_handler: Handler for unhealthy responses. Same signature.\n        success_status: HTTP status for healthy (default 204 No Content).\n        failure_status: HTTP status for unhealthy (default 503).\n        debug: Include check details in responses.\n        prefix: URL prefix for probe routes (e.g. \"/health\").\n        timeout: Max seconds for all checks; on exceed returns failure. None = no limit.\n\n    Returns:\n        ProbeRouteOptions for use with HealthcheckRouter or health().\n    \"\"\"\n    return ProbeRouteOptions(\n        success_handler=success_handler,\n        failure_handler=failure_handler,\n        success_status=success_status,\n        failure_status=failure_status,\n        debug=debug,\n        timeout=timeout,\n        prefix=prefix,\n    )\n</code></pre>"},{"location":"api/#fast_healthchecks.integrations.base.close_probes","title":"<code>close_probes(probes)</code>  <code>async</code>","text":"<p>Close resources owned by checks in the given probes.</p> <p>Calls <code>aclose()</code> on each check that has it (e.g. checks with cached clients). Ignores exceptions so one failure does not block others. After closing, yields to the event loop a few times so that any transport/socket cleanup callbacks (e.g. from aiohttp connector) can run before the caller's context is torn down (avoids unclosed-resource warnings in tests).</p> <p>Parameters:</p> Name Type Description Default <code>probes</code> <code>Iterable[Probe]</code> <p>Probes whose checks should be closed.</p> required Source code in <code>fast_healthchecks/integrations/base.py</code> <pre><code>async def close_probes(probes: Iterable[Probe]) -&gt; None:\n    \"\"\"Close resources owned by checks in the given probes.\n\n    Calls ``aclose()`` on each check that has it (e.g. checks with cached\n    clients). Ignores exceptions so one failure does not block others.\n    After closing, yields to the event loop a few times so that any\n    transport/socket cleanup callbacks (e.g. from aiohttp connector) can run\n    before the caller's context is torn down (avoids unclosed-resource\n    warnings in tests).\n\n    Args:\n        probes: Probes whose checks should be closed.\n    \"\"\"\n    for probe in probes:\n        for check in probe.checks:\n            aclose = getattr(check, \"aclose\", None)\n            if callable(aclose):\n                with contextlib.suppress(Exception):\n                    await aclose()\n    # aiohttp (opensearch-py) schedules transport cleanup on the next loop\n    # iteration; yield so it can run before the caller tears down.\n    await asyncio.sleep(0)\n</code></pre>"},{"location":"api/#fast_healthchecks.integrations.base.create_probe_route_handler","title":"<code>create_probe_route_handler(probe, params, *, response_factory)</code>","text":"<p>Create an async handler for a probe route.</p> <p>Framework integrations use this with their response_factory to build the handler, then register it (FastAPI add_api_route, FastStream/Litestar return).</p> <p>Parameters:</p> Name Type Description Default <code>probe</code> <code>Probe</code> <p>The probe to run when the route is called.</p> required <code>params</code> <code>ProbeRouteParams</code> <p>Route params (handlers, status codes, etc.).</p> required <code>response_factory</code> <code>Callable[[bytes, dict[str, str], int], _T]</code> <p>Called with (body, headers, status_code); returns framework response.</p> required <p>Returns:</p> Type Description <code>Callable[[], Awaitable[_T]]</code> <p>Async callable that runs the probe and returns the framework response.</p> Source code in <code>fast_healthchecks/integrations/base.py</code> <pre><code>def create_probe_route_handler(\n    probe: Probe,\n    params: ProbeRouteParams,\n    *,\n    response_factory: Callable[[bytes, dict[str, str], int], _T],\n) -&gt; Callable[[], Awaitable[_T]]:\n    \"\"\"Create an async handler for a probe route.\n\n    Framework integrations use this with their response_factory to build\n    the handler, then register it (FastAPI add_api_route, FastStream/Litestar return).\n\n    Args:\n        probe: The probe to run when the route is called.\n        params: Route params (handlers, status codes, etc.).\n        response_factory: Called with (body, headers, status_code); returns framework response.\n\n    Returns:\n        Async callable that runs the probe and returns the framework response.\n    \"\"\"\n    probe_asgi = make_probe_asgi(probe, options=params.to_options())\n\n    async def handler() -&gt; _T:\n        content, headers, status_code = await probe_asgi()\n        return response_factory(content, headers or {}, status_code)\n\n    return handler\n</code></pre>"},{"location":"api/#fast_healthchecks.integrations.base.default_handler","title":"<code>default_handler(response)</code>  <code>async</code>","text":"<p>Default handler for health check route.</p> <p>Returns a minimal body <code>{\"status\": \"healthy\"|\"unhealthy\"}</code> for responses that require content (e.g. 503). Returns <code>None</code> for 204 No Content.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>ProbeAsgiResponse</code> <p>The response from the probe.</p> required <p>Returns:</p> Type Description <code>dict[str, Any] | None</code> <p>Minimal status dict, or None for no response body.</p> Source code in <code>fast_healthchecks/integrations/base.py</code> <pre><code>async def default_handler(response: ProbeAsgiResponse) -&gt; dict[str, Any] | None:\n    \"\"\"Default handler for health check route.\n\n    Returns a minimal body ``{\"status\": \"healthy\"|\"unhealthy\"}`` for responses\n    that require content (e.g. 503). Returns ``None`` for 204 No Content.\n\n    Args:\n        response: The response from the probe.\n\n    Returns:\n        Minimal status dict, or None for no response body.\n    \"\"\"\n    await asyncio.sleep(0)\n    return {\"status\": \"healthy\" if response.healthy else \"unhealthy\"}\n</code></pre>"},{"location":"api/#fast_healthchecks.integrations.base.healthcheck_shutdown","title":"<code>healthcheck_shutdown(probes)</code>","text":"<p>Return an async shutdown callback that closes the given probes' checks.</p> <p>Use this with framework lifespan/shutdown hooks (e.g. Litestar <code>on_shutdown</code>, FastStream shutdown) so that health check resources are closed on app shutdown.</p> <p>Parameters:</p> Name Type Description Default <code>probes</code> <code>Iterable[Probe]</code> <p>The same probes passed to your health routes.</p> required <p>Returns:</p> Type Description <code>Callable[[], Awaitable[None]]</code> <p>An async callable with no arguments that closes all checks with <code>aclose()</code>.</p> Source code in <code>fast_healthchecks/integrations/base.py</code> <pre><code>def healthcheck_shutdown(probes: Iterable[Probe]) -&gt; Callable[[], Awaitable[None]]:\n    \"\"\"Return an async shutdown callback that closes the given probes' checks.\n\n    Use this with framework lifespan/shutdown hooks (e.g. Litestar ``on_shutdown``,\n    FastStream shutdown) so that health check resources are closed on app shutdown.\n\n    Args:\n        probes: The same probes passed to your health routes.\n\n    Returns:\n        An async callable with no arguments that closes all checks with ``aclose()``.\n    \"\"\"\n\n    async def _shutdown() -&gt; None:\n        await close_probes(probes)\n\n    return _shutdown\n</code></pre>"},{"location":"api/#fast_healthchecks.integrations.base.make_probe_asgi","title":"<code>make_probe_asgi(probe, *, options=None)</code>","text":"<p>Create an ASGI probe from a probe.</p> <p>Parameters:</p> Name Type Description Default <code>probe</code> <code>Probe</code> <p>The probe to create the ASGI probe from.</p> required <code>options</code> <code>ProbeRouteOptions | None</code> <p>Route options. When None, defaults from build_probe_route_options().</p> <code>None</code> <p>Returns:</p> Type Description <code>Callable[[], Awaitable[tuple[bytes, dict[str, str] | None, int]]]</code> <p>An ASGI probe.</p> Source code in <code>fast_healthchecks/integrations/base.py</code> <pre><code>def make_probe_asgi(\n    probe: Probe,\n    *,\n    options: ProbeRouteOptions | None = None,\n) -&gt; Callable[[], Awaitable[tuple[bytes, dict[str, str] | None, int]]]:\n    \"\"\"Create an ASGI probe from a probe.\n\n    Args:\n        probe: The probe to create the ASGI probe from.\n        options: Route options. When None, defaults from build_probe_route_options().\n\n    Returns:\n        An ASGI probe.\n    \"\"\"\n    return ProbeAsgi(probe, options=options)\n</code></pre>"},{"location":"api/#fast_healthchecks.integrations.base.probe_path_suffix","title":"<code>probe_path_suffix(probe)</code>","text":"<p>Return the path suffix for a probe (name without leading slash).</p> Source code in <code>fast_healthchecks/integrations/base.py</code> <pre><code>def probe_path_suffix(probe: Probe) -&gt; str:\n    \"\"\"Return the path suffix for a probe (name without leading slash).\"\"\"\n    return probe.name.removeprefix(\"/\")\n</code></pre>"},{"location":"api/#fast_healthchecks.integrations.base.probe_route_path","title":"<code>probe_route_path(probe, prefix='/health')</code>","text":"<p>Return the route path for a probe given a prefix.</p> Source code in <code>fast_healthchecks/integrations/base.py</code> <pre><code>def probe_route_path(probe: Probe, prefix: str = \"/health\") -&gt; str:\n    \"\"\"Return the route path for a probe given a prefix.\"\"\"\n    return f\"{prefix.removesuffix('/')}/{probe_path_suffix(probe)}\"\n</code></pre>"},{"location":"api/#fast_healthchecks.integrations.base.run_probe","title":"<code>run_probe(probe, *, timeout=None, on_check_start=None, on_check_end=None, on_timeout_return_failure=False)</code>  <code>async</code>","text":"<p>Run a probe and return the health check report.</p> <p>Can be used without ASGI (CLI, cron, tests). ProbeAsgi uses this with on_timeout_return_failure=True so timeout behavior is unified.</p> <p>When <code>on_check_start</code> or <code>on_check_end</code> are provided, checks run sequentially (for ordering guarantees). Otherwise they run in parallel.</p> <p>Parameters:</p> Name Type Description Default <code>probe</code> <code>Probe</code> <p>The probe to run.</p> required <code>timeout</code> <code>float | None</code> <p>Maximum seconds for all checks. Raises asyncio.TimeoutError if exceeded unless on_timeout_return_failure is True.</p> <code>None</code> <code>on_check_start</code> <code>OnCheckStart | None</code> <p>Optional callback before each check runs. Receives (check, index).</p> <code>None</code> <code>on_check_end</code> <code>OnCheckEnd | None</code> <p>Optional callback after each check completes. Receives (check, index, result).</p> <code>None</code> <code>on_timeout_return_failure</code> <code>bool</code> <p>If True, on timeout return a report with failed results instead of raising TimeoutError.</p> <code>False</code> <p>Returns:</p> Type Description <code>HealthCheckReport</code> <p>HealthCheckReport with results from all checks.</p> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>When timeout is exceeded and on_timeout_return_failure is False.</p> Source code in <code>fast_healthchecks/integrations/base.py</code> <pre><code>async def run_probe(\n    probe: Probe,\n    *,\n    timeout: float | None = None,\n    on_check_start: OnCheckStart | None = None,\n    on_check_end: OnCheckEnd | None = None,\n    on_timeout_return_failure: bool = False,\n) -&gt; HealthCheckReport:\n    \"\"\"Run a probe and return the health check report.\n\n    Can be used without ASGI (CLI, cron, tests). ProbeAsgi uses this with\n    on_timeout_return_failure=True so timeout behavior is unified.\n\n    When ``on_check_start`` or ``on_check_end`` are provided, checks run\n    sequentially (for ordering guarantees). Otherwise they run in parallel.\n\n    Args:\n        probe: The probe to run.\n        timeout: Maximum seconds for all checks. Raises asyncio.TimeoutError if exceeded\n            unless on_timeout_return_failure is True.\n        on_check_start: Optional callback before each check runs. Receives (check, index).\n        on_check_end: Optional callback after each check completes. Receives (check, index, result).\n        on_timeout_return_failure: If True, on timeout return a report with failed results\n            instead of raising TimeoutError.\n\n    Returns:\n        HealthCheckReport with results from all checks.\n\n    Raises:\n        TimeoutError: When timeout is exceeded and on_timeout_return_failure is False.\n    \"\"\"\n    if on_check_start is None and on_check_end is None:\n        results = await _gather_check_results(\n            probe,\n            timeout=timeout,\n            on_timeout_return_failure=on_timeout_return_failure,\n        )\n    else:\n\n        async def _run_with_hooks() -&gt; list[HealthCheckResult]:\n            out: list[HealthCheckResult] = []\n            for i, check in enumerate(probe.checks):\n                if on_check_start is not None:\n                    await on_check_start(check, i)\n                result = await _run_check_safe(check, i)\n                if on_check_end is not None:\n                    await on_check_end(check, i, result)\n                out.append(result)\n            return out\n\n        try:\n            if timeout is not None:\n                results = await asyncio.wait_for(_run_with_hooks(), timeout=timeout)\n            else:\n                results = await _run_with_hooks()\n        except asyncio.TimeoutError:\n            if on_timeout_return_failure:\n                results = [\n                    HealthCheckResult(\n                        name=_get_check_name(check, i),\n                        healthy=False,\n                        error_details=\"Probe timed out\",\n                    )\n                    for i, check in enumerate(probe.checks)\n                ]\n            else:\n                raise\n\n    return HealthCheckReport(\n        results=results,\n        allow_partial_failure=probe.allow_partial_failure,\n    )\n</code></pre>"},{"location":"api/#fast_healthchecks.integrations.fastapi.HealthcheckRouter","title":"<code>HealthcheckRouter</code>","text":"<p>               Bases: <code>APIRouter</code></p> <p>A router for health checks.</p> <p>Parameters:</p> Name Type Description Default <code>*probes</code> <code>Probe</code> <p>Probes to run (e.g. liveness, readiness, startup).</p> <code>()</code> <code>options</code> <code>ProbeRouteOptions | None</code> <p>Route options. When None, uses build_probe_route_options() defaults.</p> <code>None</code> <p>To close health check resources (e.g. cached clients) on app shutdown, call <code>await router.close()</code> from your FastAPI lifespan, or use <code>healthcheck_shutdown(probes)</code> and call the returned callback.</p> Source code in <code>fast_healthchecks/integrations/fastapi.py</code> <pre><code>class HealthcheckRouter(APIRouter):\n    \"\"\"A router for health checks.\n\n    Args:\n        *probes: Probes to run (e.g. liveness, readiness, startup).\n        options: Route options. When None, uses build_probe_route_options() defaults.\n\n    To close health check resources (e.g. cached clients) on app shutdown,\n    call ``await router.close()`` from your FastAPI lifespan, or use\n    ``healthcheck_shutdown(probes)`` and call the returned callback.\n    \"\"\"\n\n    def __init__(self, *probes: Probe, options: ProbeRouteOptions | None = None) -&gt; None:\n        \"\"\"Initialize the router.\"\"\"\n        if options is None:\n            options = build_probe_route_options()\n        super().__init__(prefix=options.prefix.removesuffix(\"/\"), tags=[\"Healthchecks\"])\n        self._healthcheck_probes: list[Probe] = list(probes)\n        for probe in probes:\n            self._add_probe_route(probe, options=options)\n\n    def _add_probe_route(self, probe: Probe, *, options: ProbeRouteOptions) -&gt; None:\n        params = options.to_route_params()\n        handle_request = create_probe_route_handler(\n            probe,\n            params,\n            response_factory=lambda c, h, s: Response(content=c, status_code=s, headers=h),\n        )\n\n        self.add_api_route(\n            path=f\"/{probe_path_suffix(probe)}\",\n            endpoint=handle_request,\n            status_code=options.success_status,\n            summary=probe.endpoint_summary,\n            include_in_schema=options.debug,\n            response_model=None,\n            response_class=Response,\n        )\n\n    async def close(self) -&gt; None:\n        \"\"\"Close resources owned by this router's health check probes.\n\n        Call this from your FastAPI lifespan shutdown (e.g. after ``yield``\n        in an ``@asynccontextmanager`` lifespan) so cached clients are closed.\n        \"\"\"\n        await close_probes(self._healthcheck_probes)\n</code></pre>"},{"location":"api/#fast_healthchecks.integrations.fastapi.HealthcheckRouter.__init__","title":"<code>__init__(*probes, options=None)</code>","text":"<p>Initialize the router.</p> Source code in <code>fast_healthchecks/integrations/fastapi.py</code> <pre><code>def __init__(self, *probes: Probe, options: ProbeRouteOptions | None = None) -&gt; None:\n    \"\"\"Initialize the router.\"\"\"\n    if options is None:\n        options = build_probe_route_options()\n    super().__init__(prefix=options.prefix.removesuffix(\"/\"), tags=[\"Healthchecks\"])\n    self._healthcheck_probes: list[Probe] = list(probes)\n    for probe in probes:\n        self._add_probe_route(probe, options=options)\n</code></pre>"},{"location":"api/#fast_healthchecks.integrations.fastapi.HealthcheckRouter.close","title":"<code>close()</code>  <code>async</code>","text":"<p>Close resources owned by this router's health check probes.</p> <p>Call this from your FastAPI lifespan shutdown (e.g. after <code>yield</code> in an <code>@asynccontextmanager</code> lifespan) so cached clients are closed.</p> Source code in <code>fast_healthchecks/integrations/fastapi.py</code> <pre><code>async def close(self) -&gt; None:\n    \"\"\"Close resources owned by this router's health check probes.\n\n    Call this from your FastAPI lifespan shutdown (e.g. after ``yield``\n    in an ``@asynccontextmanager`` lifespan) so cached clients are closed.\n    \"\"\"\n    await close_probes(self._healthcheck_probes)\n</code></pre>"},{"location":"api/#fast_healthchecks.integrations.fastapi.healthcheck_shutdown","title":"<code>healthcheck_shutdown(probes)</code>","text":"<p>Return an async shutdown callback that closes the given probes' checks.</p> <p>Use this with framework lifespan/shutdown hooks (e.g. Litestar <code>on_shutdown</code>, FastStream shutdown) so that health check resources are closed on app shutdown.</p> <p>Parameters:</p> Name Type Description Default <code>probes</code> <code>Iterable[Probe]</code> <p>The same probes passed to your health routes.</p> required <p>Returns:</p> Type Description <code>Callable[[], Awaitable[None]]</code> <p>An async callable with no arguments that closes all checks with <code>aclose()</code>.</p> Source code in <code>fast_healthchecks/integrations/base.py</code> <pre><code>def healthcheck_shutdown(probes: Iterable[Probe]) -&gt; Callable[[], Awaitable[None]]:\n    \"\"\"Return an async shutdown callback that closes the given probes' checks.\n\n    Use this with framework lifespan/shutdown hooks (e.g. Litestar ``on_shutdown``,\n    FastStream shutdown) so that health check resources are closed on app shutdown.\n\n    Args:\n        probes: The same probes passed to your health routes.\n\n    Returns:\n        An async callable with no arguments that closes all checks with ``aclose()``.\n    \"\"\"\n\n    async def _shutdown() -&gt; None:\n        await close_probes(probes)\n\n    return _shutdown\n</code></pre>"},{"location":"api/#fast_healthchecks.integrations.faststream.health","title":"<code>health(*probes, options=None)</code>","text":"<p>Make list of routes for healthchecks.</p> <p>Returns:</p> Type Description <code>Iterable[tuple[str, ASGIApp]]</code> <p>Iterable[tuple[str, ASGIApp]]: Generated healthcheck routes.</p> <p>To close health check resources on app shutdown, pass the same probes to <code>healthcheck_shutdown(probes)</code> and register the returned callback with your FastStream app's shutdown hooks (e.g. <code>@app.on_shutdown</code>).</p> Source code in <code>fast_healthchecks/integrations/faststream.py</code> <pre><code>def health(\n    *probes: Probe,\n    options: ProbeRouteOptions | None = None,\n) -&gt; Iterable[tuple[str, ASGIApp]]:\n    \"\"\"Make list of routes for healthchecks.\n\n    Returns:\n        Iterable[tuple[str, ASGIApp]]: Generated healthcheck routes.\n\n    To close health check resources on app shutdown, pass the same probes\n    to ``healthcheck_shutdown(probes)`` and register the returned callback\n    with your FastStream app's shutdown hooks (e.g. ``@app.on_shutdown``).\n    \"\"\"\n    return build_health_routes(probes, add_route=_add_probe_route, options=options)\n</code></pre>"},{"location":"api/#fast_healthchecks.integrations.faststream.healthcheck_shutdown","title":"<code>healthcheck_shutdown(probes)</code>","text":"<p>Return an async shutdown callback that closes the given probes' checks.</p> <p>Use this with framework lifespan/shutdown hooks (e.g. Litestar <code>on_shutdown</code>, FastStream shutdown) so that health check resources are closed on app shutdown.</p> <p>Parameters:</p> Name Type Description Default <code>probes</code> <code>Iterable[Probe]</code> <p>The same probes passed to your health routes.</p> required <p>Returns:</p> Type Description <code>Callable[[], Awaitable[None]]</code> <p>An async callable with no arguments that closes all checks with <code>aclose()</code>.</p> Source code in <code>fast_healthchecks/integrations/base.py</code> <pre><code>def healthcheck_shutdown(probes: Iterable[Probe]) -&gt; Callable[[], Awaitable[None]]:\n    \"\"\"Return an async shutdown callback that closes the given probes' checks.\n\n    Use this with framework lifespan/shutdown hooks (e.g. Litestar ``on_shutdown``,\n    FastStream shutdown) so that health check resources are closed on app shutdown.\n\n    Args:\n        probes: The same probes passed to your health routes.\n\n    Returns:\n        An async callable with no arguments that closes all checks with ``aclose()``.\n    \"\"\"\n\n    async def _shutdown() -&gt; None:\n        await close_probes(probes)\n\n    return _shutdown\n</code></pre>"},{"location":"api/#fast_healthchecks.integrations.litestar.health","title":"<code>health(*probes, options=None)</code>","text":"<p>Make list of routes for healthchecks.</p> <p>Returns:</p> Type Description <code>Iterable[HTTPRouteHandler]</code> <p>Iterable[HTTPRouteHandler]: Generated healthcheck route handlers.</p> <p>To close health check resources on app shutdown, pass the same probes to <code>healthcheck_shutdown(probes)</code> and add the returned callback to Litestar's <code>on_shutdown</code> list.</p> Source code in <code>fast_healthchecks/integrations/litestar.py</code> <pre><code>def health(\n    *probes: Probe,\n    options: ProbeRouteOptions | None = None,\n) -&gt; Iterable[HTTPRouteHandler]:\n    \"\"\"Make list of routes for healthchecks.\n\n    Returns:\n        Iterable[HTTPRouteHandler]: Generated healthcheck route handlers.\n\n    To close health check resources on app shutdown, pass the same probes\n    to ``healthcheck_shutdown(probes)`` and add the returned callback to\n    Litestar's ``on_shutdown`` list.\n    \"\"\"\n    return build_health_routes(probes, add_route=_add_probe_route, options=options)\n</code></pre>"},{"location":"api/#fast_healthchecks.integrations.litestar.healthcheck_shutdown","title":"<code>healthcheck_shutdown(probes)</code>","text":"<p>Return an async shutdown callback that closes the given probes' checks.</p> <p>Use this with framework lifespan/shutdown hooks (e.g. Litestar <code>on_shutdown</code>, FastStream shutdown) so that health check resources are closed on app shutdown.</p> <p>Parameters:</p> Name Type Description Default <code>probes</code> <code>Iterable[Probe]</code> <p>The same probes passed to your health routes.</p> required <p>Returns:</p> Type Description <code>Callable[[], Awaitable[None]]</code> <p>An async callable with no arguments that closes all checks with <code>aclose()</code>.</p> Source code in <code>fast_healthchecks/integrations/base.py</code> <pre><code>def healthcheck_shutdown(probes: Iterable[Probe]) -&gt; Callable[[], Awaitable[None]]:\n    \"\"\"Return an async shutdown callback that closes the given probes' checks.\n\n    Use this with framework lifespan/shutdown hooks (e.g. Litestar ``on_shutdown``,\n    FastStream shutdown) so that health check resources are closed on app shutdown.\n\n    Args:\n        probes: The same probes passed to your health routes.\n\n    Returns:\n        An async callable with no arguments that closes all checks with ``aclose()``.\n    \"\"\"\n\n    async def _shutdown() -&gt; None:\n        await close_probes(probes)\n\n    return _shutdown\n</code></pre>"},{"location":"api/#fast_healthchecks.utils.maybe_redact","title":"<code>maybe_redact(data, *, redact_secrets)</code>","text":"<p>Return data with secrets redacted if requested, otherwise return as-is.</p> Source code in <code>fast_healthchecks/utils.py</code> <pre><code>def maybe_redact(data: dict[str, Any], *, redact_secrets: bool) -&gt; dict[str, Any]:\n    \"\"\"Return data with secrets redacted if requested, otherwise return as-is.\"\"\"\n    return redact_secrets_in_dict(data) if redact_secrets else data\n</code></pre>"},{"location":"api/#fast_healthchecks.utils.parse_query_string","title":"<code>parse_query_string(query)</code>","text":"<p>Parse a URL query string into a dictionary.</p> <p>Keys and values are URL-decoded (unquoted). Pairs without '=' are stored with an empty value. Values containing '=' are preserved.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>The query string (e.g. 'key1=value1&amp;key2=value2').</p> required <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>A dictionary of key-value pairs.</p> Source code in <code>fast_healthchecks/utils.py</code> <pre><code>def parse_query_string(query: str) -&gt; dict[str, str]:\n    \"\"\"Parse a URL query string into a dictionary.\n\n    Keys and values are URL-decoded (unquoted). Pairs without '=' are stored\n    with an empty value. Values containing '=' are preserved.\n\n    Args:\n        query: The query string (e.g. 'key1=value1&amp;key2=value2').\n\n    Returns:\n        A dictionary of key-value pairs.\n    \"\"\"\n    if not query:\n        return {}\n    result: dict[str, str] = {}\n    for part in query.split(\"&amp;\"):\n        kv = part.split(\"=\", 1)\n        key = unquote(kv[0]) if kv[0] else \"\"\n        value = unquote(kv[1]) if len(kv) &gt; 1 else \"\"\n        result[key] = value\n    return result\n</code></pre>"},{"location":"api/#fast_healthchecks.utils.redact_secrets_in_dict","title":"<code>redact_secrets_in_dict(data)</code>","text":"<p>Return a copy of data with credential fields replaced by placeholder.</p> Source code in <code>fast_healthchecks/utils.py</code> <pre><code>def redact_secrets_in_dict(data: dict[str, Any]) -&gt; dict[str, Any]:\n    \"\"\"Return a copy of data with credential fields replaced by placeholder.\"\"\"\n    return {k: (REDACT_PLACEHOLDER if k in _SECRET_KEYS else v) for k, v in data.items()}\n</code></pre>"},{"location":"api/#fast_healthchecks.utils.validate_host_ssrf_async","title":"<code>validate_host_ssrf_async(host)</code>  <code>async</code>","text":"<p>Resolve host to IP(s) and reject if any are loopback/private/reserved (SSRF/DNS rebinding).</p> <p>Call this before making the request when block_private_hosts=True, so that hostnames that resolve to private IPs (e.g. internal DNS or DNS rebinding) are rejected.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>The hostname to resolve and validate.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If any resolved IP is loopback, private, or reserved.</p> Source code in <code>fast_healthchecks/utils.py</code> <pre><code>async def validate_host_ssrf_async(host: str) -&gt; None:\n    \"\"\"Resolve host to IP(s) and reject if any are loopback/private/reserved (SSRF/DNS rebinding).\n\n    Call this before making the request when block_private_hosts=True, so that\n    hostnames that resolve to private IPs (e.g. internal DNS or DNS rebinding)\n    are rejected.\n\n    Args:\n        host: The hostname to resolve and validate.\n\n    Raises:\n        ValueError: If any resolved IP is loopback, private, or reserved.\n    \"\"\"\n    host = (host or \"\").strip()\n    if not host:\n        return\n    if host.lower() in {\"localhost\", \"localhost.\", \"localhost6\", \"localhost6.localdomain6\"}:\n        msg = \"URL host must not be localhost when block_private_hosts=True\"\n        raise ValueError(msg)\n    try:\n        loop = asyncio.get_running_loop()\n        infos = await loop.run_in_executor(None, lambda: socket.getaddrinfo(host, None))\n    except OSError:\n        # Resolution failed; let the subsequent request fail or handle\n        return\n    for _family, _type, _proto, _canon, sockaddr in infos:\n        if not sockaddr:\n            continue\n        ip_str = sockaddr[0] if isinstance(sockaddr, (list, tuple)) else getattr(sockaddr, \"host\", None)\n        if not ip_str:\n            continue\n        addr = _parse_ip_safe(ip_str)\n        if addr is None:\n            continue\n        if addr.is_loopback or addr.is_private or addr.is_reserved:\n            msg = \"URL host must not resolve to loopback or private when block_private_hosts=True\"\n            raise ValueError(msg)\n</code></pre>"},{"location":"api/#fast_healthchecks.utils.validate_url_ssrf","title":"<code>validate_url_ssrf(url, *, allowed_schemes=frozenset({'http', 'https'}), block_private_hosts=False)</code>","text":"<p>Validate URL for SSRF-sensitive use (e.g. healthchecks from config).</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL string to validate.</p> required <code>allowed_schemes</code> <code>frozenset[str]</code> <p>Schemes permitted (default http, https).</p> <code>frozenset({'http', 'https'})</code> <code>block_private_hosts</code> <code>bool</code> <p>If True, reject localhost and private IP ranges.</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If scheme is not allowed or host is in blocked range.</p> Source code in <code>fast_healthchecks/utils.py</code> <pre><code>def validate_url_ssrf(\n    url: str,\n    *,\n    allowed_schemes: frozenset[str] = frozenset({\"http\", \"https\"}),\n    block_private_hosts: bool = False,\n) -&gt; None:\n    \"\"\"Validate URL for SSRF-sensitive use (e.g. healthchecks from config).\n\n    Args:\n        url: The URL string to validate.\n        allowed_schemes: Schemes permitted (default http, https).\n        block_private_hosts: If True, reject localhost and private IP ranges.\n\n    Raises:\n        ValueError: If scheme is not allowed or host is in blocked range.\n    \"\"\"\n    parsed = urlparse(url)\n    scheme = (parsed.scheme or \"\").lower()\n    if scheme not in allowed_schemes:\n        msg = f\"URL scheme must be one of {sorted(allowed_schemes)}, got {scheme!r}\"\n        raise ValueError(msg)\n    if not block_private_hosts:\n        return\n    host = (parsed.hostname or \"\").strip()\n    if not host:\n        return\n    if host.lower() in {\"localhost\", \"localhost.\", \"localhost6\", \"localhost6.localdomain6\"}:\n        msg = \"URL host must not be localhost when block_private_hosts=True\"\n        raise ValueError(msg)\n    addr = _parse_ip_safe(host)\n    if addr is None:\n        return\n    if addr.is_loopback or addr.is_private or addr.is_reserved:\n        msg = \"URL host must not be loopback or private when block_private_hosts=True\"\n        raise ValueError(msg)\n</code></pre>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#100-2026-02-15","title":"1.0.0 (2026-02-15)","text":""},{"location":"changelog/#fix","title":"Fix","text":"<ul> <li>checks: fixed <code>__slots__</code> in <code>RabbitMQHealthCheck</code>, renamed <code>check_pydantinc_installed</code> -&gt; <code>check_pydantic_installed</code>, <code>from_dsn</code> for <code>MongoHealthCheck</code> and <code>parse_dsn</code> for <code>BasePostgreSQLHealthCheck</code> more stable</li> </ul>"},{"location":"changelog/#024-2025-09-19","title":"0.2.4 (2025-09-19)","text":""},{"location":"changelog/#fix_1","title":"Fix","text":"<ul> <li>typing: prevent typing from failing</li> </ul>"},{"location":"changelog/#023-2025-09-19","title":"0.2.3 (2025-09-19)","text":""},{"location":"changelog/#fix_2","title":"Fix","text":"<ul> <li>all: upgrade dependencies, make tests more stable, switch <code>mypy</code> to <code>ty</code></li> </ul>"},{"location":"changelog/#022-2025-04-16","title":"0.2.2 (2025-04-16)","text":""},{"location":"changelog/#fix_3","title":"Fix","text":"<ul> <li>all: make PEP 561 compatible</li> </ul>"},{"location":"changelog/#021-2025-03-07","title":"0.2.1 (2025-03-07)","text":""},{"location":"changelog/#fix_4","title":"Fix","text":"<ul> <li>mongo: added multihost support for MongoDB</li> </ul>"},{"location":"changelog/#020-2025-02-20","title":"0.2.0 (2025-02-20)","text":""},{"location":"changelog/#feat","title":"Feat","text":"<ul> <li>healthchecks: added OpenSearch healthcheck</li> </ul>"},{"location":"changelog/#fix_5","title":"Fix","text":"<ul> <li>dependencies: upgrade github actions</li> <li>vscode: fixed ruff plugin setup</li> <li>dependencies: upgrade dependencies</li> <li>dependencies: upgrade pre-commit</li> <li>docs: typo in install commands</li> </ul>"},{"location":"changelog/#refactor","title":"Refactor","text":"<ul> <li>tests: move <code>to_dict</code> method out of tests</li> </ul>"},{"location":"changelog/#015-2025-01-23","title":"0.1.5 (2025-01-23)","text":""},{"location":"changelog/#fix_6","title":"Fix","text":"<ul> <li>redis: added support for SSL connections</li> </ul>"},{"location":"changelog/#014-2025-01-22","title":"0.1.4 (2025-01-22)","text":""},{"location":"changelog/#fix_7","title":"Fix","text":"<ul> <li>dependencies: upgrade dependencies and pre-commit</li> <li>mongo: fixed Mongo check</li> </ul>"},{"location":"changelog/#013-2024-12-10","title":"0.1.3 (2024-12-10)","text":""},{"location":"changelog/#fix_8","title":"Fix","text":"<ul> <li>validate_dsn: removed dummy validation isinstance</li> </ul>"},{"location":"changelog/#012-2024-12-10","title":"0.1.2 (2024-12-10)","text":""},{"location":"changelog/#fix_9","title":"Fix","text":"<ul> <li>setuptools: included packages</li> <li>docs: changed logo for documentation to green color</li> </ul>"},{"location":"changelog/#011-2024-12-09","title":"0.1.1 (2024-12-09)","text":""},{"location":"changelog/#fix_10","title":"Fix","text":"<ul> <li>docs: fixed <code>README.md</code></li> </ul>"},{"location":"changelog/#010-2024-12-09","title":"0.1.0 (2024-12-09)","text":""},{"location":"changelog/#feat_1","title":"Feat","text":"<ul> <li>all: \ud83d\ude80 INIT</li> </ul>"},{"location":"decisions/001-check-contract/","title":"ADR 001: Health check contract (DSN, name, lifecycle)","text":""},{"location":"decisions/001-check-contract/#status","title":"Status","text":"<p>Accepted.</p>"},{"location":"decisions/001-check-contract/#context","title":"Context","text":"<p>Check classes need a consistent contract for DSN handling, display names, and client lifecycle.</p>"},{"location":"decisions/001-check-contract/#decision","title":"Decision","text":"<ul> <li>DSN: <code>fast_healthchecks.dsn</code> provides NewTypes (AmqpDsn, RedisDsn, etc.) for typing only. Each <code>HealthCheckDSN</code> subclass implements <code>parse_dsn()</code> and <code>validate_dsn()</code>; no shared DSN runtime logic.</li> <li>Name: All checks expose <code>_name</code> (str), used in <code>HealthCheckResult</code> and error reporting. <code>_get_check_name()</code> falls back to <code>name</code> or <code>\"Check-{index}\"</code>.</li> <li>Lifecycle: <code>ClientCachingMixin._close_client(client)</code> must return <code>Awaitable[None]</code> (not <code>None</code>). Per-call checks (RabbitMQ, PostgreSQL) do not use <code>ClientCachingMixin</code>.</li> <li>Config: Connection-based checks accept an optional <code>config: XConfig | None</code>; when <code>None</code>, config is built from <code>**kwargs</code>. Config dataclasses live in <code>fast_healthchecks.checks._configs</code>, are immutable (frozen), and provide <code>to_dict()</code> for serialization. This avoids long parameter lists and centralizes <code>_build_dict()</code> logic.</li> </ul>"}]}